#![doc = "Peripheral access API for STM32F0XX microcontrollers (generated using svd2rust v0.6.1)"]
#![deny ( missing_docs )]
#![deny ( warnings )]
#![feature ( const_fn )]
#![no_std]
extern crate cortex_m ;
extern crate vcell ;
use core::ops::Deref;
use cortex_m::peripheral::Peripheral;
#[doc = r" Interrupts"]
pub mod interrupt {
    use cortex_m::ctxt::Context;
    use cortex_m::exception;
    use cortex_m::interrupt::Nr;
    #[doc = "0 - Window Watchdog interrupt"]
    pub struct WwdgIrq {
        _0: (),
    }
    unsafe impl Context for WwdgIrq {}
    unsafe impl Nr for WwdgIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            0
        }
    }
    #[doc = "1 - PVD through EXTI line detection"]
    pub struct PvdIrq {
        _0: (),
    }
    unsafe impl Context for PvdIrq {}
    unsafe impl Nr for PvdIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            1
        }
    }
    #[doc = "2 - RTC global interrupt"]
    pub struct RtcIrq {
        _0: (),
    }
    unsafe impl Context for RtcIrq {}
    unsafe impl Nr for RtcIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            2
        }
    }
    #[doc = "3 - Flash global interrupt"]
    pub struct FlashIrq {
        _0: (),
    }
    unsafe impl Context for FlashIrq {}
    unsafe impl Nr for FlashIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            3
        }
    }
    #[doc = "4 - RCC global interrupt"]
    pub struct RccIrq {
        _0: (),
    }
    unsafe impl Context for RccIrq {}
    unsafe impl Nr for RccIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            4
        }
    }
    # [ doc = "5 - EXTI Line[1:0] interrupts" ]
    pub struct Exti01Irq {
        _0: (),
    }
    unsafe impl Context for Exti01Irq {}
    unsafe impl Nr for Exti01Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            5
        }
    }
    # [ doc = "6 - EXTI Line[3:2] interrupts" ]
    pub struct Exti23Irq {
        _0: (),
    }
    unsafe impl Context for Exti23Irq {}
    unsafe impl Nr for Exti23Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            6
        }
    }
    #[doc = "7 - EXTI Line15 and EXTI4 interrupts"]
    pub struct Exti415Irq {
        _0: (),
    }
    unsafe impl Context for Exti415Irq {}
    unsafe impl Nr for Exti415Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            7
        }
    }
    #[doc = "8 - Touch sensing interrupt"]
    pub struct TscIrq {
        _0: (),
    }
    unsafe impl Context for TscIrq {}
    unsafe impl Nr for TscIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            8
        }
    }
    #[doc = "9 - DMA channel 1 interrupt"]
    pub struct DmaCh1Irq {
        _0: (),
    }
    unsafe impl Context for DmaCh1Irq {}
    unsafe impl Nr for DmaCh1Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            9
        }
    }
    #[doc = "10 - DMA channel 2 and 3 interrupts"]
    pub struct DmaCh23Irq {
        _0: (),
    }
    unsafe impl Context for DmaCh23Irq {}
    unsafe impl Nr for DmaCh23Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            10
        }
    }
    #[doc = "11 - DMA channel 4 and 5 interrupts"]
    pub struct DmaCh45Irq {
        _0: (),
    }
    unsafe impl Context for DmaCh45Irq {}
    unsafe impl Nr for DmaCh45Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            11
        }
    }
    #[doc = "12 - ADC and comparator 1 and 2"]
    pub struct AdcCompIrq {
        _0: (),
    }
    unsafe impl Context for AdcCompIrq {}
    unsafe impl Nr for AdcCompIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            12
        }
    }
    #[doc = "13 - TIM1 Break, update, trigger and"]
    pub struct Tim1BrkUpIrq {
        _0: (),
    }
    unsafe impl Context for Tim1BrkUpIrq {}
    unsafe impl Nr for Tim1BrkUpIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            13
        }
    }
    #[doc = "14 - TIM1 Capture Compare interrupt"]
    pub struct Tim1CcIrq {
        _0: (),
    }
    unsafe impl Context for Tim1CcIrq {}
    unsafe impl Nr for Tim1CcIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            14
        }
    }
    #[doc = "15 - TIM2 global interrupt"]
    pub struct Tim2Irq {
        _0: (),
    }
    unsafe impl Context for Tim2Irq {}
    unsafe impl Nr for Tim2Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            15
        }
    }
    #[doc = "16 - TIM3 global interrupt"]
    pub struct Tim3Irq {
        _0: (),
    }
    unsafe impl Context for Tim3Irq {}
    unsafe impl Nr for Tim3Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            16
        }
    }
    #[doc = "17 - TIM6 global interrupt and DAC"]
    pub struct Tim6DacIrq {
        _0: (),
    }
    unsafe impl Context for Tim6DacIrq {}
    unsafe impl Nr for Tim6DacIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            17
        }
    }
    #[doc = "19 - TIM14 global interrupt"]
    pub struct Tim14Irq {
        _0: (),
    }
    unsafe impl Context for Tim14Irq {}
    unsafe impl Nr for Tim14Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            19
        }
    }
    #[doc = "20 - TIM15 global interrupt"]
    pub struct Tim15Irq {
        _0: (),
    }
    unsafe impl Context for Tim15Irq {}
    unsafe impl Nr for Tim15Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            20
        }
    }
    #[doc = "21 - TIM16 global interrupt"]
    pub struct Tim16Irq {
        _0: (),
    }
    unsafe impl Context for Tim16Irq {}
    unsafe impl Nr for Tim16Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            21
        }
    }
    #[doc = "22 - TIM17 global interrupt"]
    pub struct Tim17Irq {
        _0: (),
    }
    unsafe impl Context for Tim17Irq {}
    unsafe impl Nr for Tim17Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            22
        }
    }
    #[doc = "23 - I2C1 global interrupt"]
    pub struct I2c1Irq {
        _0: (),
    }
    unsafe impl Context for I2c1Irq {}
    unsafe impl Nr for I2c1Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            23
        }
    }
    #[doc = "24 - I2C2 global interrupt"]
    pub struct I2c2Irq {
        _0: (),
    }
    unsafe impl Context for I2c2Irq {}
    unsafe impl Nr for I2c2Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            24
        }
    }
    #[doc = "25 - SPI1_global_interrupt"]
    pub struct Spi1Irq {
        _0: (),
    }
    unsafe impl Context for Spi1Irq {}
    unsafe impl Nr for Spi1Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            25
        }
    }
    #[doc = "26 - SPI2 global interrupt"]
    pub struct Spi2Irq {
        _0: (),
    }
    unsafe impl Context for Spi2Irq {}
    unsafe impl Nr for Spi2Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            26
        }
    }
    #[doc = "27 - USART1 global interrupt"]
    pub struct Usart1Irq {
        _0: (),
    }
    unsafe impl Context for Usart1Irq {}
    unsafe impl Nr for Usart1Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            27
        }
    }
    #[doc = "28 - USART2 global interrupt"]
    pub struct Usart2Irq {
        _0: (),
    }
    unsafe impl Context for Usart2Irq {}
    unsafe impl Nr for Usart2Irq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            28
        }
    }
    #[doc = "30 - CEC global interrupt"]
    pub struct CecIrq {
        _0: (),
    }
    unsafe impl Context for CecIrq {}
    unsafe impl Nr for CecIrq {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            30
        }
    }
    use cortex_m::Reserved;
    #[doc = r" Interrupt handlers"]
    #[allow ( non_snake_case )]
    #[repr ( C )]
    pub struct Handlers {
        #[doc = "0 - Window Watchdog interrupt"]
        pub WwdgIrq: extern "C" fn(WwdgIrq),
        #[doc = "1 - PVD through EXTI line detection"]
        pub PvdIrq: extern "C" fn(PvdIrq),
        #[doc = "2 - RTC global interrupt"]
        pub RtcIrq: extern "C" fn(RtcIrq),
        #[doc = "3 - Flash global interrupt"]
        pub FlashIrq: extern "C" fn(FlashIrq),
        #[doc = "4 - RCC global interrupt"]
        pub RccIrq: extern "C" fn(RccIrq),
        # [ doc = "5 - EXTI Line[1:0] interrupts" ]
        pub Exti01Irq: extern "C" fn(Exti01Irq),
        # [ doc = "6 - EXTI Line[3:2] interrupts" ]
        pub Exti23Irq: extern "C" fn(Exti23Irq),
        #[doc = "7 - EXTI Line15 and EXTI4 interrupts"]
        pub Exti415Irq: extern "C" fn(Exti415Irq),
        #[doc = "8 - Touch sensing interrupt"]
        pub TscIrq: extern "C" fn(TscIrq),
        #[doc = "9 - DMA channel 1 interrupt"]
        pub DmaCh1Irq: extern "C" fn(DmaCh1Irq),
        #[doc = "10 - DMA channel 2 and 3 interrupts"]
        pub DmaCh23Irq: extern "C" fn(DmaCh23Irq),
        #[doc = "11 - DMA channel 4 and 5 interrupts"]
        pub DmaCh45Irq: extern "C" fn(DmaCh45Irq),
        #[doc = "12 - ADC and comparator 1 and 2"]
        pub AdcCompIrq: extern "C" fn(AdcCompIrq),
        #[doc = "13 - TIM1 Break, update, trigger and"]
        pub Tim1BrkUpIrq: extern "C" fn(Tim1BrkUpIrq),
        #[doc = "14 - TIM1 Capture Compare interrupt"]
        pub Tim1CcIrq: extern "C" fn(Tim1CcIrq),
        #[doc = "15 - TIM2 global interrupt"]
        pub Tim2Irq: extern "C" fn(Tim2Irq),
        #[doc = "16 - TIM3 global interrupt"]
        pub Tim3Irq: extern "C" fn(Tim3Irq),
        #[doc = "17 - TIM6 global interrupt and DAC"]
        pub Tim6DacIrq: extern "C" fn(Tim6DacIrq),
        #[doc = r" Reserved spot in the vector table"]
        pub _reserved0: [Reserved; 1],
        #[doc = "19 - TIM14 global interrupt"]
        pub Tim14Irq: extern "C" fn(Tim14Irq),
        #[doc = "20 - TIM15 global interrupt"]
        pub Tim15Irq: extern "C" fn(Tim15Irq),
        #[doc = "21 - TIM16 global interrupt"]
        pub Tim16Irq: extern "C" fn(Tim16Irq),
        #[doc = "22 - TIM17 global interrupt"]
        pub Tim17Irq: extern "C" fn(Tim17Irq),
        #[doc = "23 - I2C1 global interrupt"]
        pub I2c1Irq: extern "C" fn(I2c1Irq),
        #[doc = "24 - I2C2 global interrupt"]
        pub I2c2Irq: extern "C" fn(I2c2Irq),
        #[doc = "25 - SPI1_global_interrupt"]
        pub Spi1Irq: extern "C" fn(Spi1Irq),
        #[doc = "26 - SPI2 global interrupt"]
        pub Spi2Irq: extern "C" fn(Spi2Irq),
        #[doc = "27 - USART1 global interrupt"]
        pub Usart1Irq: extern "C" fn(Usart1Irq),
        #[doc = "28 - USART2 global interrupt"]
        pub Usart2Irq: extern "C" fn(Usart2Irq),
        #[doc = r" Reserved spot in the vector table"]
        pub _reserved1: [Reserved; 1],
        #[doc = "30 - CEC global interrupt"]
        pub CecIrq: extern "C" fn(CecIrq),
    }
    #[doc = r" Default interrupt handlers"]
    pub const DEFAULT_HANDLERS: Handlers = Handlers {
        WwdgIrq: exception::default_handler,
        PvdIrq: exception::default_handler,
        RtcIrq: exception::default_handler,
        FlashIrq: exception::default_handler,
        RccIrq: exception::default_handler,
        Exti01Irq: exception::default_handler,
        Exti23Irq: exception::default_handler,
        Exti415Irq: exception::default_handler,
        TscIrq: exception::default_handler,
        DmaCh1Irq: exception::default_handler,
        DmaCh23Irq: exception::default_handler,
        DmaCh45Irq: exception::default_handler,
        AdcCompIrq: exception::default_handler,
        Tim1BrkUpIrq: exception::default_handler,
        Tim1CcIrq: exception::default_handler,
        Tim2Irq: exception::default_handler,
        Tim3Irq: exception::default_handler,
        Tim6DacIrq: exception::default_handler,
        _reserved0: [Reserved::Vector; 1],
        Tim14Irq: exception::default_handler,
        Tim15Irq: exception::default_handler,
        Tim16Irq: exception::default_handler,
        Tim17Irq: exception::default_handler,
        I2c1Irq: exception::default_handler,
        I2c2Irq: exception::default_handler,
        Spi1Irq: exception::default_handler,
        Spi2Irq: exception::default_handler,
        Usart1Irq: exception::default_handler,
        Usart2Irq: exception::default_handler,
        _reserved1: [Reserved::Vector; 1],
        CecIrq: exception::default_handler,
    };
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - Window Watchdog interrupt"]
        WwdgIrq,
        #[doc = "1 - PVD through EXTI line detection"]
        PvdIrq,
        #[doc = "2 - RTC global interrupt"]
        RtcIrq,
        #[doc = "3 - Flash global interrupt"]
        FlashIrq,
        #[doc = "4 - RCC global interrupt"]
        RccIrq,
        # [ doc = "5 - EXTI Line[1:0] interrupts" ]
        Exti01Irq,
        # [ doc = "6 - EXTI Line[3:2] interrupts" ]
        Exti23Irq,
        #[doc = "7 - EXTI Line15 and EXTI4 interrupts"]
        Exti415Irq,
        #[doc = "8 - Touch sensing interrupt"]
        TscIrq,
        #[doc = "9 - DMA channel 1 interrupt"]
        DmaCh1Irq,
        #[doc = "10 - DMA channel 2 and 3 interrupts"]
        DmaCh23Irq,
        #[doc = "11 - DMA channel 4 and 5 interrupts"]
        DmaCh45Irq,
        #[doc = "12 - ADC and comparator 1 and 2"]
        AdcCompIrq,
        #[doc = "13 - TIM1 Break, update, trigger and"]
        Tim1BrkUpIrq,
        #[doc = "14 - TIM1 Capture Compare interrupt"]
        Tim1CcIrq,
        #[doc = "15 - TIM2 global interrupt"]
        Tim2Irq,
        #[doc = "16 - TIM3 global interrupt"]
        Tim3Irq,
        #[doc = "17 - TIM6 global interrupt and DAC"]
        Tim6DacIrq,
        #[doc = "19 - TIM14 global interrupt"]
        Tim14Irq,
        #[doc = "20 - TIM15 global interrupt"]
        Tim15Irq,
        #[doc = "21 - TIM16 global interrupt"]
        Tim16Irq,
        #[doc = "22 - TIM17 global interrupt"]
        Tim17Irq,
        #[doc = "23 - I2C1 global interrupt"]
        I2c1Irq,
        #[doc = "24 - I2C2 global interrupt"]
        I2c2Irq,
        #[doc = "25 - SPI1_global_interrupt"]
        Spi1Irq,
        #[doc = "26 - SPI2 global interrupt"]
        Spi2Irq,
        #[doc = "27 - USART1 global interrupt"]
        Usart1Irq,
        #[doc = "28 - USART2 global interrupt"]
        Usart2Irq,
        #[doc = "30 - CEC global interrupt"]
        CecIrq,
    }
    unsafe impl Nr for Interrupt {
        #[inline ( always )]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::WwdgIrq => 0,
                Interrupt::PvdIrq => 1,
                Interrupt::RtcIrq => 2,
                Interrupt::FlashIrq => 3,
                Interrupt::RccIrq => 4,
                Interrupt::Exti01Irq => 5,
                Interrupt::Exti23Irq => 6,
                Interrupt::Exti415Irq => 7,
                Interrupt::TscIrq => 8,
                Interrupt::DmaCh1Irq => 9,
                Interrupt::DmaCh23Irq => 10,
                Interrupt::DmaCh45Irq => 11,
                Interrupt::AdcCompIrq => 12,
                Interrupt::Tim1BrkUpIrq => 13,
                Interrupt::Tim1CcIrq => 14,
                Interrupt::Tim2Irq => 15,
                Interrupt::Tim3Irq => 16,
                Interrupt::Tim6DacIrq => 17,
                Interrupt::Tim14Irq => 19,
                Interrupt::Tim15Irq => 20,
                Interrupt::Tim16Irq => 21,
                Interrupt::Tim17Irq => 22,
                Interrupt::I2c1Irq => 23,
                Interrupt::I2c2Irq => 24,
                Interrupt::Spi1Irq => 25,
                Interrupt::Spi2Irq => 26,
                Interrupt::Usart1Irq => 27,
                Interrupt::Usart2Irq => 28,
                Interrupt::CecIrq => 30,
            }
        }
    }
}
#[doc = "cyclic redundancy check calculation unit"]
pub const CRC: Peripheral<Crc> = unsafe { Peripheral::new(1073885184) };
#[doc = "cyclic redundancy check calculation unit"]
pub mod crc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Data register"]
        pub dr: Dr,
        #[doc = "0x04 - Independent data register"]
        pub idr: Idr,
        #[doc = "0x08 - Control register"]
        pub cr: Cr,
        #[doc = "0x0c - Initial CRC value"]
        pub init: Init,
    }
    #[doc = "Data register"]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    #[doc = "Data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DrR {
            bits: u32,
        }
        impl DrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data register bits"]
            #[inline ( always )]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data register bits"]
            #[inline ( always )]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    #[doc = "Independent data register"]
    pub struct Idr {
        register: VolatileCell<u32>,
    }
    #[doc = "Independent data register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Idr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct IdrR {
            bits: u8,
        }
        impl IdrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IdrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
            #[inline ( always )]
            pub fn idr(&self) -> IdrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
            #[inline ( always )]
            pub fn idr(&mut self) -> _IdrW {
                _IdrW { w: self }
            }
        }
    }
    #[doc = "Control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ResetR {
            bits: u8,
        }
        impl ResetR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RevInR {
            bits: u8,
        }
        impl RevInR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RevOutR {
            bits: u8,
        }
        impl RevOutR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ResetW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResetW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RevInW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RevInW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RevOutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RevOutW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - reset bit"]
            #[inline ( always )]
            pub fn reset(&self) -> ResetR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ResetR { bits }
            }
            #[doc = "Bits 5:6 - Reverse input data"]
            #[inline ( always )]
            pub fn rev_in(&self) -> RevInR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RevInR { bits }
            }
            #[doc = "Bit 7 - Reverse output data"]
            #[inline ( always )]
            pub fn rev_out(&self) -> RevOutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RevOutR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - reset bit"]
            #[inline ( always )]
            pub fn reset(&mut self) -> _ResetW {
                _ResetW { w: self }
            }
            #[doc = "Bits 5:6 - Reverse input data"]
            #[inline ( always )]
            pub fn rev_in(&mut self) -> _RevInW {
                _RevInW { w: self }
            }
            #[doc = "Bit 7 - Reverse output data"]
            #[inline ( always )]
            pub fn rev_out(&mut self) -> _RevOutW {
                _RevOutW { w: self }
            }
        }
    }
    #[doc = "Initial CRC value"]
    pub struct Init {
        register: VolatileCell<u32>,
    }
    #[doc = "Initial CRC value"]
    pub mod init {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Init {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct InitR {
            bits: u32,
        }
        impl InitR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _InitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _InitW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Programmable initial CRC value"]
            #[inline ( always )]
            pub fn init(&self) -> InitR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                InitR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Programmable initial CRC value"]
            #[inline ( always )]
            pub fn init(&mut self) -> _InitW {
                _InitW { w: self }
            }
        }
    }
}
#[doc = "cyclic redundancy check calculation unit"]
pub struct Crc {
    register_block: crc::RegisterBlock,
}
impl Deref for Crc {
    type Target = crc::RegisterBlock;
    fn deref(&self) -> &crc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose I/Os"]
pub const GPIOF: Peripheral<Gpiof> = unsafe { Peripheral::new(1207964672) };
#[doc = "General-purpose I/Os"]
pub mod gpiof {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - GPIO port mode register"]
        pub moder: Moder,
        #[doc = "0x04 - GPIO port output type register"]
        pub otyper: Otyper,
        #[doc = "0x08 - GPIO port output speed register"]
        pub ospeedr: Ospeedr,
        #[doc = "0x0c - GPIO port pull-up/pull-down register"]
        pub pupdr: Pupdr,
        #[doc = "0x10 - GPIO port input data register"]
        pub idr: Idr,
        #[doc = "0x14 - GPIO port output data register"]
        pub odr: Odr,
        #[doc = "0x18 - GPIO port bit set/reset register"]
        pub bsrr: Bsrr,
        #[doc = "0x1c - GPIO port configuration lock register"]
        pub lckr: Lckr,
        #[doc = "0x20 - GPIO alternate function low register"]
        pub afrl: Afrl,
        #[doc = "0x24 - GPIO alternate function high register"]
        pub afrh: Afrh,
        #[doc = "0x28 - Port bit reset register"]
        pub brr: Brr,
    }
    #[doc = "GPIO port mode register"]
    pub struct Moder {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port mode register"]
    pub mod moder {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Moder {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder15R {
            bits: u8,
        }
        impl Moder15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder14R {
            bits: u8,
        }
        impl Moder14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder13R {
            bits: u8,
        }
        impl Moder13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder12R {
            bits: u8,
        }
        impl Moder12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder11R {
            bits: u8,
        }
        impl Moder11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder10R {
            bits: u8,
        }
        impl Moder10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder9R {
            bits: u8,
        }
        impl Moder9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder8R {
            bits: u8,
        }
        impl Moder8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder7R {
            bits: u8,
        }
        impl Moder7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder6R {
            bits: u8,
        }
        impl Moder6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder5R {
            bits: u8,
        }
        impl Moder5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder4R {
            bits: u8,
        }
        impl Moder4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder3R {
            bits: u8,
        }
        impl Moder3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder2R {
            bits: u8,
        }
        impl Moder2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder1R {
            bits: u8,
        }
        impl Moder1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder0R {
            bits: u8,
        }
        impl Moder0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder15(&self) -> Moder15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder14(&self) -> Moder14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder13(&self) -> Moder13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder12(&self) -> Moder12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder11(&self) -> Moder11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder10(&self) -> Moder10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder9(&self) -> Moder9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder8(&self) -> Moder8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder7(&self) -> Moder7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder6(&self) -> Moder6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder5(&self) -> Moder5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder4(&self) -> Moder4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder3(&self) -> Moder3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder2(&self) -> Moder2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder1(&self) -> Moder1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder0(&self) -> Moder0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder15(&mut self) -> _Moder15W {
                _Moder15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder14(&mut self) -> _Moder14W {
                _Moder14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder13(&mut self) -> _Moder13W {
                _Moder13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder12(&mut self) -> _Moder12W {
                _Moder12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder11(&mut self) -> _Moder11W {
                _Moder11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder10(&mut self) -> _Moder10W {
                _Moder10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder9(&mut self) -> _Moder9W {
                _Moder9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder8(&mut self) -> _Moder8W {
                _Moder8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder7(&mut self) -> _Moder7W {
                _Moder7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder6(&mut self) -> _Moder6W {
                _Moder6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder5(&mut self) -> _Moder5W {
                _Moder5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder4(&mut self) -> _Moder4W {
                _Moder4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder3(&mut self) -> _Moder3W {
                _Moder3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder2(&mut self) -> _Moder2W {
                _Moder2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder1(&mut self) -> _Moder1W {
                _Moder1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder0(&mut self) -> _Moder0W {
                _Moder0W { w: self }
            }
        }
    }
    #[doc = "GPIO port output type register"]
    pub struct Otyper {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output type register"]
    pub mod otyper {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Otyper {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot15R {
            bits: u8,
        }
        impl Ot15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot14R {
            bits: u8,
        }
        impl Ot14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot13R {
            bits: u8,
        }
        impl Ot13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot12R {
            bits: u8,
        }
        impl Ot12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot11R {
            bits: u8,
        }
        impl Ot11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot10R {
            bits: u8,
        }
        impl Ot10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot9R {
            bits: u8,
        }
        impl Ot9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot8R {
            bits: u8,
        }
        impl Ot8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot7R {
            bits: u8,
        }
        impl Ot7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot6R {
            bits: u8,
        }
        impl Ot6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot5R {
            bits: u8,
        }
        impl Ot5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot4R {
            bits: u8,
        }
        impl Ot4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot3R {
            bits: u8,
        }
        impl Ot3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot2R {
            bits: u8,
        }
        impl Ot2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot1R {
            bits: u8,
        }
        impl Ot1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot0R {
            bits: u8,
        }
        impl Ot0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port x configuration bit 15"]
            #[inline ( always )]
            pub fn ot15(&self) -> Ot15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot15R { bits }
            }
            #[doc = "Bit 14 - Port x configuration bit 14"]
            #[inline ( always )]
            pub fn ot14(&self) -> Ot14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot14R { bits }
            }
            #[doc = "Bit 13 - Port x configuration bit 13"]
            #[inline ( always )]
            pub fn ot13(&self) -> Ot13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot13R { bits }
            }
            #[doc = "Bit 12 - Port x configuration bit 12"]
            #[inline ( always )]
            pub fn ot12(&self) -> Ot12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot12R { bits }
            }
            #[doc = "Bit 11 - Port x configuration bit 11"]
            #[inline ( always )]
            pub fn ot11(&self) -> Ot11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot11R { bits }
            }
            #[doc = "Bit 10 - Port x configuration bit 10"]
            #[inline ( always )]
            pub fn ot10(&self) -> Ot10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot10R { bits }
            }
            #[doc = "Bit 9 - Port x configuration bit 9"]
            #[inline ( always )]
            pub fn ot9(&self) -> Ot9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot9R { bits }
            }
            #[doc = "Bit 8 - Port x configuration bit 8"]
            #[inline ( always )]
            pub fn ot8(&self) -> Ot8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot8R { bits }
            }
            #[doc = "Bit 7 - Port x configuration bit 7"]
            #[inline ( always )]
            pub fn ot7(&self) -> Ot7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot7R { bits }
            }
            #[doc = "Bit 6 - Port x configuration bit 6"]
            #[inline ( always )]
            pub fn ot6(&self) -> Ot6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot6R { bits }
            }
            #[doc = "Bit 5 - Port x configuration bit 5"]
            #[inline ( always )]
            pub fn ot5(&self) -> Ot5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot5R { bits }
            }
            #[doc = "Bit 4 - Port x configuration bit 4"]
            #[inline ( always )]
            pub fn ot4(&self) -> Ot4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot4R { bits }
            }
            #[doc = "Bit 3 - Port x configuration bit 3"]
            #[inline ( always )]
            pub fn ot3(&self) -> Ot3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot3R { bits }
            }
            #[doc = "Bit 2 - Port x configuration bit 2"]
            #[inline ( always )]
            pub fn ot2(&self) -> Ot2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot2R { bits }
            }
            #[doc = "Bit 1 - Port x configuration bit 1"]
            #[inline ( always )]
            pub fn ot1(&self) -> Ot1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot1R { bits }
            }
            #[doc = "Bit 0 - Port x configuration bit 0"]
            #[inline ( always )]
            pub fn ot0(&self) -> Ot0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Port x configuration bit 15"]
            #[inline ( always )]
            pub fn ot15(&mut self) -> _Ot15W {
                _Ot15W { w: self }
            }
            #[doc = "Bit 14 - Port x configuration bit 14"]
            #[inline ( always )]
            pub fn ot14(&mut self) -> _Ot14W {
                _Ot14W { w: self }
            }
            #[doc = "Bit 13 - Port x configuration bit 13"]
            #[inline ( always )]
            pub fn ot13(&mut self) -> _Ot13W {
                _Ot13W { w: self }
            }
            #[doc = "Bit 12 - Port x configuration bit 12"]
            #[inline ( always )]
            pub fn ot12(&mut self) -> _Ot12W {
                _Ot12W { w: self }
            }
            #[doc = "Bit 11 - Port x configuration bit 11"]
            #[inline ( always )]
            pub fn ot11(&mut self) -> _Ot11W {
                _Ot11W { w: self }
            }
            #[doc = "Bit 10 - Port x configuration bit 10"]
            #[inline ( always )]
            pub fn ot10(&mut self) -> _Ot10W {
                _Ot10W { w: self }
            }
            #[doc = "Bit 9 - Port x configuration bit 9"]
            #[inline ( always )]
            pub fn ot9(&mut self) -> _Ot9W {
                _Ot9W { w: self }
            }
            #[doc = "Bit 8 - Port x configuration bit 8"]
            #[inline ( always )]
            pub fn ot8(&mut self) -> _Ot8W {
                _Ot8W { w: self }
            }
            #[doc = "Bit 7 - Port x configuration bit 7"]
            #[inline ( always )]
            pub fn ot7(&mut self) -> _Ot7W {
                _Ot7W { w: self }
            }
            #[doc = "Bit 6 - Port x configuration bit 6"]
            #[inline ( always )]
            pub fn ot6(&mut self) -> _Ot6W {
                _Ot6W { w: self }
            }
            #[doc = "Bit 5 - Port x configuration bit 5"]
            #[inline ( always )]
            pub fn ot5(&mut self) -> _Ot5W {
                _Ot5W { w: self }
            }
            #[doc = "Bit 4 - Port x configuration bit 4"]
            #[inline ( always )]
            pub fn ot4(&mut self) -> _Ot4W {
                _Ot4W { w: self }
            }
            #[doc = "Bit 3 - Port x configuration bit 3"]
            #[inline ( always )]
            pub fn ot3(&mut self) -> _Ot3W {
                _Ot3W { w: self }
            }
            #[doc = "Bit 2 - Port x configuration bit 2"]
            #[inline ( always )]
            pub fn ot2(&mut self) -> _Ot2W {
                _Ot2W { w: self }
            }
            #[doc = "Bit 1 - Port x configuration bit 1"]
            #[inline ( always )]
            pub fn ot1(&mut self) -> _Ot1W {
                _Ot1W { w: self }
            }
            #[doc = "Bit 0 - Port x configuration bit 0"]
            #[inline ( always )]
            pub fn ot0(&mut self) -> _Ot0W {
                _Ot0W { w: self }
            }
        }
    }
    #[doc = "GPIO port output speed register"]
    pub struct Ospeedr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output speed register"]
    pub mod ospeedr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ospeedr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr15R {
            bits: u8,
        }
        impl Ospeedr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr14R {
            bits: u8,
        }
        impl Ospeedr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr13R {
            bits: u8,
        }
        impl Ospeedr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr12R {
            bits: u8,
        }
        impl Ospeedr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr11R {
            bits: u8,
        }
        impl Ospeedr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr10R {
            bits: u8,
        }
        impl Ospeedr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr9R {
            bits: u8,
        }
        impl Ospeedr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr8R {
            bits: u8,
        }
        impl Ospeedr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr7R {
            bits: u8,
        }
        impl Ospeedr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr6R {
            bits: u8,
        }
        impl Ospeedr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr5R {
            bits: u8,
        }
        impl Ospeedr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr4R {
            bits: u8,
        }
        impl Ospeedr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr3R {
            bits: u8,
        }
        impl Ospeedr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr2R {
            bits: u8,
        }
        impl Ospeedr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr1R {
            bits: u8,
        }
        impl Ospeedr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr0R {
            bits: u8,
        }
        impl Ospeedr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr15(&self) -> Ospeedr15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr14(&self) -> Ospeedr14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr13(&self) -> Ospeedr13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr12(&self) -> Ospeedr12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr11(&self) -> Ospeedr11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr10(&self) -> Ospeedr10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr9(&self) -> Ospeedr9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr8(&self) -> Ospeedr8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr7(&self) -> Ospeedr7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr6(&self) -> Ospeedr6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr5(&self) -> Ospeedr5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr4(&self) -> Ospeedr4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr3(&self) -> Ospeedr3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr2(&self) -> Ospeedr2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr1(&self) -> Ospeedr1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr0(&self) -> Ospeedr0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr15(&mut self) -> _Ospeedr15W {
                _Ospeedr15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr14(&mut self) -> _Ospeedr14W {
                _Ospeedr14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr13(&mut self) -> _Ospeedr13W {
                _Ospeedr13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr12(&mut self) -> _Ospeedr12W {
                _Ospeedr12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr11(&mut self) -> _Ospeedr11W {
                _Ospeedr11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr10(&mut self) -> _Ospeedr10W {
                _Ospeedr10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr9(&mut self) -> _Ospeedr9W {
                _Ospeedr9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr8(&mut self) -> _Ospeedr8W {
                _Ospeedr8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr7(&mut self) -> _Ospeedr7W {
                _Ospeedr7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr6(&mut self) -> _Ospeedr6W {
                _Ospeedr6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr5(&mut self) -> _Ospeedr5W {
                _Ospeedr5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr4(&mut self) -> _Ospeedr4W {
                _Ospeedr4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr3(&mut self) -> _Ospeedr3W {
                _Ospeedr3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr2(&mut self) -> _Ospeedr2W {
                _Ospeedr2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr1(&mut self) -> _Ospeedr1W {
                _Ospeedr1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr0(&mut self) -> _Ospeedr0W {
                _Ospeedr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port pull-up/pull-down register"]
    pub struct Pupdr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port pull-up/pull-down register"]
    pub mod pupdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Pupdr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr15R {
            bits: u8,
        }
        impl Pupdr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr14R {
            bits: u8,
        }
        impl Pupdr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr13R {
            bits: u8,
        }
        impl Pupdr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr12R {
            bits: u8,
        }
        impl Pupdr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr11R {
            bits: u8,
        }
        impl Pupdr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr10R {
            bits: u8,
        }
        impl Pupdr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr9R {
            bits: u8,
        }
        impl Pupdr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr8R {
            bits: u8,
        }
        impl Pupdr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr7R {
            bits: u8,
        }
        impl Pupdr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr6R {
            bits: u8,
        }
        impl Pupdr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr5R {
            bits: u8,
        }
        impl Pupdr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr4R {
            bits: u8,
        }
        impl Pupdr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr3R {
            bits: u8,
        }
        impl Pupdr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr2R {
            bits: u8,
        }
        impl Pupdr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr1R {
            bits: u8,
        }
        impl Pupdr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr0R {
            bits: u8,
        }
        impl Pupdr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr15(&self) -> Pupdr15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr14(&self) -> Pupdr14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr13(&self) -> Pupdr13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr12(&self) -> Pupdr12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr11(&self) -> Pupdr11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr10(&self) -> Pupdr10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr9(&self) -> Pupdr9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr8(&self) -> Pupdr8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr7(&self) -> Pupdr7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr6(&self) -> Pupdr6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr5(&self) -> Pupdr5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr4(&self) -> Pupdr4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr3(&self) -> Pupdr3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr2(&self) -> Pupdr2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr1(&self) -> Pupdr1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr0(&self) -> Pupdr0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr15(&mut self) -> _Pupdr15W {
                _Pupdr15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr14(&mut self) -> _Pupdr14W {
                _Pupdr14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr13(&mut self) -> _Pupdr13W {
                _Pupdr13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr12(&mut self) -> _Pupdr12W {
                _Pupdr12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr11(&mut self) -> _Pupdr11W {
                _Pupdr11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr10(&mut self) -> _Pupdr10W {
                _Pupdr10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr9(&mut self) -> _Pupdr9W {
                _Pupdr9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr8(&mut self) -> _Pupdr8W {
                _Pupdr8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr7(&mut self) -> _Pupdr7W {
                _Pupdr7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr6(&mut self) -> _Pupdr6W {
                _Pupdr6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr5(&mut self) -> _Pupdr5W {
                _Pupdr5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr4(&mut self) -> _Pupdr4W {
                _Pupdr4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr3(&mut self) -> _Pupdr3W {
                _Pupdr3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr2(&mut self) -> _Pupdr2W {
                _Pupdr2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr1(&mut self) -> _Pupdr1W {
                _Pupdr1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr0(&mut self) -> _Pupdr0W {
                _Pupdr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port input data register"]
    pub struct Idr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port input data register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Idr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr15R {
            bits: u8,
        }
        impl Idr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr14R {
            bits: u8,
        }
        impl Idr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr13R {
            bits: u8,
        }
        impl Idr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr12R {
            bits: u8,
        }
        impl Idr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr11R {
            bits: u8,
        }
        impl Idr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr10R {
            bits: u8,
        }
        impl Idr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr9R {
            bits: u8,
        }
        impl Idr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr8R {
            bits: u8,
        }
        impl Idr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr7R {
            bits: u8,
        }
        impl Idr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr6R {
            bits: u8,
        }
        impl Idr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr5R {
            bits: u8,
        }
        impl Idr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr4R {
            bits: u8,
        }
        impl Idr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr3R {
            bits: u8,
        }
        impl Idr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr2R {
            bits: u8,
        }
        impl Idr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr1R {
            bits: u8,
        }
        impl Idr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr0R {
            bits: u8,
        }
        impl Idr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr15(&self) -> Idr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr15R { bits }
            }
            #[doc = "Bit 14 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr14(&self) -> Idr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr14R { bits }
            }
            #[doc = "Bit 13 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr13(&self) -> Idr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr13R { bits }
            }
            #[doc = "Bit 12 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr12(&self) -> Idr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr12R { bits }
            }
            #[doc = "Bit 11 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr11(&self) -> Idr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr11R { bits }
            }
            #[doc = "Bit 10 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr10(&self) -> Idr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr10R { bits }
            }
            #[doc = "Bit 9 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr9(&self) -> Idr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr9R { bits }
            }
            #[doc = "Bit 8 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr8(&self) -> Idr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr8R { bits }
            }
            #[doc = "Bit 7 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr7(&self) -> Idr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr7R { bits }
            }
            #[doc = "Bit 6 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr6(&self) -> Idr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr6R { bits }
            }
            #[doc = "Bit 5 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr5(&self) -> Idr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr5R { bits }
            }
            #[doc = "Bit 4 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr4(&self) -> Idr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr4R { bits }
            }
            #[doc = "Bit 3 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr3(&self) -> Idr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr3R { bits }
            }
            #[doc = "Bit 2 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr2(&self) -> Idr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr2R { bits }
            }
            #[doc = "Bit 1 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr1(&self) -> Idr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr1R { bits }
            }
            #[doc = "Bit 0 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr0(&self) -> Idr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr0R { bits }
            }
        }
    }
    #[doc = "GPIO port output data register"]
    pub struct Odr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output data register"]
    pub mod odr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Odr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr15R {
            bits: u8,
        }
        impl Odr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr14R {
            bits: u8,
        }
        impl Odr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr13R {
            bits: u8,
        }
        impl Odr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr12R {
            bits: u8,
        }
        impl Odr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr11R {
            bits: u8,
        }
        impl Odr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr10R {
            bits: u8,
        }
        impl Odr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr9R {
            bits: u8,
        }
        impl Odr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr8R {
            bits: u8,
        }
        impl Odr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr7R {
            bits: u8,
        }
        impl Odr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr6R {
            bits: u8,
        }
        impl Odr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr5R {
            bits: u8,
        }
        impl Odr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr4R {
            bits: u8,
        }
        impl Odr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr3R {
            bits: u8,
        }
        impl Odr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr2R {
            bits: u8,
        }
        impl Odr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr1R {
            bits: u8,
        }
        impl Odr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr0R {
            bits: u8,
        }
        impl Odr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr15(&self) -> Odr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr15R { bits }
            }
            #[doc = "Bit 14 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr14(&self) -> Odr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr14R { bits }
            }
            #[doc = "Bit 13 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr13(&self) -> Odr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr13R { bits }
            }
            #[doc = "Bit 12 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr12(&self) -> Odr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr12R { bits }
            }
            #[doc = "Bit 11 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr11(&self) -> Odr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr11R { bits }
            }
            #[doc = "Bit 10 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr10(&self) -> Odr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr10R { bits }
            }
            #[doc = "Bit 9 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr9(&self) -> Odr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr9R { bits }
            }
            #[doc = "Bit 8 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr8(&self) -> Odr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr8R { bits }
            }
            #[doc = "Bit 7 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr7(&self) -> Odr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr7R { bits }
            }
            #[doc = "Bit 6 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr6(&self) -> Odr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr6R { bits }
            }
            #[doc = "Bit 5 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr5(&self) -> Odr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr5R { bits }
            }
            #[doc = "Bit 4 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr4(&self) -> Odr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr4R { bits }
            }
            #[doc = "Bit 3 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr3(&self) -> Odr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr3R { bits }
            }
            #[doc = "Bit 2 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr2(&self) -> Odr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr2R { bits }
            }
            #[doc = "Bit 1 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr1(&self) -> Odr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr1R { bits }
            }
            #[doc = "Bit 0 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr0(&self) -> Odr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr15(&mut self) -> _Odr15W {
                _Odr15W { w: self }
            }
            #[doc = "Bit 14 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr14(&mut self) -> _Odr14W {
                _Odr14W { w: self }
            }
            #[doc = "Bit 13 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr13(&mut self) -> _Odr13W {
                _Odr13W { w: self }
            }
            #[doc = "Bit 12 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr12(&mut self) -> _Odr12W {
                _Odr12W { w: self }
            }
            #[doc = "Bit 11 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr11(&mut self) -> _Odr11W {
                _Odr11W { w: self }
            }
            #[doc = "Bit 10 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr10(&mut self) -> _Odr10W {
                _Odr10W { w: self }
            }
            #[doc = "Bit 9 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr9(&mut self) -> _Odr9W {
                _Odr9W { w: self }
            }
            #[doc = "Bit 8 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr8(&mut self) -> _Odr8W {
                _Odr8W { w: self }
            }
            #[doc = "Bit 7 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr7(&mut self) -> _Odr7W {
                _Odr7W { w: self }
            }
            #[doc = "Bit 6 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr6(&mut self) -> _Odr6W {
                _Odr6W { w: self }
            }
            #[doc = "Bit 5 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr5(&mut self) -> _Odr5W {
                _Odr5W { w: self }
            }
            #[doc = "Bit 4 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr4(&mut self) -> _Odr4W {
                _Odr4W { w: self }
            }
            #[doc = "Bit 3 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr3(&mut self) -> _Odr3W {
                _Odr3W { w: self }
            }
            #[doc = "Bit 2 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr2(&mut self) -> _Odr2W {
                _Odr2W { w: self }
            }
            #[doc = "Bit 1 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr1(&mut self) -> _Odr1W {
                _Odr1W { w: self }
            }
            #[doc = "Bit 0 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr0(&mut self) -> _Odr0W {
                _Odr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit set/reset register"]
    pub struct Bsrr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port bit set/reset register"]
    pub mod bsrr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bsrr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
            #[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            #[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            #[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            #[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            #[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            #[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            #[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            #[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            #[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            #[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            #[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            #[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            #[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            #[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            #[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            #[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs15(&mut self) -> _Bs15W {
                _Bs15W { w: self }
            }
            #[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs14(&mut self) -> _Bs14W {
                _Bs14W { w: self }
            }
            #[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs13(&mut self) -> _Bs13W {
                _Bs13W { w: self }
            }
            #[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs12(&mut self) -> _Bs12W {
                _Bs12W { w: self }
            }
            #[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs11(&mut self) -> _Bs11W {
                _Bs11W { w: self }
            }
            #[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs10(&mut self) -> _Bs10W {
                _Bs10W { w: self }
            }
            #[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs9(&mut self) -> _Bs9W {
                _Bs9W { w: self }
            }
            #[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs8(&mut self) -> _Bs8W {
                _Bs8W { w: self }
            }
            #[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs7(&mut self) -> _Bs7W {
                _Bs7W { w: self }
            }
            #[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs6(&mut self) -> _Bs6W {
                _Bs6W { w: self }
            }
            #[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs5(&mut self) -> _Bs5W {
                _Bs5W { w: self }
            }
            #[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs4(&mut self) -> _Bs4W {
                _Bs4W { w: self }
            }
            #[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs3(&mut self) -> _Bs3W {
                _Bs3W { w: self }
            }
            #[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs2(&mut self) -> _Bs2W {
                _Bs2W { w: self }
            }
            #[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs1(&mut self) -> _Bs1W {
                _Bs1W { w: self }
            }
            #[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs0(&mut self) -> _Bs0W {
                _Bs0W { w: self }
            }
        }
    }
    #[doc = "GPIO port configuration lock register"]
    pub struct Lckr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port configuration lock register"]
    pub mod lckr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Lckr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct LckkR {
            bits: u8,
        }
        impl LckkR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck15R {
            bits: u8,
        }
        impl Lck15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck14R {
            bits: u8,
        }
        impl Lck14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck13R {
            bits: u8,
        }
        impl Lck13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck12R {
            bits: u8,
        }
        impl Lck12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck11R {
            bits: u8,
        }
        impl Lck11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck10R {
            bits: u8,
        }
        impl Lck10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck9R {
            bits: u8,
        }
        impl Lck9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck8R {
            bits: u8,
        }
        impl Lck8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck7R {
            bits: u8,
        }
        impl Lck7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck6R {
            bits: u8,
        }
        impl Lck6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck5R {
            bits: u8,
        }
        impl Lck5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck4R {
            bits: u8,
        }
        impl Lck4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck3R {
            bits: u8,
        }
        impl Lck3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck2R {
            bits: u8,
        }
        impl Lck2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck1R {
            bits: u8,
        }
        impl Lck1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck0R {
            bits: u8,
        }
        impl Lck0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LckkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LckkW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Port x lock bit y"]
            #[inline ( always )]
            pub fn lckk(&self) -> LckkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LckkR { bits }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck15(&self) -> Lck15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck15R { bits }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck14(&self) -> Lck14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck14R { bits }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck13(&self) -> Lck13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck13R { bits }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck12(&self) -> Lck12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck12R { bits }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck11(&self) -> Lck11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck11R { bits }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck10(&self) -> Lck10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck10R { bits }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck9(&self) -> Lck9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck9R { bits }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck8(&self) -> Lck8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck8R { bits }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck7(&self) -> Lck7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck7R { bits }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck6(&self) -> Lck6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck6R { bits }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck5(&self) -> Lck5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck5R { bits }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck4(&self) -> Lck4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck4R { bits }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck3(&self) -> Lck3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck3R { bits }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck2(&self) -> Lck2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck2R { bits }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck1(&self) -> Lck1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck1R { bits }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck0(&self) -> Lck0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Port x lock bit y"]
            #[inline ( always )]
            pub fn lckk(&mut self) -> _LckkW {
                _LckkW { w: self }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck15(&mut self) -> _Lck15W {
                _Lck15W { w: self }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck14(&mut self) -> _Lck14W {
                _Lck14W { w: self }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck13(&mut self) -> _Lck13W {
                _Lck13W { w: self }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck12(&mut self) -> _Lck12W {
                _Lck12W { w: self }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck11(&mut self) -> _Lck11W {
                _Lck11W { w: self }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck10(&mut self) -> _Lck10W {
                _Lck10W { w: self }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck9(&mut self) -> _Lck9W {
                _Lck9W { w: self }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck8(&mut self) -> _Lck8W {
                _Lck8W { w: self }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck7(&mut self) -> _Lck7W {
                _Lck7W { w: self }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck6(&mut self) -> _Lck6W {
                _Lck6W { w: self }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck5(&mut self) -> _Lck5W {
                _Lck5W { w: self }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck4(&mut self) -> _Lck4W {
                _Lck4W { w: self }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck3(&mut self) -> _Lck3W {
                _Lck3W { w: self }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck2(&mut self) -> _Lck2W {
                _Lck2W { w: self }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck1(&mut self) -> _Lck1W {
                _Lck1W { w: self }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck0(&mut self) -> _Lck0W {
                _Lck0W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function low register"]
    pub struct Afrl {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO alternate function low register"]
    pub mod afrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Afrl {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl7R {
            bits: u8,
        }
        impl Afrl7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl6R {
            bits: u8,
        }
        impl Afrl6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl5R {
            bits: u8,
        }
        impl Afrl5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl4R {
            bits: u8,
        }
        impl Afrl4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl3R {
            bits: u8,
        }
        impl Afrl3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl2R {
            bits: u8,
        }
        impl Afrl2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl1R {
            bits: u8,
        }
        impl Afrl1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl0R {
            bits: u8,
        }
        impl Afrl0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl7(&self) -> Afrl7R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl7R { bits }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl6(&self) -> Afrl6R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl6R { bits }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl5(&self) -> Afrl5R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl5R { bits }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl4(&self) -> Afrl4R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl4R { bits }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl3(&self) -> Afrl3R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl3R { bits }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl2(&self) -> Afrl2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl2R { bits }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl1(&self) -> Afrl1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl1R { bits }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl0(&self) -> Afrl0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl7(&mut self) -> _Afrl7W {
                _Afrl7W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl6(&mut self) -> _Afrl6W {
                _Afrl6W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl5(&mut self) -> _Afrl5W {
                _Afrl5W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl4(&mut self) -> _Afrl4W {
                _Afrl4W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl3(&mut self) -> _Afrl3W {
                _Afrl3W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl2(&mut self) -> _Afrl2W {
                _Afrl2W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl1(&mut self) -> _Afrl1W {
                _Afrl1W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl0(&mut self) -> _Afrl0W {
                _Afrl0W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function high register"]
    pub struct Afrh {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO alternate function high register"]
    pub mod afrh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Afrh {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh15R {
            bits: u8,
        }
        impl Afrh15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh14R {
            bits: u8,
        }
        impl Afrh14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh13R {
            bits: u8,
        }
        impl Afrh13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh12R {
            bits: u8,
        }
        impl Afrh12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh11R {
            bits: u8,
        }
        impl Afrh11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh10R {
            bits: u8,
        }
        impl Afrh10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh9R {
            bits: u8,
        }
        impl Afrh9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh8R {
            bits: u8,
        }
        impl Afrh8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh15(&self) -> Afrh15R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh15R { bits }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh14(&self) -> Afrh14R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh14R { bits }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh13(&self) -> Afrh13R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh13R { bits }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh12(&self) -> Afrh12R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh12R { bits }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh11(&self) -> Afrh11R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh11R { bits }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh10(&self) -> Afrh10R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh10R { bits }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh9(&self) -> Afrh9R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh9R { bits }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh8(&self) -> Afrh8R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh8R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh15(&mut self) -> _Afrh15W {
                _Afrh15W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh14(&mut self) -> _Afrh14W {
                _Afrh14W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh13(&mut self) -> _Afrh13W {
                _Afrh13W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh12(&mut self) -> _Afrh12W {
                _Afrh12W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh11(&mut self) -> _Afrh11W {
                _Afrh11W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh10(&mut self) -> _Afrh10W {
                _Afrh10W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh9(&mut self) -> _Afrh9W {
                _Afrh9W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh8(&mut self) -> _Afrh8W {
                _Afrh8W { w: self }
            }
        }
    }
    #[doc = "Port bit reset register"]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    #[doc = "Port bit reset register"]
    pub mod brr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            #[doc = "Bit 1 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            #[doc = "Bit 2 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            #[doc = "Bit 3 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            #[doc = "Bit 4 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            #[doc = "Bit 5 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            #[doc = "Bit 6 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            #[doc = "Bit 7 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            #[doc = "Bit 8 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            #[doc = "Bit 9 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            #[doc = "Bit 10 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            #[doc = "Bit 11 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            #[doc = "Bit 12 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            #[doc = "Bit 13 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            #[doc = "Bit 14 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            #[doc = "Bit 15 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
        }
    }
}
#[doc = "General-purpose I/Os"]
pub struct Gpiof {
    register_block: gpiof::RegisterBlock,
}
impl Deref for Gpiof {
    type Target = gpiof::RegisterBlock;
    fn deref(&self) -> &gpiof::RegisterBlock {
        &self.register_block
    }
}
#[doc = "GPIOD"]
pub const GPIOD: Peripheral<Gpiod> = unsafe { Peripheral::new(1207962624) };
#[doc = r" Register block"]
pub struct Gpiod {
    register_block: gpiof::RegisterBlock,
}
impl Deref for Gpiod {
    type Target = gpiof::RegisterBlock;
    fn deref(&self) -> &gpiof::RegisterBlock {
        &self.register_block
    }
}
#[doc = "GPIOC"]
pub const GPIOC: Peripheral<Gpioc> = unsafe { Peripheral::new(1207961600) };
#[doc = r" Register block"]
pub struct Gpioc {
    register_block: gpiof::RegisterBlock,
}
impl Deref for Gpioc {
    type Target = gpiof::RegisterBlock;
    fn deref(&self) -> &gpiof::RegisterBlock {
        &self.register_block
    }
}
#[doc = "GPIOB"]
pub const GPIOB: Peripheral<Gpiob> = unsafe { Peripheral::new(1207960576) };
#[doc = r" Register block"]
pub struct Gpiob {
    register_block: gpiof::RegisterBlock,
}
impl Deref for Gpiob {
    type Target = gpiof::RegisterBlock;
    fn deref(&self) -> &gpiof::RegisterBlock {
        &self.register_block
    }
}
#[doc = "GPIOE"]
pub const GPIOE: Peripheral<Gpioe> = unsafe { Peripheral::new(1207963648) };
#[doc = r" Register block"]
pub struct Gpioe {
    register_block: gpiof::RegisterBlock,
}
impl Deref for Gpioe {
    type Target = gpiof::RegisterBlock;
    fn deref(&self) -> &gpiof::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose I/Os"]
pub const GPIOA: Peripheral<Gpioa> = unsafe { Peripheral::new(1207959552) };
#[doc = "General-purpose I/Os"]
pub mod gpioa {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - GPIO port mode register"]
        pub moder: Moder,
        #[doc = "0x04 - GPIO port output type register"]
        pub otyper: Otyper,
        #[doc = "0x08 - GPIO port output speed register"]
        pub ospeedr: Ospeedr,
        #[doc = "0x0c - GPIO port pull-up/pull-down register"]
        pub pupdr: Pupdr,
        #[doc = "0x10 - GPIO port input data register"]
        pub idr: Idr,
        #[doc = "0x14 - GPIO port output data register"]
        pub odr: Odr,
        #[doc = "0x18 - GPIO port bit set/reset register"]
        pub bsrr: Bsrr,
        #[doc = "0x1c - GPIO port configuration lock register"]
        pub lckr: Lckr,
        #[doc = "0x20 - GPIO alternate function low register"]
        pub afrl: Afrl,
        #[doc = "0x24 - GPIO alternate function high register"]
        pub afrh: Afrh,
        #[doc = "0x28 - Port bit reset register"]
        pub brr: Brr,
    }
    #[doc = "GPIO port mode register"]
    pub struct Moder {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port mode register"]
    pub mod moder {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Moder {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder15R {
            bits: u8,
        }
        impl Moder15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder14R {
            bits: u8,
        }
        impl Moder14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder13R {
            bits: u8,
        }
        impl Moder13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder12R {
            bits: u8,
        }
        impl Moder12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder11R {
            bits: u8,
        }
        impl Moder11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder10R {
            bits: u8,
        }
        impl Moder10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder9R {
            bits: u8,
        }
        impl Moder9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder8R {
            bits: u8,
        }
        impl Moder8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder7R {
            bits: u8,
        }
        impl Moder7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder6R {
            bits: u8,
        }
        impl Moder6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder5R {
            bits: u8,
        }
        impl Moder5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder4R {
            bits: u8,
        }
        impl Moder4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder3R {
            bits: u8,
        }
        impl Moder3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder2R {
            bits: u8,
        }
        impl Moder2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder1R {
            bits: u8,
        }
        impl Moder1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Moder0R {
            bits: u8,
        }
        impl Moder0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Moder0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Moder0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder15(&self) -> Moder15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder14(&self) -> Moder14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder13(&self) -> Moder13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder12(&self) -> Moder12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder11(&self) -> Moder11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder10(&self) -> Moder10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder9(&self) -> Moder9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder8(&self) -> Moder8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder7(&self) -> Moder7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder6(&self) -> Moder6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder5(&self) -> Moder5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder4(&self) -> Moder4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder3(&self) -> Moder3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder2(&self) -> Moder2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder1(&self) -> Moder1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder0(&self) -> Moder0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Moder0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 671088640 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder15(&mut self) -> _Moder15W {
                _Moder15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder14(&mut self) -> _Moder14W {
                _Moder14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder13(&mut self) -> _Moder13W {
                _Moder13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder12(&mut self) -> _Moder12W {
                _Moder12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder11(&mut self) -> _Moder11W {
                _Moder11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder10(&mut self) -> _Moder10W {
                _Moder10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder9(&mut self) -> _Moder9W {
                _Moder9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder8(&mut self) -> _Moder8W {
                _Moder8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder7(&mut self) -> _Moder7W {
                _Moder7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder6(&mut self) -> _Moder6W {
                _Moder6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder5(&mut self) -> _Moder5W {
                _Moder5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder4(&mut self) -> _Moder4W {
                _Moder4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder3(&mut self) -> _Moder3W {
                _Moder3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder2(&mut self) -> _Moder2W {
                _Moder2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder1(&mut self) -> _Moder1W {
                _Moder1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn moder0(&mut self) -> _Moder0W {
                _Moder0W { w: self }
            }
        }
    }
    #[doc = "GPIO port output type register"]
    pub struct Otyper {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output type register"]
    pub mod otyper {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Otyper {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot15R {
            bits: u8,
        }
        impl Ot15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot14R {
            bits: u8,
        }
        impl Ot14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot13R {
            bits: u8,
        }
        impl Ot13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot12R {
            bits: u8,
        }
        impl Ot12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot11R {
            bits: u8,
        }
        impl Ot11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot10R {
            bits: u8,
        }
        impl Ot10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot9R {
            bits: u8,
        }
        impl Ot9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot8R {
            bits: u8,
        }
        impl Ot8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot7R {
            bits: u8,
        }
        impl Ot7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot6R {
            bits: u8,
        }
        impl Ot6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot5R {
            bits: u8,
        }
        impl Ot5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot4R {
            bits: u8,
        }
        impl Ot4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot3R {
            bits: u8,
        }
        impl Ot3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot2R {
            bits: u8,
        }
        impl Ot2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot1R {
            bits: u8,
        }
        impl Ot1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ot0R {
            bits: u8,
        }
        impl Ot0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ot0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ot0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot15(&self) -> Ot15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot15R { bits }
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot14(&self) -> Ot14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot14R { bits }
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot13(&self) -> Ot13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot13R { bits }
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot12(&self) -> Ot12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot12R { bits }
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot11(&self) -> Ot11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot11R { bits }
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot10(&self) -> Ot10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot10R { bits }
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot9(&self) -> Ot9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot9R { bits }
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot8(&self) -> Ot8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot8R { bits }
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot7(&self) -> Ot7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot7R { bits }
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot6(&self) -> Ot6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot6R { bits }
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot5(&self) -> Ot5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot5R { bits }
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot4(&self) -> Ot4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot4R { bits }
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot3(&self) -> Ot3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot3R { bits }
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot2(&self) -> Ot2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot2R { bits }
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot1(&self) -> Ot1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot1R { bits }
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot0(&self) -> Ot0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ot0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot15(&mut self) -> _Ot15W {
                _Ot15W { w: self }
            }
            #[doc = "Bit 14 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot14(&mut self) -> _Ot14W {
                _Ot14W { w: self }
            }
            #[doc = "Bit 13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot13(&mut self) -> _Ot13W {
                _Ot13W { w: self }
            }
            #[doc = "Bit 12 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot12(&mut self) -> _Ot12W {
                _Ot12W { w: self }
            }
            #[doc = "Bit 11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot11(&mut self) -> _Ot11W {
                _Ot11W { w: self }
            }
            #[doc = "Bit 10 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot10(&mut self) -> _Ot10W {
                _Ot10W { w: self }
            }
            #[doc = "Bit 9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot9(&mut self) -> _Ot9W {
                _Ot9W { w: self }
            }
            #[doc = "Bit 8 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot8(&mut self) -> _Ot8W {
                _Ot8W { w: self }
            }
            #[doc = "Bit 7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot7(&mut self) -> _Ot7W {
                _Ot7W { w: self }
            }
            #[doc = "Bit 6 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot6(&mut self) -> _Ot6W {
                _Ot6W { w: self }
            }
            #[doc = "Bit 5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot5(&mut self) -> _Ot5W {
                _Ot5W { w: self }
            }
            #[doc = "Bit 4 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot4(&mut self) -> _Ot4W {
                _Ot4W { w: self }
            }
            #[doc = "Bit 3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot3(&mut self) -> _Ot3W {
                _Ot3W { w: self }
            }
            #[doc = "Bit 2 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot2(&mut self) -> _Ot2W {
                _Ot2W { w: self }
            }
            #[doc = "Bit 1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot1(&mut self) -> _Ot1W {
                _Ot1W { w: self }
            }
            #[doc = "Bit 0 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ot0(&mut self) -> _Ot0W {
                _Ot0W { w: self }
            }
        }
    }
    #[doc = "GPIO port output speed register"]
    pub struct Ospeedr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output speed register"]
    pub mod ospeedr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ospeedr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr15R {
            bits: u8,
        }
        impl Ospeedr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr14R {
            bits: u8,
        }
        impl Ospeedr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr13R {
            bits: u8,
        }
        impl Ospeedr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr12R {
            bits: u8,
        }
        impl Ospeedr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr11R {
            bits: u8,
        }
        impl Ospeedr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr10R {
            bits: u8,
        }
        impl Ospeedr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr9R {
            bits: u8,
        }
        impl Ospeedr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr8R {
            bits: u8,
        }
        impl Ospeedr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr7R {
            bits: u8,
        }
        impl Ospeedr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr6R {
            bits: u8,
        }
        impl Ospeedr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr5R {
            bits: u8,
        }
        impl Ospeedr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr4R {
            bits: u8,
        }
        impl Ospeedr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr3R {
            bits: u8,
        }
        impl Ospeedr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr2R {
            bits: u8,
        }
        impl Ospeedr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr1R {
            bits: u8,
        }
        impl Ospeedr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ospeedr0R {
            bits: u8,
        }
        impl Ospeedr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ospeedr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ospeedr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr15(&self) -> Ospeedr15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr14(&self) -> Ospeedr14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr13(&self) -> Ospeedr13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr12(&self) -> Ospeedr12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr11(&self) -> Ospeedr11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr10(&self) -> Ospeedr10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr9(&self) -> Ospeedr9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr8(&self) -> Ospeedr8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr7(&self) -> Ospeedr7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr6(&self) -> Ospeedr6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr5(&self) -> Ospeedr5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr4(&self) -> Ospeedr4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr3(&self) -> Ospeedr3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr2(&self) -> Ospeedr2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr1(&self) -> Ospeedr1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr0(&self) -> Ospeedr0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ospeedr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr15(&mut self) -> _Ospeedr15W {
                _Ospeedr15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr14(&mut self) -> _Ospeedr14W {
                _Ospeedr14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr13(&mut self) -> _Ospeedr13W {
                _Ospeedr13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr12(&mut self) -> _Ospeedr12W {
                _Ospeedr12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr11(&mut self) -> _Ospeedr11W {
                _Ospeedr11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr10(&mut self) -> _Ospeedr10W {
                _Ospeedr10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr9(&mut self) -> _Ospeedr9W {
                _Ospeedr9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr8(&mut self) -> _Ospeedr8W {
                _Ospeedr8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr7(&mut self) -> _Ospeedr7W {
                _Ospeedr7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr6(&mut self) -> _Ospeedr6W {
                _Ospeedr6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr5(&mut self) -> _Ospeedr5W {
                _Ospeedr5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr4(&mut self) -> _Ospeedr4W {
                _Ospeedr4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr3(&mut self) -> _Ospeedr3W {
                _Ospeedr3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr2(&mut self) -> _Ospeedr2W {
                _Ospeedr2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr1(&mut self) -> _Ospeedr1W {
                _Ospeedr1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn ospeedr0(&mut self) -> _Ospeedr0W {
                _Ospeedr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port pull-up/pull-down register"]
    pub struct Pupdr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port pull-up/pull-down register"]
    pub mod pupdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Pupdr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr15R {
            bits: u8,
        }
        impl Pupdr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr14R {
            bits: u8,
        }
        impl Pupdr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr13R {
            bits: u8,
        }
        impl Pupdr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr12R {
            bits: u8,
        }
        impl Pupdr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr11R {
            bits: u8,
        }
        impl Pupdr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr10R {
            bits: u8,
        }
        impl Pupdr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr9R {
            bits: u8,
        }
        impl Pupdr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr8R {
            bits: u8,
        }
        impl Pupdr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr7R {
            bits: u8,
        }
        impl Pupdr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr6R {
            bits: u8,
        }
        impl Pupdr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr5R {
            bits: u8,
        }
        impl Pupdr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr4R {
            bits: u8,
        }
        impl Pupdr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr3R {
            bits: u8,
        }
        impl Pupdr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr2R {
            bits: u8,
        }
        impl Pupdr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr1R {
            bits: u8,
        }
        impl Pupdr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pupdr0R {
            bits: u8,
        }
        impl Pupdr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pupdr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pupdr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr15(&self) -> Pupdr15R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr15R { bits }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr14(&self) -> Pupdr14R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr14R { bits }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr13(&self) -> Pupdr13R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr13R { bits }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr12(&self) -> Pupdr12R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr12R { bits }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr11(&self) -> Pupdr11R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr11R { bits }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr10(&self) -> Pupdr10R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr10R { bits }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr9(&self) -> Pupdr9R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr9R { bits }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr8(&self) -> Pupdr8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr8R { bits }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr7(&self) -> Pupdr7R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr7R { bits }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr6(&self) -> Pupdr6R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr6R { bits }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr5(&self) -> Pupdr5R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr5R { bits }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr4(&self) -> Pupdr4R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr4R { bits }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr3(&self) -> Pupdr3R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr3R { bits }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr2(&self) -> Pupdr2R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr2R { bits }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr1(&self) -> Pupdr1R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr1R { bits }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr0(&self) -> Pupdr0R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pupdr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 603979776 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 30:31 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr15(&mut self) -> _Pupdr15W {
                _Pupdr15W { w: self }
            }
            #[doc = "Bits 28:29 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr14(&mut self) -> _Pupdr14W {
                _Pupdr14W { w: self }
            }
            #[doc = "Bits 26:27 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr13(&mut self) -> _Pupdr13W {
                _Pupdr13W { w: self }
            }
            #[doc = "Bits 24:25 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr12(&mut self) -> _Pupdr12W {
                _Pupdr12W { w: self }
            }
            #[doc = "Bits 22:23 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr11(&mut self) -> _Pupdr11W {
                _Pupdr11W { w: self }
            }
            #[doc = "Bits 20:21 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr10(&mut self) -> _Pupdr10W {
                _Pupdr10W { w: self }
            }
            #[doc = "Bits 18:19 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr9(&mut self) -> _Pupdr9W {
                _Pupdr9W { w: self }
            }
            #[doc = "Bits 16:17 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr8(&mut self) -> _Pupdr8W {
                _Pupdr8W { w: self }
            }
            #[doc = "Bits 14:15 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr7(&mut self) -> _Pupdr7W {
                _Pupdr7W { w: self }
            }
            #[doc = "Bits 12:13 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr6(&mut self) -> _Pupdr6W {
                _Pupdr6W { w: self }
            }
            #[doc = "Bits 10:11 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr5(&mut self) -> _Pupdr5W {
                _Pupdr5W { w: self }
            }
            #[doc = "Bits 8:9 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr4(&mut self) -> _Pupdr4W {
                _Pupdr4W { w: self }
            }
            #[doc = "Bits 6:7 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr3(&mut self) -> _Pupdr3W {
                _Pupdr3W { w: self }
            }
            #[doc = "Bits 4:5 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr2(&mut self) -> _Pupdr2W {
                _Pupdr2W { w: self }
            }
            #[doc = "Bits 2:3 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr1(&mut self) -> _Pupdr1W {
                _Pupdr1W { w: self }
            }
            #[doc = "Bits 0:1 - Port x configuration bits (y = 0..15)"]
            #[inline ( always )]
            pub fn pupdr0(&mut self) -> _Pupdr0W {
                _Pupdr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port input data register"]
    pub struct Idr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port input data register"]
    pub mod idr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Idr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr15R {
            bits: u8,
        }
        impl Idr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr14R {
            bits: u8,
        }
        impl Idr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr13R {
            bits: u8,
        }
        impl Idr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr12R {
            bits: u8,
        }
        impl Idr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr11R {
            bits: u8,
        }
        impl Idr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr10R {
            bits: u8,
        }
        impl Idr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr9R {
            bits: u8,
        }
        impl Idr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr8R {
            bits: u8,
        }
        impl Idr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr7R {
            bits: u8,
        }
        impl Idr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr6R {
            bits: u8,
        }
        impl Idr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr5R {
            bits: u8,
        }
        impl Idr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr4R {
            bits: u8,
        }
        impl Idr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr3R {
            bits: u8,
        }
        impl Idr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr2R {
            bits: u8,
        }
        impl Idr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr1R {
            bits: u8,
        }
        impl Idr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Idr0R {
            bits: u8,
        }
        impl Idr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr15(&self) -> Idr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr15R { bits }
            }
            #[doc = "Bit 14 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr14(&self) -> Idr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr14R { bits }
            }
            #[doc = "Bit 13 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr13(&self) -> Idr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr13R { bits }
            }
            #[doc = "Bit 12 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr12(&self) -> Idr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr12R { bits }
            }
            #[doc = "Bit 11 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr11(&self) -> Idr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr11R { bits }
            }
            #[doc = "Bit 10 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr10(&self) -> Idr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr10R { bits }
            }
            #[doc = "Bit 9 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr9(&self) -> Idr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr9R { bits }
            }
            #[doc = "Bit 8 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr8(&self) -> Idr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr8R { bits }
            }
            #[doc = "Bit 7 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr7(&self) -> Idr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr7R { bits }
            }
            #[doc = "Bit 6 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr6(&self) -> Idr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr6R { bits }
            }
            #[doc = "Bit 5 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr5(&self) -> Idr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr5R { bits }
            }
            #[doc = "Bit 4 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr4(&self) -> Idr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr4R { bits }
            }
            #[doc = "Bit 3 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr3(&self) -> Idr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr3R { bits }
            }
            #[doc = "Bit 2 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr2(&self) -> Idr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr2R { bits }
            }
            #[doc = "Bit 1 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr1(&self) -> Idr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr1R { bits }
            }
            #[doc = "Bit 0 - Port input data (y = 0..15)"]
            #[inline ( always )]
            pub fn idr0(&self) -> Idr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Idr0R { bits }
            }
        }
    }
    #[doc = "GPIO port output data register"]
    pub struct Odr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port output data register"]
    pub mod odr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Odr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr15R {
            bits: u8,
        }
        impl Odr15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr14R {
            bits: u8,
        }
        impl Odr14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr13R {
            bits: u8,
        }
        impl Odr13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr12R {
            bits: u8,
        }
        impl Odr12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr11R {
            bits: u8,
        }
        impl Odr11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr10R {
            bits: u8,
        }
        impl Odr10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr9R {
            bits: u8,
        }
        impl Odr9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr8R {
            bits: u8,
        }
        impl Odr8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr7R {
            bits: u8,
        }
        impl Odr7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr6R {
            bits: u8,
        }
        impl Odr6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr5R {
            bits: u8,
        }
        impl Odr5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr4R {
            bits: u8,
        }
        impl Odr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr3R {
            bits: u8,
        }
        impl Odr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr2R {
            bits: u8,
        }
        impl Odr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr1R {
            bits: u8,
        }
        impl Odr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Odr0R {
            bits: u8,
        }
        impl Odr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Odr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Odr0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr15(&self) -> Odr15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr15R { bits }
            }
            #[doc = "Bit 14 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr14(&self) -> Odr14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr14R { bits }
            }
            #[doc = "Bit 13 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr13(&self) -> Odr13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr13R { bits }
            }
            #[doc = "Bit 12 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr12(&self) -> Odr12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr12R { bits }
            }
            #[doc = "Bit 11 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr11(&self) -> Odr11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr11R { bits }
            }
            #[doc = "Bit 10 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr10(&self) -> Odr10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr10R { bits }
            }
            #[doc = "Bit 9 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr9(&self) -> Odr9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr9R { bits }
            }
            #[doc = "Bit 8 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr8(&self) -> Odr8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr8R { bits }
            }
            #[doc = "Bit 7 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr7(&self) -> Odr7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr7R { bits }
            }
            #[doc = "Bit 6 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr6(&self) -> Odr6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr6R { bits }
            }
            #[doc = "Bit 5 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr5(&self) -> Odr5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr5R { bits }
            }
            #[doc = "Bit 4 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr4(&self) -> Odr4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr4R { bits }
            }
            #[doc = "Bit 3 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr3(&self) -> Odr3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr3R { bits }
            }
            #[doc = "Bit 2 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr2(&self) -> Odr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr2R { bits }
            }
            #[doc = "Bit 1 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr1(&self) -> Odr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr1R { bits }
            }
            #[doc = "Bit 0 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr0(&self) -> Odr0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Odr0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr15(&mut self) -> _Odr15W {
                _Odr15W { w: self }
            }
            #[doc = "Bit 14 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr14(&mut self) -> _Odr14W {
                _Odr14W { w: self }
            }
            #[doc = "Bit 13 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr13(&mut self) -> _Odr13W {
                _Odr13W { w: self }
            }
            #[doc = "Bit 12 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr12(&mut self) -> _Odr12W {
                _Odr12W { w: self }
            }
            #[doc = "Bit 11 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr11(&mut self) -> _Odr11W {
                _Odr11W { w: self }
            }
            #[doc = "Bit 10 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr10(&mut self) -> _Odr10W {
                _Odr10W { w: self }
            }
            #[doc = "Bit 9 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr9(&mut self) -> _Odr9W {
                _Odr9W { w: self }
            }
            #[doc = "Bit 8 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr8(&mut self) -> _Odr8W {
                _Odr8W { w: self }
            }
            #[doc = "Bit 7 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr7(&mut self) -> _Odr7W {
                _Odr7W { w: self }
            }
            #[doc = "Bit 6 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr6(&mut self) -> _Odr6W {
                _Odr6W { w: self }
            }
            #[doc = "Bit 5 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr5(&mut self) -> _Odr5W {
                _Odr5W { w: self }
            }
            #[doc = "Bit 4 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr4(&mut self) -> _Odr4W {
                _Odr4W { w: self }
            }
            #[doc = "Bit 3 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr3(&mut self) -> _Odr3W {
                _Odr3W { w: self }
            }
            #[doc = "Bit 2 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr2(&mut self) -> _Odr2W {
                _Odr2W { w: self }
            }
            #[doc = "Bit 1 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr1(&mut self) -> _Odr1W {
                _Odr1W { w: self }
            }
            #[doc = "Bit 0 - Port output data (y = 0..15)"]
            #[inline ( always )]
            pub fn odr0(&mut self) -> _Odr0W {
                _Odr0W { w: self }
            }
        }
    }
    #[doc = "GPIO port bit set/reset register"]
    pub struct Bsrr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port bit set/reset register"]
    pub mod bsrr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bsrr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Bs0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Bs0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
            #[doc = "Bit 30 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            #[doc = "Bit 29 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            #[doc = "Bit 28 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            #[doc = "Bit 27 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            #[doc = "Bit 26 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            #[doc = "Bit 25 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            #[doc = "Bit 24 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            #[doc = "Bit 23 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            #[doc = "Bit 22 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            #[doc = "Bit 21 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            #[doc = "Bit 20 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            #[doc = "Bit 19 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            #[doc = "Bit 18 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            #[doc = "Bit 17 - Port x reset bit y (y = 0..15)"]
            #[inline ( always )]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            #[doc = "Bit 16 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            #[doc = "Bit 15 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs15(&mut self) -> _Bs15W {
                _Bs15W { w: self }
            }
            #[doc = "Bit 14 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs14(&mut self) -> _Bs14W {
                _Bs14W { w: self }
            }
            #[doc = "Bit 13 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs13(&mut self) -> _Bs13W {
                _Bs13W { w: self }
            }
            #[doc = "Bit 12 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs12(&mut self) -> _Bs12W {
                _Bs12W { w: self }
            }
            #[doc = "Bit 11 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs11(&mut self) -> _Bs11W {
                _Bs11W { w: self }
            }
            #[doc = "Bit 10 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs10(&mut self) -> _Bs10W {
                _Bs10W { w: self }
            }
            #[doc = "Bit 9 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs9(&mut self) -> _Bs9W {
                _Bs9W { w: self }
            }
            #[doc = "Bit 8 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs8(&mut self) -> _Bs8W {
                _Bs8W { w: self }
            }
            #[doc = "Bit 7 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs7(&mut self) -> _Bs7W {
                _Bs7W { w: self }
            }
            #[doc = "Bit 6 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs6(&mut self) -> _Bs6W {
                _Bs6W { w: self }
            }
            #[doc = "Bit 5 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs5(&mut self) -> _Bs5W {
                _Bs5W { w: self }
            }
            #[doc = "Bit 4 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs4(&mut self) -> _Bs4W {
                _Bs4W { w: self }
            }
            #[doc = "Bit 3 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs3(&mut self) -> _Bs3W {
                _Bs3W { w: self }
            }
            #[doc = "Bit 2 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs2(&mut self) -> _Bs2W {
                _Bs2W { w: self }
            }
            #[doc = "Bit 1 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs1(&mut self) -> _Bs1W {
                _Bs1W { w: self }
            }
            #[doc = "Bit 0 - Port x set bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn bs0(&mut self) -> _Bs0W {
                _Bs0W { w: self }
            }
        }
    }
    #[doc = "GPIO port configuration lock register"]
    pub struct Lckr {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO port configuration lock register"]
    pub mod lckr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Lckr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct LckkR {
            bits: u8,
        }
        impl LckkR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck15R {
            bits: u8,
        }
        impl Lck15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck14R {
            bits: u8,
        }
        impl Lck14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck13R {
            bits: u8,
        }
        impl Lck13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck12R {
            bits: u8,
        }
        impl Lck12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck11R {
            bits: u8,
        }
        impl Lck11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck10R {
            bits: u8,
        }
        impl Lck10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck9R {
            bits: u8,
        }
        impl Lck9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck8R {
            bits: u8,
        }
        impl Lck8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck7R {
            bits: u8,
        }
        impl Lck7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck6R {
            bits: u8,
        }
        impl Lck6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck5R {
            bits: u8,
        }
        impl Lck5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck4R {
            bits: u8,
        }
        impl Lck4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck3R {
            bits: u8,
        }
        impl Lck3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck2R {
            bits: u8,
        }
        impl Lck2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck1R {
            bits: u8,
        }
        impl Lck1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Lck0R {
            bits: u8,
        }
        impl Lck0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LckkW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LckkW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Lck0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Lck0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lckk(&self) -> LckkR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LckkR { bits }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck15(&self) -> Lck15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck15R { bits }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck14(&self) -> Lck14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck14R { bits }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck13(&self) -> Lck13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck13R { bits }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck12(&self) -> Lck12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck12R { bits }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck11(&self) -> Lck11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck11R { bits }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck10(&self) -> Lck10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck10R { bits }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck9(&self) -> Lck9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck9R { bits }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck8(&self) -> Lck8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck8R { bits }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck7(&self) -> Lck7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck7R { bits }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck6(&self) -> Lck6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck6R { bits }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck5(&self) -> Lck5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck5R { bits }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck4(&self) -> Lck4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck4R { bits }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck3(&self) -> Lck3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck3R { bits }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck2(&self) -> Lck2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck2R { bits }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck1(&self) -> Lck1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck1R { bits }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck0(&self) -> Lck0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Lck0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lckk(&mut self) -> _LckkW {
                _LckkW { w: self }
            }
            #[doc = "Bit 15 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck15(&mut self) -> _Lck15W {
                _Lck15W { w: self }
            }
            #[doc = "Bit 14 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck14(&mut self) -> _Lck14W {
                _Lck14W { w: self }
            }
            #[doc = "Bit 13 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck13(&mut self) -> _Lck13W {
                _Lck13W { w: self }
            }
            #[doc = "Bit 12 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck12(&mut self) -> _Lck12W {
                _Lck12W { w: self }
            }
            #[doc = "Bit 11 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck11(&mut self) -> _Lck11W {
                _Lck11W { w: self }
            }
            #[doc = "Bit 10 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck10(&mut self) -> _Lck10W {
                _Lck10W { w: self }
            }
            #[doc = "Bit 9 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck9(&mut self) -> _Lck9W {
                _Lck9W { w: self }
            }
            #[doc = "Bit 8 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck8(&mut self) -> _Lck8W {
                _Lck8W { w: self }
            }
            #[doc = "Bit 7 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck7(&mut self) -> _Lck7W {
                _Lck7W { w: self }
            }
            #[doc = "Bit 6 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck6(&mut self) -> _Lck6W {
                _Lck6W { w: self }
            }
            #[doc = "Bit 5 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck5(&mut self) -> _Lck5W {
                _Lck5W { w: self }
            }
            #[doc = "Bit 4 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck4(&mut self) -> _Lck4W {
                _Lck4W { w: self }
            }
            #[doc = "Bit 3 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck3(&mut self) -> _Lck3W {
                _Lck3W { w: self }
            }
            #[doc = "Bit 2 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck2(&mut self) -> _Lck2W {
                _Lck2W { w: self }
            }
            #[doc = "Bit 1 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck1(&mut self) -> _Lck1W {
                _Lck1W { w: self }
            }
            #[doc = "Bit 0 - Port x lock bit y (y= 0..15)"]
            #[inline ( always )]
            pub fn lck0(&mut self) -> _Lck0W {
                _Lck0W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function low register"]
    pub struct Afrl {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO alternate function low register"]
    pub mod afrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Afrl {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl7R {
            bits: u8,
        }
        impl Afrl7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl6R {
            bits: u8,
        }
        impl Afrl6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl5R {
            bits: u8,
        }
        impl Afrl5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl4R {
            bits: u8,
        }
        impl Afrl4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl3R {
            bits: u8,
        }
        impl Afrl3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl2R {
            bits: u8,
        }
        impl Afrl2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl1R {
            bits: u8,
        }
        impl Afrl1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrl0R {
            bits: u8,
        }
        impl Afrl0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrl0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrl0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl7(&self) -> Afrl7R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl7R { bits }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl6(&self) -> Afrl6R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl6R { bits }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl5(&self) -> Afrl5R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl5R { bits }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl4(&self) -> Afrl4R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl4R { bits }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl3(&self) -> Afrl3R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl3R { bits }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl2(&self) -> Afrl2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl2R { bits }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl1(&self) -> Afrl1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl1R { bits }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl0(&self) -> Afrl0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrl0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl7(&mut self) -> _Afrl7W {
                _Afrl7W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl6(&mut self) -> _Afrl6W {
                _Afrl6W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl5(&mut self) -> _Afrl5W {
                _Afrl5W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl4(&mut self) -> _Afrl4W {
                _Afrl4W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl3(&mut self) -> _Afrl3W {
                _Afrl3W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl2(&mut self) -> _Afrl2W {
                _Afrl2W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl1(&mut self) -> _Afrl1W {
                _Afrl1W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 0..7)"]
            #[inline ( always )]
            pub fn afrl0(&mut self) -> _Afrl0W {
                _Afrl0W { w: self }
            }
        }
    }
    #[doc = "GPIO alternate function high register"]
    pub struct Afrh {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO alternate function high register"]
    pub mod afrh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Afrh {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh15R {
            bits: u8,
        }
        impl Afrh15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh14R {
            bits: u8,
        }
        impl Afrh14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh13R {
            bits: u8,
        }
        impl Afrh13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh12R {
            bits: u8,
        }
        impl Afrh12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh11R {
            bits: u8,
        }
        impl Afrh11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh10R {
            bits: u8,
        }
        impl Afrh10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh9R {
            bits: u8,
        }
        impl Afrh9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Afrh8R {
            bits: u8,
        }
        impl Afrh8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Afrh8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Afrh8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh15(&self) -> Afrh15R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh15R { bits }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh14(&self) -> Afrh14R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh14R { bits }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh13(&self) -> Afrh13R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh13R { bits }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh12(&self) -> Afrh12R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh12R { bits }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh11(&self) -> Afrh11R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh11R { bits }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh10(&self) -> Afrh10R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh10R { bits }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh9(&self) -> Afrh9R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh9R { bits }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh8(&self) -> Afrh8R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Afrh8R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh15(&mut self) -> _Afrh15W {
                _Afrh15W { w: self }
            }
            #[doc = "Bits 24:27 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh14(&mut self) -> _Afrh14W {
                _Afrh14W { w: self }
            }
            #[doc = "Bits 20:23 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh13(&mut self) -> _Afrh13W {
                _Afrh13W { w: self }
            }
            #[doc = "Bits 16:19 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh12(&mut self) -> _Afrh12W {
                _Afrh12W { w: self }
            }
            #[doc = "Bits 12:15 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh11(&mut self) -> _Afrh11W {
                _Afrh11W { w: self }
            }
            #[doc = "Bits 8:11 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh10(&mut self) -> _Afrh10W {
                _Afrh10W { w: self }
            }
            #[doc = "Bits 4:7 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh9(&mut self) -> _Afrh9W {
                _Afrh9W { w: self }
            }
            #[doc = "Bits 0:3 - Alternate function selection for port x bit y (y = 8..15)"]
            #[inline ( always )]
            pub fn afrh8(&mut self) -> _Afrh8W {
                _Afrh8W { w: self }
            }
        }
    }
    #[doc = "Port bit reset register"]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    #[doc = "Port bit reset register"]
    pub mod brr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Br15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Br15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br0(&mut self) -> _Br0W {
                _Br0W { w: self }
            }
            #[doc = "Bit 1 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br1(&mut self) -> _Br1W {
                _Br1W { w: self }
            }
            #[doc = "Bit 2 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br2(&mut self) -> _Br2W {
                _Br2W { w: self }
            }
            #[doc = "Bit 3 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br3(&mut self) -> _Br3W {
                _Br3W { w: self }
            }
            #[doc = "Bit 4 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br4(&mut self) -> _Br4W {
                _Br4W { w: self }
            }
            #[doc = "Bit 5 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br5(&mut self) -> _Br5W {
                _Br5W { w: self }
            }
            #[doc = "Bit 6 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br6(&mut self) -> _Br6W {
                _Br6W { w: self }
            }
            #[doc = "Bit 7 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br7(&mut self) -> _Br7W {
                _Br7W { w: self }
            }
            #[doc = "Bit 8 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br8(&mut self) -> _Br8W {
                _Br8W { w: self }
            }
            #[doc = "Bit 9 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br9(&mut self) -> _Br9W {
                _Br9W { w: self }
            }
            #[doc = "Bit 10 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br10(&mut self) -> _Br10W {
                _Br10W { w: self }
            }
            #[doc = "Bit 11 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br11(&mut self) -> _Br11W {
                _Br11W { w: self }
            }
            #[doc = "Bit 12 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br12(&mut self) -> _Br12W {
                _Br12W { w: self }
            }
            #[doc = "Bit 13 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br13(&mut self) -> _Br13W {
                _Br13W { w: self }
            }
            #[doc = "Bit 14 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br14(&mut self) -> _Br14W {
                _Br14W { w: self }
            }
            #[doc = "Bit 15 - Port x Reset bit y"]
            #[inline ( always )]
            pub fn br15(&mut self) -> _Br15W {
                _Br15W { w: self }
            }
        }
    }
}
#[doc = "General-purpose I/Os"]
pub struct Gpioa {
    register_block: gpioa::RegisterBlock,
}
impl Deref for Gpioa {
    type Target = gpioa::RegisterBlock;
    fn deref(&self) -> &gpioa::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Serial peripheral interface"]
pub const SPI1: Peripheral<Spi1> = unsafe { Peripheral::new(1073819648) };
#[doc = "Serial peripheral interface"]
pub mod spi1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - status register"]
        pub sr: Sr,
        #[doc = "0x0c - data register"]
        pub dr: Dr,
        #[doc = "0x10 - CRC polynomial register"]
        pub crcpr: Crcpr,
        #[doc = "0x14 - RX CRC register"]
        pub rxcrcr: Rxcrcr,
        #[doc = "0x18 - TX CRC register"]
        pub txcrcr: Txcrcr,
        #[doc = "0x1c - I2S configuration register"]
        pub i2scfgr: I2scfgr,
        #[doc = "0x20 - I2S prescaler register"]
        pub i2spr: I2spr,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BidimodeR {
            bits: u8,
        }
        impl BidimodeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BidioeR {
            bits: u8,
        }
        impl BidioeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CRCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CrcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CrcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrcenR::Disabled => 0,
                    CrcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CrcenR {
                match bits {
                    0 => CrcenR::Disabled,
                    1 => CrcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CrcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CrcenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct CrcnextR {
            bits: u8,
        }
        impl CrcnextR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DffR {
            bits: u8,
        }
        impl DffR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxonlyR {
            bits: u8,
        }
        impl RxonlyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsmR {
            bits: u8,
        }
        impl SsmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsiR {
            bits: u8,
        }
        impl SsiR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LsbfirstR {
            bits: u8,
        }
        impl LsbfirstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SpeR {
            bits: u8,
        }
        impl SpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BrR {
            bits: u8,
        }
        impl BrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MstrR {
            bits: u8,
        }
        impl MstrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CpolR {
            bits: u8,
        }
        impl CpolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CphaR {
            bits: u8,
        }
        impl CphaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BidimodeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BidimodeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BidioeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BidioeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRCEN`"]
        pub enum CrcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CrcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CrcenW::Disabled => 0,
                    CrcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CrcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CrcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CrcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CrcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CrcnextW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcnextW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DffW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxonlyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxonlyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SsiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsiW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsbfirstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsbfirstW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MstrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MstrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline ( always )]
            pub fn bidimode(&self) -> BidimodeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BidimodeR { bits }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline ( always )]
            pub fn bidioe(&self) -> BidioeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BidioeR { bits }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline ( always )]
            pub fn crcen(&self) -> CrcenR {
                CrcenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 13;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline ( always )]
            pub fn crcnext(&self) -> CrcnextR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcnextR { bits }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline ( always )]
            pub fn dff(&self) -> DffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DffR { bits }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline ( always )]
            pub fn rxonly(&self) -> RxonlyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxonlyR { bits }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline ( always )]
            pub fn ssm(&self) -> SsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsmR { bits }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline ( always )]
            pub fn ssi(&self) -> SsiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsiR { bits }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline ( always )]
            pub fn lsbfirst(&self) -> LsbfirstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsbfirstR { bits }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline ( always )]
            pub fn spe(&self) -> SpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SpeR { bits }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline ( always )]
            pub fn br(&self) -> BrR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BrR { bits }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline ( always )]
            pub fn mstr(&self) -> MstrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MstrR { bits }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline ( always )]
            pub fn cpol(&self) -> CpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CpolR { bits }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline ( always )]
            pub fn cpha(&self) -> CphaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CphaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Bidirectional data mode enable"]
            #[inline ( always )]
            pub fn bidimode(&mut self) -> _BidimodeW {
                _BidimodeW { w: self }
            }
            #[doc = "Bit 14 - Output enable in bidirectional mode"]
            #[inline ( always )]
            pub fn bidioe(&mut self) -> _BidioeW {
                _BidioeW { w: self }
            }
            #[doc = "Bit 13 - Hardware CRC calculation enable"]
            #[inline ( always )]
            pub fn crcen(&mut self) -> _CrcenW {
                _CrcenW { w: self }
            }
            #[doc = "Bit 12 - CRC transfer next"]
            #[inline ( always )]
            pub fn crcnext(&mut self) -> _CrcnextW {
                _CrcnextW { w: self }
            }
            #[doc = "Bit 11 - Data frame format"]
            #[inline ( always )]
            pub fn dff(&mut self) -> _DffW {
                _DffW { w: self }
            }
            #[doc = "Bit 10 - Receive only"]
            #[inline ( always )]
            pub fn rxonly(&mut self) -> _RxonlyW {
                _RxonlyW { w: self }
            }
            #[doc = "Bit 9 - Software slave management"]
            #[inline ( always )]
            pub fn ssm(&mut self) -> _SsmW {
                _SsmW { w: self }
            }
            #[doc = "Bit 8 - Internal slave select"]
            #[inline ( always )]
            pub fn ssi(&mut self) -> _SsiW {
                _SsiW { w: self }
            }
            #[doc = "Bit 7 - Frame format"]
            #[inline ( always )]
            pub fn lsbfirst(&mut self) -> _LsbfirstW {
                _LsbfirstW { w: self }
            }
            #[doc = "Bit 6 - SPI enable"]
            #[inline ( always )]
            pub fn spe(&mut self) -> _SpeW {
                _SpeW { w: self }
            }
            #[doc = "Bits 3:5 - Baud rate control"]
            #[inline ( always )]
            pub fn br(&mut self) -> _BrW {
                _BrW { w: self }
            }
            #[doc = "Bit 2 - Master selection"]
            #[inline ( always )]
            pub fn mstr(&mut self) -> _MstrW {
                _MstrW { w: self }
            }
            #[doc = "Bit 1 - Clock polarity"]
            #[inline ( always )]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
            #[doc = "Bit 0 - Clock phase"]
            #[inline ( always )]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `RXDMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum RxdmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RxdmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdmaenR::Disabled => 0,
                    RxdmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> RxdmaenR {
                match bits {
                    0 => RxdmaenR::Disabled,
                    1 => RxdmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == RxdmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == RxdmaenR::Enabled
            }
        }
        #[doc = "Possible values of the field `TXDMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TxdmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TxdmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdmaenR::Disabled => 0,
                    TxdmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TxdmaenR {
                match bits {
                    0 => TxdmaenR::Disabled,
                    1 => TxdmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TxdmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TxdmaenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsoeR {
            bits: u8,
        }
        impl SsoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NsspR {
            bits: u8,
        }
        impl NsspR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FrfR {
            bits: u8,
        }
        impl FrfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ErrieR {
            bits: u8,
        }
        impl ErrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DsR {
            bits: u8,
        }
        impl DsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FrxthR {
            bits: u8,
        }
        impl FrxthR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LdmaRxR {
            bits: u8,
        }
        impl LdmaRxR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LdmaTxR {
            bits: u8,
        }
        impl LdmaTxR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `RXDMAEN`"]
        pub enum RxdmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RxdmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdmaenW::Disabled => 0,
                    RxdmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: RxdmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RxdmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RxdmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDMAEN`"]
        pub enum TxdmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TxdmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdmaenW::Disabled => 0,
                    TxdmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TxdmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TxdmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TxdmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SsoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NsspW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NsspW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FrfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ErrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FrxthW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FrxthW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LdmaRxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LdmaRxW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LdmaTxW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LdmaTxW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline ( always )]
            pub fn rxdmaen(&self) -> RxdmaenR {
                RxdmaenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 0;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline ( always )]
            pub fn txdmaen(&self) -> TxdmaenR {
                TxdmaenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 1;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline ( always )]
            pub fn ssoe(&self) -> SsoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsoeR { bits }
            }
            #[doc = "Bit 3 - NSS pulse management"]
            #[inline ( always )]
            pub fn nssp(&self) -> NsspR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NsspR { bits }
            }
            #[doc = "Bit 4 - Frame format"]
            #[inline ( always )]
            pub fn frf(&self) -> FrfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FrfR { bits }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline ( always )]
            pub fn errie(&self) -> ErrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ErrieR { bits }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline ( always )]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline ( always )]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            #[doc = "Bits 8:11 - Data size"]
            #[inline ( always )]
            pub fn ds(&self) -> DsR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DsR { bits }
            }
            #[doc = "Bit 12 - FIFO reception threshold"]
            #[inline ( always )]
            pub fn frxth(&self) -> FrxthR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FrxthR { bits }
            }
            #[doc = "Bit 13 - Last DMA transfer for reception"]
            #[inline ( always )]
            pub fn ldma_rx(&self) -> LdmaRxR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LdmaRxR { bits }
            }
            #[doc = "Bit 14 - Last DMA transfer for transmission"]
            #[inline ( always )]
            pub fn ldma_tx(&self) -> LdmaTxR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LdmaTxR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Rx buffer DMA enable"]
            #[inline ( always )]
            pub fn rxdmaen(&mut self) -> _RxdmaenW {
                _RxdmaenW { w: self }
            }
            #[doc = "Bit 1 - Tx buffer DMA enable"]
            #[inline ( always )]
            pub fn txdmaen(&mut self) -> _TxdmaenW {
                _TxdmaenW { w: self }
            }
            #[doc = "Bit 2 - SS output enable"]
            #[inline ( always )]
            pub fn ssoe(&mut self) -> _SsoeW {
                _SsoeW { w: self }
            }
            #[doc = "Bit 3 - NSS pulse management"]
            #[inline ( always )]
            pub fn nssp(&mut self) -> _NsspW {
                _NsspW { w: self }
            }
            #[doc = "Bit 4 - Frame format"]
            #[inline ( always )]
            pub fn frf(&mut self) -> _FrfW {
                _FrfW { w: self }
            }
            #[doc = "Bit 5 - Error interrupt enable"]
            #[inline ( always )]
            pub fn errie(&mut self) -> _ErrieW {
                _ErrieW { w: self }
            }
            #[doc = "Bit 6 - RX buffer not empty interrupt enable"]
            #[inline ( always )]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            #[doc = "Bit 7 - Tx buffer empty interrupt enable"]
            #[inline ( always )]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            #[doc = "Bits 8:11 - Data size"]
            #[inline ( always )]
            pub fn ds(&mut self) -> _DsW {
                _DsW { w: self }
            }
            #[doc = "Bit 12 - FIFO reception threshold"]
            #[inline ( always )]
            pub fn frxth(&mut self) -> _FrxthW {
                _FrxthW { w: self }
            }
            #[doc = "Bit 13 - Last DMA transfer for reception"]
            #[inline ( always )]
            pub fn ldma_rx(&mut self) -> _LdmaRxW {
                _LdmaRxW { w: self }
            }
            #[doc = "Bit 14 - Last DMA transfer for transmission"]
            #[inline ( always )]
            pub fn ldma_tx(&mut self) -> _LdmaTxW {
                _LdmaTxW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ChsideR {
            bits: u8,
        }
        impl ChsideR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdrR {
            bits: u8,
        }
        impl UdrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CrcerrR {
            bits: u8,
        }
        impl CrcerrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ModfR {
            bits: u8,
        }
        impl ModfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrR {
            bits: u8,
        }
        impl OvrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BsyR {
            bits: u8,
        }
        impl BsyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TifrfeR {
            bits: u8,
        }
        impl TifrfeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FrlvlR {
            bits: u8,
        }
        impl FrlvlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FtlvlR {
            bits: u8,
        }
        impl FtlvlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CrcerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcerrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receive buffer not empty"]
            #[inline ( always )]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            #[doc = "Bit 1 - Transmit buffer empty"]
            #[inline ( always )]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            #[doc = "Bit 2 - Channel side"]
            #[inline ( always )]
            pub fn chside(&self) -> ChsideR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ChsideR { bits }
            }
            #[doc = "Bit 3 - Underrun flag"]
            #[inline ( always )]
            pub fn udr(&self) -> UdrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdrR { bits }
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline ( always )]
            pub fn crcerr(&self) -> CrcerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CrcerrR { bits }
            }
            #[doc = "Bit 5 - Mode fault"]
            #[inline ( always )]
            pub fn modf(&self) -> ModfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ModfR { bits }
            }
            #[doc = "Bit 6 - Overrun flag"]
            #[inline ( always )]
            pub fn ovr(&self) -> OvrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrR { bits }
            }
            #[doc = "Bit 7 - Busy flag"]
            #[inline ( always )]
            pub fn bsy(&self) -> BsyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BsyR { bits }
            }
            #[doc = "Bit 8 - TI frame format error"]
            #[inline ( always )]
            pub fn tifrfe(&self) -> TifrfeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifrfeR { bits }
            }
            #[doc = "Bits 9:10 - FIFO reception level"]
            #[inline ( always )]
            pub fn frlvl(&self) -> FrlvlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FrlvlR { bits }
            }
            #[doc = "Bits 11:12 - FIFO transmission level"]
            #[inline ( always )]
            pub fn ftlvl(&self) -> FtlvlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FtlvlR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 4 - CRC error flag"]
            #[inline ( always )]
            pub fn crcerr(&mut self) -> _CrcerrW {
                _CrcerrW { w: self }
            }
        }
    }
    #[doc = "data register"]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    #[doc = "data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DrR {
            bits: u16,
        }
        impl DrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Data register"]
            #[inline ( always )]
            pub fn dr(&self) -> DrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Data register"]
            #[inline ( always )]
            pub fn dr(&mut self) -> _DrW {
                _DrW { w: self }
            }
        }
    }
    #[doc = "CRC polynomial register"]
    pub struct Crcpr {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC polynomial register"]
    pub mod crcpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Crcpr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CrcpolyR {
            bits: u16,
        }
        impl CrcpolyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CrcpolyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcpolyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline ( always )]
            pub fn crcpoly(&self) -> CrcpolyR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CrcpolyR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 7 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - CRC polynomial register"]
            #[inline ( always )]
            pub fn crcpoly(&mut self) -> _CrcpolyW {
                _CrcpolyW { w: self }
            }
        }
    }
    #[doc = "RX CRC register"]
    pub struct Rxcrcr {
        register: VolatileCell<u32>,
    }
    #[doc = "RX CRC register"]
    pub mod rxcrcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Rxcrcr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxCrcR {
            bits: u16,
        }
        impl RxCrcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Rx CRC register"]
            #[inline ( always )]
            pub fn rx_crc(&self) -> RxCrcR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RxCrcR { bits }
            }
        }
    }
    #[doc = "TX CRC register"]
    pub struct Txcrcr {
        register: VolatileCell<u32>,
    }
    #[doc = "TX CRC register"]
    pub mod txcrcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Txcrcr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxCrcR {
            bits: u16,
        }
        impl TxCrcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Tx CRC register"]
            #[inline ( always )]
            pub fn tx_crc(&self) -> TxCrcR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TxCrcR { bits }
            }
        }
    }
    #[doc = "I2S configuration register"]
    pub struct I2scfgr {
        register: VolatileCell<u32>,
    }
    #[doc = "I2S configuration register"]
    pub mod i2scfgr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2scfgr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2smodR {
            bits: u8,
        }
        impl I2smodR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2seR {
            bits: u8,
        }
        impl I2seR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2scfgR {
            bits: u8,
        }
        impl I2scfgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PcmsyncR {
            bits: u8,
        }
        impl PcmsyncR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2sstdR {
            bits: u8,
        }
        impl I2sstdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkpolR {
            bits: u8,
        }
        impl CkpolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DatlenR {
            bits: u8,
        }
        impl DatlenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ChlenR {
            bits: u8,
        }
        impl ChlenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2smodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2smodW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2seW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2seW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2scfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2scfgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PcmsyncW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PcmsyncW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2sstdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2sstdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkpolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DatlenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatlenW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ChlenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ChlenW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 11 - I2S mode selection"]
            #[inline ( always )]
            pub fn i2smod(&self) -> I2smodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2smodR { bits }
            }
            #[doc = "Bit 10 - I2S Enable"]
            #[inline ( always )]
            pub fn i2se(&self) -> I2seR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2seR { bits }
            }
            #[doc = "Bits 8:9 - I2S configuration mode"]
            #[inline ( always )]
            pub fn i2scfg(&self) -> I2scfgR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2scfgR { bits }
            }
            #[doc = "Bit 7 - PCM frame synchronization"]
            #[inline ( always )]
            pub fn pcmsync(&self) -> PcmsyncR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PcmsyncR { bits }
            }
            #[doc = "Bits 4:5 - I2S standard selection"]
            #[inline ( always )]
            pub fn i2sstd(&self) -> I2sstdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2sstdR { bits }
            }
            #[doc = "Bit 3 - Steady state clock polarity"]
            #[inline ( always )]
            pub fn ckpol(&self) -> CkpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkpolR { bits }
            }
            #[doc = "Bits 1:2 - Data length to be transferred"]
            #[inline ( always )]
            pub fn datlen(&self) -> DatlenR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatlenR { bits }
            }
            #[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
            #[inline ( always )]
            pub fn chlen(&self) -> ChlenR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ChlenR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 11 - I2S mode selection"]
            #[inline ( always )]
            pub fn i2smod(&mut self) -> _I2smodW {
                _I2smodW { w: self }
            }
            #[doc = "Bit 10 - I2S Enable"]
            #[inline ( always )]
            pub fn i2se(&mut self) -> _I2seW {
                _I2seW { w: self }
            }
            #[doc = "Bits 8:9 - I2S configuration mode"]
            #[inline ( always )]
            pub fn i2scfg(&mut self) -> _I2scfgW {
                _I2scfgW { w: self }
            }
            #[doc = "Bit 7 - PCM frame synchronization"]
            #[inline ( always )]
            pub fn pcmsync(&mut self) -> _PcmsyncW {
                _PcmsyncW { w: self }
            }
            #[doc = "Bits 4:5 - I2S standard selection"]
            #[inline ( always )]
            pub fn i2sstd(&mut self) -> _I2sstdW {
                _I2sstdW { w: self }
            }
            #[doc = "Bit 3 - Steady state clock polarity"]
            #[inline ( always )]
            pub fn ckpol(&mut self) -> _CkpolW {
                _CkpolW { w: self }
            }
            #[doc = "Bits 1:2 - Data length to be transferred"]
            #[inline ( always )]
            pub fn datlen(&mut self) -> _DatlenW {
                _DatlenW { w: self }
            }
            #[doc = "Bit 0 - Channel length (number of bits per audio channel)"]
            #[inline ( always )]
            pub fn chlen(&mut self) -> _ChlenW {
                _ChlenW { w: self }
            }
        }
    }
    #[doc = "I2S prescaler register"]
    pub struct I2spr {
        register: VolatileCell<u32>,
    }
    #[doc = "I2S prescaler register"]
    pub mod i2spr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::I2spr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MckoeR {
            bits: u8,
        }
        impl MckoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OddR {
            bits: u8,
        }
        impl OddR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2sdivR {
            bits: u8,
        }
        impl I2sdivR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MckoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MckoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OddW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OddW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2sdivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2sdivW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Master clock output enable"]
            #[inline ( always )]
            pub fn mckoe(&self) -> MckoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MckoeR { bits }
            }
            #[doc = "Bit 8 - Odd factor for the prescaler"]
            #[inline ( always )]
            pub fn odd(&self) -> OddR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OddR { bits }
            }
            #[doc = "Bits 0:7 - I2S Linear prescaler"]
            #[inline ( always )]
            pub fn i2sdiv(&self) -> I2sdivR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2sdivR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 16 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Master clock output enable"]
            #[inline ( always )]
            pub fn mckoe(&mut self) -> _MckoeW {
                _MckoeW { w: self }
            }
            #[doc = "Bit 8 - Odd factor for the prescaler"]
            #[inline ( always )]
            pub fn odd(&mut self) -> _OddW {
                _OddW { w: self }
            }
            #[doc = "Bits 0:7 - I2S Linear prescaler"]
            #[inline ( always )]
            pub fn i2sdiv(&mut self) -> _I2sdivW {
                _I2sdivW { w: self }
            }
        }
    }
}
#[doc = "Serial peripheral interface"]
pub struct Spi1 {
    register_block: spi1::RegisterBlock,
}
impl Deref for Spi1 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "SPI2"]
pub const SPI2: Peripheral<Spi2> = unsafe { Peripheral::new(1073756160) };
#[doc = r" Register block"]
pub struct Spi2 {
    register_block: spi1::RegisterBlock,
}
impl Deref for Spi2 {
    type Target = spi1::RegisterBlock;
    fn deref(&self) -> &spi1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Digital-to-analog converter"]
pub const DAC: Peripheral<Dac> = unsafe { Peripheral::new(1073771520) };
#[doc = "Digital-to-analog converter"]
pub mod dac {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register"]
        pub cr: Cr,
        #[doc = "0x04 - software trigger register"]
        pub swtrigr: Swtrigr,
        #[doc = "0x08 - channel1 12-bit right-aligned data holding register"]
        pub dhr12r1: Dhr12r1,
        #[doc = "0x0c - channel1 12-bit left aligned data holding register"]
        pub dhr12l1: Dhr12l1,
        #[doc = "0x10 - channel1 8-bit right aligned data holding register"]
        pub dhr8r1: Dhr8r1,
        _reserved0: [u8; 24usize],
        #[doc = "0x2c - channel1 data output register"]
        pub dor1: Dor1,
        _reserved1: [u8; 4usize],
        #[doc = "0x34 - status register"]
        pub sr: Sr,
    }
    #[doc = "control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct En1R {
            bits: u8,
        }
        impl En1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Boff1R {
            bits: u8,
        }
        impl Boff1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ten1R {
            bits: u8,
        }
        impl Ten1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tsel10R {
            bits: u8,
        }
        impl Tsel10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tsel11R {
            bits: u8,
        }
        impl Tsel11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tsel12R {
            bits: u8,
        }
        impl Tsel12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dmaen1R {
            bits: u8,
        }
        impl Dmaen1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dmaudrie1R {
            bits: u8,
        }
        impl Dmaudrie1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _En1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _En1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Boff1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Boff1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ten1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ten1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tsel10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tsel10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tsel11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tsel11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tsel12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tsel12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dmaen1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaen1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dmaudrie1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudrie1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline ( always )]
            pub fn en1(&self) -> En1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                En1R { bits }
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline ( always )]
            pub fn boff1(&self) -> Boff1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Boff1R { bits }
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline ( always )]
            pub fn ten1(&self) -> Ten1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ten1R { bits }
            }
            #[doc = "Bit 3 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel10(&self) -> Tsel10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tsel10R { bits }
            }
            #[doc = "Bit 4 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel11(&self) -> Tsel11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tsel11R { bits }
            }
            #[doc = "Bit 5 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel12(&self) -> Tsel12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tsel12R { bits }
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline ( always )]
            pub fn dmaen1(&self) -> Dmaen1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaen1R { bits }
            }
            #[doc = "Bit 13 - DAC channel1 DMA Underrun Interrupt enable"]
            #[inline ( always )]
            pub fn dmaudrie1(&self) -> Dmaudrie1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudrie1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DAC channel1 enable"]
            #[inline ( always )]
            pub fn en1(&mut self) -> _En1W {
                _En1W { w: self }
            }
            #[doc = "Bit 1 - DAC channel1 output buffer disable"]
            #[inline ( always )]
            pub fn boff1(&mut self) -> _Boff1W {
                _Boff1W { w: self }
            }
            #[doc = "Bit 2 - DAC channel1 trigger enable"]
            #[inline ( always )]
            pub fn ten1(&mut self) -> _Ten1W {
                _Ten1W { w: self }
            }
            #[doc = "Bit 3 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel10(&mut self) -> _Tsel10W {
                _Tsel10W { w: self }
            }
            #[doc = "Bit 4 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel11(&mut self) -> _Tsel11W {
                _Tsel11W { w: self }
            }
            #[doc = "Bit 5 - DAC channel1 trigger selection"]
            #[inline ( always )]
            pub fn tsel12(&mut self) -> _Tsel12W {
                _Tsel12W { w: self }
            }
            #[doc = "Bit 12 - DAC channel1 DMA enable"]
            #[inline ( always )]
            pub fn dmaen1(&mut self) -> _Dmaen1W {
                _Dmaen1W { w: self }
            }
            #[doc = "Bit 13 - DAC channel1 DMA Underrun Interrupt enable"]
            #[inline ( always )]
            pub fn dmaudrie1(&mut self) -> _Dmaudrie1W {
                _Dmaudrie1W { w: self }
            }
        }
    }
    #[doc = "software trigger register"]
    pub struct Swtrigr {
        register: VolatileCell<u32>,
    }
    #[doc = "software trigger register"]
    pub mod swtrigr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Swtrigr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Swtrig1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swtrig1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DAC channel1 software trigger"]
            #[inline ( always )]
            pub fn swtrig1(&mut self) -> _Swtrig1W {
                _Swtrig1W { w: self }
            }
        }
    }
    #[doc = "channel1 12-bit right-aligned data holding register"]
    pub struct Dhr12r1 {
        register: VolatileCell<u32>,
    }
    #[doc = "channel1 12-bit right-aligned data holding register"]
    pub mod dhr12r1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12r1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - DAC channel1 12-bit right-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    #[doc = "channel1 12-bit left aligned data holding register"]
    pub struct Dhr12l1 {
        register: VolatileCell<u32>,
    }
    #[doc = "channel1 12-bit left aligned data holding register"]
    pub mod dhr12l1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr12l1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dacc1dhrR {
            bits: u16,
        }
        impl Dacc1dhrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - DAC channel1 12-bit left-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    #[doc = "channel1 8-bit right aligned data holding register"]
    pub struct Dhr8r1 {
        register: VolatileCell<u32>,
    }
    #[doc = "channel1 8-bit right aligned data holding register"]
    pub mod dhr8r1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dhr8r1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dacc1dhrR {
            bits: u8,
        }
        impl Dacc1dhrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dacc1dhrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dacc1dhrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&self) -> Dacc1dhrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dacc1dhrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - DAC channel1 8-bit right-aligned data"]
            #[inline ( always )]
            pub fn dacc1dhr(&mut self) -> _Dacc1dhrW {
                _Dacc1dhrW { w: self }
            }
        }
    }
    #[doc = "channel1 data output register"]
    pub struct Dor1 {
        register: VolatileCell<u32>,
    }
    #[doc = "channel1 data output register"]
    pub mod dor1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Dor1 {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dacc1dorR {
            bits: u16,
        }
        impl Dacc1dorR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - DAC channel1 data output"]
            #[inline ( always )]
            pub fn dacc1dor(&self) -> Dacc1dorR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Dacc1dorR { bits }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dmaudr2R {
            bits: u8,
        }
        impl Dmaudr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Dmaudr1R {
            bits: u8,
        }
        impl Dmaudr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dmaudr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Dmaudr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Dmaudr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline ( always )]
            pub fn dmaudr2(&self) -> Dmaudr2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudr2R { bits }
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline ( always )]
            pub fn dmaudr1(&self) -> Dmaudr1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Dmaudr1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 29 - DAC channel2 DMA underrun flag"]
            #[inline ( always )]
            pub fn dmaudr2(&mut self) -> _Dmaudr2W {
                _Dmaudr2W { w: self }
            }
            #[doc = "Bit 13 - DAC channel1 DMA underrun flag"]
            #[inline ( always )]
            pub fn dmaudr1(&mut self) -> _Dmaudr1W {
                _Dmaudr1W { w: self }
            }
        }
    }
}
#[doc = "Digital-to-analog converter"]
pub struct Dac {
    register_block: dac::RegisterBlock,
}
impl Deref for Dac {
    type Target = dac::RegisterBlock;
    fn deref(&self) -> &dac::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Power control"]
pub const PWR: Peripheral<Pwr> = unsafe { Peripheral::new(1073770496) };
#[doc = "Power control"]
pub mod pwr {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - power control register"]
        pub cr: Cr,
        #[doc = "0x04 - power control/status register"]
        pub csr: Csr,
    }
    #[doc = "power control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "power control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct FpdsR {
            bits: u8,
        }
        impl FpdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbpR {
            bits: u8,
        }
        impl DbpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlsR {
            bits: u8,
        }
        impl PlsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PvdeR {
            bits: u8,
        }
        impl PvdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CsbfR {
            bits: u8,
        }
        impl CsbfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CwufR {
            bits: u8,
        }
        impl CwufR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PddsR {
            bits: u8,
        }
        impl PddsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LpdsR {
            bits: u8,
        }
        impl LpdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FpdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FpdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PvdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PvdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CsbfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CsbfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CwufW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CwufW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PddsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PddsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LpdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Flash power down in Stop mode"]
            #[inline ( always )]
            pub fn fpds(&self) -> FpdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FpdsR { bits }
            }
            #[doc = "Bit 8 - Disable backup domain write protection"]
            #[inline ( always )]
            pub fn dbp(&self) -> DbpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbpR { bits }
            }
            #[doc = "Bits 5:7 - PVD level selection"]
            #[inline ( always )]
            pub fn pls(&self) -> PlsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlsR { bits }
            }
            #[doc = "Bit 4 - Power voltage detector enable"]
            #[inline ( always )]
            pub fn pvde(&self) -> PvdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvdeR { bits }
            }
            #[doc = "Bit 3 - Clear standby flag"]
            #[inline ( always )]
            pub fn csbf(&self) -> CsbfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CsbfR { bits }
            }
            #[doc = "Bit 2 - Clear wakeup flag"]
            #[inline ( always )]
            pub fn cwuf(&self) -> CwufR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CwufR { bits }
            }
            #[doc = "Bit 1 - Power down deepsleep"]
            #[inline ( always )]
            pub fn pdds(&self) -> PddsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PddsR { bits }
            }
            #[doc = "Bit 0 - Low-power deep sleep"]
            #[inline ( always )]
            pub fn lpds(&self) -> LpdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LpdsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Flash power down in Stop mode"]
            #[inline ( always )]
            pub fn fpds(&mut self) -> _FpdsW {
                _FpdsW { w: self }
            }
            #[doc = "Bit 8 - Disable backup domain write protection"]
            #[inline ( always )]
            pub fn dbp(&mut self) -> _DbpW {
                _DbpW { w: self }
            }
            #[doc = "Bits 5:7 - PVD level selection"]
            #[inline ( always )]
            pub fn pls(&mut self) -> _PlsW {
                _PlsW { w: self }
            }
            #[doc = "Bit 4 - Power voltage detector enable"]
            #[inline ( always )]
            pub fn pvde(&mut self) -> _PvdeW {
                _PvdeW { w: self }
            }
            #[doc = "Bit 3 - Clear standby flag"]
            #[inline ( always )]
            pub fn csbf(&mut self) -> _CsbfW {
                _CsbfW { w: self }
            }
            #[doc = "Bit 2 - Clear wakeup flag"]
            #[inline ( always )]
            pub fn cwuf(&mut self) -> _CwufW {
                _CwufW { w: self }
            }
            #[doc = "Bit 1 - Power down deepsleep"]
            #[inline ( always )]
            pub fn pdds(&mut self) -> _PddsW {
                _PddsW { w: self }
            }
            #[doc = "Bit 0 - Low-power deep sleep"]
            #[inline ( always )]
            pub fn lpds(&mut self) -> _LpdsW {
                _LpdsW { w: self }
            }
        }
    }
    #[doc = "power control/status register"]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    #[doc = "power control/status register"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BreR {
            bits: u8,
        }
        impl BreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EwupR {
            bits: u8,
        }
        impl EwupR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BrrR {
            bits: u8,
        }
        impl BrrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PvdoR {
            bits: u8,
        }
        impl PvdoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbfR {
            bits: u8,
        }
        impl SbfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WufR {
            bits: u8,
        }
        impl WufR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EwupW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwupW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Backup regulator enable"]
            #[inline ( always )]
            pub fn bre(&self) -> BreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BreR { bits }
            }
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline ( always )]
            pub fn ewup(&self) -> EwupR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwupR { bits }
            }
            #[doc = "Bit 3 - Backup regulator ready"]
            #[inline ( always )]
            pub fn brr(&self) -> BrrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BrrR { bits }
            }
            #[doc = "Bit 2 - PVD output"]
            #[inline ( always )]
            pub fn pvdo(&self) -> PvdoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvdoR { bits }
            }
            #[doc = "Bit 1 - Standby flag"]
            #[inline ( always )]
            pub fn sbf(&self) -> SbfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbfR { bits }
            }
            #[doc = "Bit 0 - Wakeup flag"]
            #[inline ( always )]
            pub fn wuf(&self) -> WufR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WufR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Backup regulator enable"]
            #[inline ( always )]
            pub fn bre(&mut self) -> _BreW {
                _BreW { w: self }
            }
            #[doc = "Bit 8 - Enable WKUP pin"]
            #[inline ( always )]
            pub fn ewup(&mut self) -> _EwupW {
                _EwupW { w: self }
            }
        }
    }
}
#[doc = "Power control"]
pub struct Pwr {
    register_block: pwr::RegisterBlock,
}
impl Deref for Pwr {
    type Target = pwr::RegisterBlock;
    fn deref(&self) -> &pwr::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Inter-integrated circuit"]
pub const I2C1: Peripheral<I2c1> = unsafe { Peripheral::new(1073763328) };
#[doc = "Inter-integrated circuit"]
pub mod i2c1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - Own address register 1"]
        pub oar1: Oar1,
        #[doc = "0x0c - Own address register 2"]
        pub oar2: Oar2,
        #[doc = "0x10 - Timing register"]
        pub timingr: Timingr,
        #[doc = "0x14 - Status register 1"]
        pub timeoutr: Timeoutr,
        #[doc = "0x18 - Interrupt and Status register"]
        pub isr: Isr,
        #[doc = "0x1c - Interrupt clear register"]
        pub icr: Icr,
        #[doc = "0x20 - PEC register"]
        pub pecr: Pecr,
        #[doc = "0x24 - Receive data register"]
        pub rxdr: Rxdr,
        #[doc = "0x28 - Transmit data register"]
        pub txdr: Txdr,
    }
    #[doc = "Control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxieR {
            bits: u8,
        }
        impl TxieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxieR {
            bits: u8,
        }
        impl RxieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AddrieR {
            bits: u8,
        }
        impl AddrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NackieR {
            bits: u8,
        }
        impl NackieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StopieR {
            bits: u8,
        }
        impl StopieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ErrieR {
            bits: u8,
        }
        impl ErrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DnfR {
            bits: u8,
        }
        impl DnfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AnfoffR {
            bits: u8,
        }
        impl AnfoffR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TXDMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TxdmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TxdmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TxdmaenR::Disabled => 0,
                    TxdmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TxdmaenR {
                match bits {
                    0 => TxdmaenR::Disabled,
                    1 => TxdmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TxdmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TxdmaenR::Enabled
            }
        }
        #[doc = "Possible values of the field `RXDMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum RxdmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RxdmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    RxdmaenR::Disabled => 0,
                    RxdmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> RxdmaenR {
                match bits {
                    0 => RxdmaenR::Disabled,
                    1 => RxdmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == RxdmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == RxdmaenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbcR {
            bits: u8,
        }
        impl SbcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NostretchR {
            bits: u8,
        }
        impl NostretchR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `WUPEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum WupenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WupenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    WupenR::Disabled => 0,
                    WupenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> WupenR {
                match bits {
                    0 => WupenR::Disabled,
                    1 => WupenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == WupenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == WupenR::Enabled
            }
        }
        #[doc = "Possible values of the field `GCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum GcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl GcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    GcenR::Disabled => 0,
                    GcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> GcenR {
                match bits {
                    0 => GcenR::Disabled,
                    1 => GcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == GcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == GcenR::Enabled
            }
        }
        #[doc = "Possible values of the field `SMBHEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SmbhenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SmbhenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SmbhenR::Disabled => 0,
                    SmbhenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SmbhenR {
                match bits {
                    0 => SmbhenR::Disabled,
                    1 => SmbhenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == SmbhenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == SmbhenR::Enabled
            }
        }
        #[doc = "Possible values of the field `SMBDEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SmbdenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SmbdenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SmbdenR::Disabled => 0,
                    SmbdenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SmbdenR {
                match bits {
                    0 => SmbdenR::Disabled,
                    1 => SmbdenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == SmbdenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == SmbdenR::Enabled
            }
        }
        #[doc = "Possible values of the field `ALERTEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AlertenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AlertenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AlertenR::Disabled => 0,
                    AlertenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AlertenR {
                match bits {
                    0 => AlertenR::Disabled,
                    1 => AlertenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == AlertenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == AlertenR::Enabled
            }
        }
        #[doc = "Possible values of the field `PECEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PecenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl PecenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PecenR::Disabled => 0,
                    PecenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PecenR {
                match bits {
                    0 => PecenR::Disabled,
                    1 => PecenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == PecenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == PecenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _PeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AddrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NackieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StopieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ErrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DnfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DnfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AnfoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AnfoffW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWRST`"]
        pub enum SwrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl SwrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SwrstW::NoEffect => 0,
                    SwrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SwrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SwrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SwrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(SwrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDMAEN`"]
        pub enum TxdmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TxdmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TxdmaenW::Disabled => 0,
                    TxdmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TxdmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TxdmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TxdmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDMAEN`"]
        pub enum RxdmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RxdmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RxdmaenW::Disabled => 0,
                    RxdmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxdmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxdmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: RxdmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RxdmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RxdmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SbcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbcW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NostretchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NostretchW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WUPEN`"]
        pub enum WupenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WupenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WupenW::Disabled => 0,
                    WupenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WupenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WupenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: WupenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WupenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WupenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GCEN`"]
        pub enum GcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl GcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    GcenW::Disabled => 0,
                    GcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: GcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(GcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(GcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SMBHEN`"]
        pub enum SmbhenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SmbhenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SmbhenW::Disabled => 0,
                    SmbhenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmbhenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmbhenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SmbhenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SmbhenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SmbhenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SMBDEN`"]
        pub enum SmbdenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SmbdenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SmbdenW::Disabled => 0,
                    SmbdenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmbdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmbdenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SmbdenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SmbdenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SmbdenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ALERTEN`"]
        pub enum AlertenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AlertenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AlertenW::Disabled => 0,
                    AlertenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlertenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlertenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AlertenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AlertenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AlertenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PECEN`"]
        pub enum PecenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl PecenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PecenW::Disabled => 0,
                    PecenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PecenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PecenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PecenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PecenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PecenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline ( always )]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
            #[doc = "Bit 1 - TX Interrupt enable"]
            #[inline ( always )]
            pub fn txie(&self) -> TxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxieR { bits }
            }
            #[doc = "Bit 2 - RX Interrupt enable"]
            #[inline ( always )]
            pub fn rxie(&self) -> RxieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxieR { bits }
            }
            #[doc = "Bit 3 - Address match interrupt enable (slave only)"]
            #[inline ( always )]
            pub fn addrie(&self) -> AddrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddrieR { bits }
            }
            #[doc = "Bit 4 - Not acknowledge received interrupt enable"]
            #[inline ( always )]
            pub fn nackie(&self) -> NackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NackieR { bits }
            }
            #[doc = "Bit 5 - STOP detection Interrupt enable"]
            #[inline ( always )]
            pub fn stopie(&self) -> StopieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopieR { bits }
            }
            #[doc = "Bit 6 - Transfer Complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 7 - Error interrupts enable"]
            #[inline ( always )]
            pub fn errie(&self) -> ErrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ErrieR { bits }
            }
            #[doc = "Bits 8:11 - Digital noise filter"]
            #[inline ( always )]
            pub fn dnf(&self) -> DnfR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DnfR { bits }
            }
            #[doc = "Bit 12 - Analog noise filter OFF"]
            #[inline ( always )]
            pub fn anfoff(&self) -> AnfoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AnfoffR { bits }
            }
            #[doc = "Bit 14 - DMA transmission requests enable"]
            #[inline ( always )]
            pub fn txdmaen(&self) -> TxdmaenR {
                TxdmaenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 14;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 15 - DMA reception requests enable"]
            #[inline ( always )]
            pub fn rxdmaen(&self) -> RxdmaenR {
                RxdmaenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 15;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 16 - Slave byte control"]
            #[inline ( always )]
            pub fn sbc(&self) -> SbcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbcR { bits }
            }
            #[doc = "Bit 17 - Clock stretching disable"]
            #[inline ( always )]
            pub fn nostretch(&self) -> NostretchR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NostretchR { bits }
            }
            #[doc = "Bit 18 - Wakeup from STOP enable"]
            #[inline ( always )]
            pub fn wupen(&self) -> WupenR {
                WupenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 18;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 19 - General call enable"]
            #[inline ( always )]
            pub fn gcen(&self) -> GcenR {
                GcenR::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 20 - SMBus Host address enable"]
            #[inline ( always )]
            pub fn smbhen(&self) -> SmbhenR {
                SmbhenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 20;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 21 - SMBus Device Default address enable"]
            #[inline ( always )]
            pub fn smbden(&self) -> SmbdenR {
                SmbdenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 21;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 22 - SMBUS alert enable"]
            #[inline ( always )]
            pub fn alerten(&self) -> AlertenR {
                AlertenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 22;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 23 - PEC enable"]
            #[inline ( always )]
            pub fn pecen(&self) -> PecenR {
                PecenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 23;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral enable"]
            #[inline ( always )]
            pub fn pe(&mut self) -> _PeW {
                _PeW { w: self }
            }
            #[doc = "Bit 1 - TX Interrupt enable"]
            #[inline ( always )]
            pub fn txie(&mut self) -> _TxieW {
                _TxieW { w: self }
            }
            #[doc = "Bit 2 - RX Interrupt enable"]
            #[inline ( always )]
            pub fn rxie(&mut self) -> _RxieW {
                _RxieW { w: self }
            }
            #[doc = "Bit 3 - Address match interrupt enable (slave only)"]
            #[inline ( always )]
            pub fn addrie(&mut self) -> _AddrieW {
                _AddrieW { w: self }
            }
            #[doc = "Bit 4 - Not acknowledge received interrupt enable"]
            #[inline ( always )]
            pub fn nackie(&mut self) -> _NackieW {
                _NackieW { w: self }
            }
            #[doc = "Bit 5 - STOP detection Interrupt enable"]
            #[inline ( always )]
            pub fn stopie(&mut self) -> _StopieW {
                _StopieW { w: self }
            }
            #[doc = "Bit 6 - Transfer Complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 7 - Error interrupts enable"]
            #[inline ( always )]
            pub fn errie(&mut self) -> _ErrieW {
                _ErrieW { w: self }
            }
            #[doc = "Bits 8:11 - Digital noise filter"]
            #[inline ( always )]
            pub fn dnf(&mut self) -> _DnfW {
                _DnfW { w: self }
            }
            #[doc = "Bit 12 - Analog noise filter OFF"]
            #[inline ( always )]
            pub fn anfoff(&mut self) -> _AnfoffW {
                _AnfoffW { w: self }
            }
            #[doc = "Bit 13 - Software reset"]
            #[inline ( always )]
            pub fn swrst(&mut self) -> _SwrstW {
                _SwrstW { w: self }
            }
            #[doc = "Bit 14 - DMA transmission requests enable"]
            #[inline ( always )]
            pub fn txdmaen(&mut self) -> _TxdmaenW {
                _TxdmaenW { w: self }
            }
            #[doc = "Bit 15 - DMA reception requests enable"]
            #[inline ( always )]
            pub fn rxdmaen(&mut self) -> _RxdmaenW {
                _RxdmaenW { w: self }
            }
            #[doc = "Bit 16 - Slave byte control"]
            #[inline ( always )]
            pub fn sbc(&mut self) -> _SbcW {
                _SbcW { w: self }
            }
            #[doc = "Bit 17 - Clock stretching disable"]
            #[inline ( always )]
            pub fn nostretch(&mut self) -> _NostretchW {
                _NostretchW { w: self }
            }
            #[doc = "Bit 18 - Wakeup from STOP enable"]
            #[inline ( always )]
            pub fn wupen(&mut self) -> _WupenW {
                _WupenW { w: self }
            }
            #[doc = "Bit 19 - General call enable"]
            #[inline ( always )]
            pub fn gcen(&mut self) -> _GcenW {
                _GcenW { w: self }
            }
            #[doc = "Bit 20 - SMBus Host address enable"]
            #[inline ( always )]
            pub fn smbhen(&mut self) -> _SmbhenW {
                _SmbhenW { w: self }
            }
            #[doc = "Bit 21 - SMBus Device Default address enable"]
            #[inline ( always )]
            pub fn smbden(&mut self) -> _SmbdenW {
                _SmbdenW { w: self }
            }
            #[doc = "Bit 22 - SMBUS alert enable"]
            #[inline ( always )]
            pub fn alerten(&mut self) -> _AlertenW {
                _AlertenW { w: self }
            }
            #[doc = "Bit 23 - PEC enable"]
            #[inline ( always )]
            pub fn pecen(&mut self) -> _PecenW {
                _PecenW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PecbyteR {
            bits: u8,
        }
        impl PecbyteR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AutoendR {
            bits: u8,
        }
        impl AutoendR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ReloadR {
            bits: u8,
        }
        impl ReloadR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NbytesR {
            bits: u8,
        }
        impl NbytesR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NackR {
            bits: u8,
        }
        impl NackR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StartR {
            bits: u8,
        }
        impl StartR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Head10rR {
            bits: u8,
        }
        impl Head10rR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Add10R {
            bits: u8,
        }
        impl Add10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RdWrnR {
            bits: u8,
        }
        impl RdWrnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Sadd8R {
            bits: u8,
        }
        impl Sadd8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Sadd1R {
            bits: u8,
        }
        impl Sadd1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Sadd0R {
            bits: u8,
        }
        impl Sadd0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PecbyteW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PecbyteW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AutoendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AutoendW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ReloadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReloadW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NbytesW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NbytesW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NackW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StartW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Head10rW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Head10rW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Add10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RdWrnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RdWrnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Sadd8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sadd8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Sadd1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sadd1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Sadd0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sadd0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 26 - Packet error checking byte"]
            #[inline ( always )]
            pub fn pecbyte(&self) -> PecbyteR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecbyteR { bits }
            }
            #[doc = "Bit 25 - Automatic end mode (master mode)"]
            #[inline ( always )]
            pub fn autoend(&self) -> AutoendR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AutoendR { bits }
            }
            #[doc = "Bit 24 - NBYTES reload mode"]
            #[inline ( always )]
            pub fn reload(&self) -> ReloadR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReloadR { bits }
            }
            #[doc = "Bits 16:23 - Number of bytes"]
            #[inline ( always )]
            pub fn nbytes(&self) -> NbytesR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NbytesR { bits }
            }
            #[doc = "Bit 15 - NACK generation (slave mode)"]
            #[inline ( always )]
            pub fn nack(&self) -> NackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NackR { bits }
            }
            #[doc = "Bit 14 - Stop generation (master mode)"]
            #[inline ( always )]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            #[doc = "Bit 13 - Start generation"]
            #[inline ( always )]
            pub fn start(&self) -> StartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StartR { bits }
            }
            #[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
            #[inline ( always )]
            pub fn head10r(&self) -> Head10rR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Head10rR { bits }
            }
            #[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
            #[inline ( always )]
            pub fn add10(&self) -> Add10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add10R { bits }
            }
            #[doc = "Bit 10 - Transfer direction (master mode)"]
            #[inline ( always )]
            pub fn rd_wrn(&self) -> RdWrnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RdWrnR { bits }
            }
            #[doc = "Bits 8:9 - Slave address bit 9:8 (master mode)"]
            #[inline ( always )]
            pub fn sadd8(&self) -> Sadd8R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sadd8R { bits }
            }
            #[doc = "Bits 1:7 - Slave address bit 7:1 (master mode)"]
            #[inline ( always )]
            pub fn sadd1(&self) -> Sadd1R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sadd1R { bits }
            }
            #[doc = "Bit 0 - Slave address bit 0 (master mode)"]
            #[inline ( always )]
            pub fn sadd0(&self) -> Sadd0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Sadd0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 26 - Packet error checking byte"]
            #[inline ( always )]
            pub fn pecbyte(&mut self) -> _PecbyteW {
                _PecbyteW { w: self }
            }
            #[doc = "Bit 25 - Automatic end mode (master mode)"]
            #[inline ( always )]
            pub fn autoend(&mut self) -> _AutoendW {
                _AutoendW { w: self }
            }
            #[doc = "Bit 24 - NBYTES reload mode"]
            #[inline ( always )]
            pub fn reload(&mut self) -> _ReloadW {
                _ReloadW { w: self }
            }
            #[doc = "Bits 16:23 - Number of bytes"]
            #[inline ( always )]
            pub fn nbytes(&mut self) -> _NbytesW {
                _NbytesW { w: self }
            }
            #[doc = "Bit 15 - NACK generation (slave mode)"]
            #[inline ( always )]
            pub fn nack(&mut self) -> _NackW {
                _NackW { w: self }
            }
            #[doc = "Bit 14 - Stop generation (master mode)"]
            #[inline ( always )]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            #[doc = "Bit 13 - Start generation"]
            #[inline ( always )]
            pub fn start(&mut self) -> _StartW {
                _StartW { w: self }
            }
            #[doc = "Bit 12 - 10-bit address header only read direction (master receiver mode)"]
            #[inline ( always )]
            pub fn head10r(&mut self) -> _Head10rW {
                _Head10rW { w: self }
            }
            #[doc = "Bit 11 - 10-bit addressing mode (master mode)"]
            #[inline ( always )]
            pub fn add10(&mut self) -> _Add10W {
                _Add10W { w: self }
            }
            #[doc = "Bit 10 - Transfer direction (master mode)"]
            #[inline ( always )]
            pub fn rd_wrn(&mut self) -> _RdWrnW {
                _RdWrnW { w: self }
            }
            #[doc = "Bits 8:9 - Slave address bit 9:8 (master mode)"]
            #[inline ( always )]
            pub fn sadd8(&mut self) -> _Sadd8W {
                _Sadd8W { w: self }
            }
            #[doc = "Bits 1:7 - Slave address bit 7:1 (master mode)"]
            #[inline ( always )]
            pub fn sadd1(&mut self) -> _Sadd1W {
                _Sadd1W { w: self }
            }
            #[doc = "Bit 0 - Slave address bit 0 (master mode)"]
            #[inline ( always )]
            pub fn sadd0(&mut self) -> _Sadd0W {
                _Sadd0W { w: self }
            }
        }
    }
    #[doc = "Own address register 1"]
    pub struct Oar1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Own address register 1"]
    pub mod oar1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Oar1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa10R {
            bits: u8,
        }
        impl Oa10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa11R {
            bits: u8,
        }
        impl Oa11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa18R {
            bits: u8,
        }
        impl Oa18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa1modeR {
            bits: u8,
        }
        impl Oa1modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `OA1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Oa1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Oa1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Oa1enR::Disabled => 0,
                    Oa1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Oa1enR {
                match bits {
                    0 => Oa1enR::Disabled,
                    1 => Oa1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Oa1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Oa1enR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa18W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa1modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa1modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OA1EN`"]
        pub enum Oa1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Oa1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Oa1enW::Disabled => 0,
                    Oa1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Oa1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Oa1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Oa1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interface address"]
            #[inline ( always )]
            pub fn oa1_0(&self) -> Oa10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa10R { bits }
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline ( always )]
            pub fn oa1_1(&self) -> Oa11R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa11R { bits }
            }
            #[doc = "Bits 8:9 - Interface address"]
            #[inline ( always )]
            pub fn oa1_8(&self) -> Oa18R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa18R { bits }
            }
            #[doc = "Bit 10 - Own Address 1 10-bit mode"]
            #[inline ( always )]
            pub fn oa1mode(&self) -> Oa1modeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa1modeR { bits }
            }
            #[doc = "Bit 15 - Own Address 1 enable"]
            #[inline ( always )]
            pub fn oa1en(&self) -> Oa1enR {
                Oa1enR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 15;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interface address"]
            #[inline ( always )]
            pub fn oa1_0(&mut self) -> _Oa10W {
                _Oa10W { w: self }
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline ( always )]
            pub fn oa1_1(&mut self) -> _Oa11W {
                _Oa11W { w: self }
            }
            #[doc = "Bits 8:9 - Interface address"]
            #[inline ( always )]
            pub fn oa1_8(&mut self) -> _Oa18W {
                _Oa18W { w: self }
            }
            #[doc = "Bit 10 - Own Address 1 10-bit mode"]
            #[inline ( always )]
            pub fn oa1mode(&mut self) -> _Oa1modeW {
                _Oa1modeW { w: self }
            }
            #[doc = "Bit 15 - Own Address 1 enable"]
            #[inline ( always )]
            pub fn oa1en(&mut self) -> _Oa1enW {
                _Oa1enW { w: self }
            }
        }
    }
    #[doc = "Own address register 2"]
    pub struct Oar2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Own address register 2"]
    pub mod oar2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Oar2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa2R {
            bits: u8,
        }
        impl Oa2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oa2mskR {
            bits: u8,
        }
        impl Oa2mskR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `OA2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Oa2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Oa2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Oa2enR::Disabled => 0,
                    Oa2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Oa2enR {
                match bits {
                    0 => Oa2enR::Disabled,
                    1 => Oa2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Oa2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Oa2enR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa2mskW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa2mskW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OA2EN`"]
        pub enum Oa2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Oa2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Oa2enW::Disabled => 0,
                    Oa2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oa2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oa2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Oa2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Oa2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Oa2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline ( always )]
            pub fn oa2(&self) -> Oa2R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa2R { bits }
            }
            #[doc = "Bits 8:10 - Own Address 2 masks"]
            #[inline ( always )]
            pub fn oa2msk(&self) -> Oa2mskR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oa2mskR { bits }
            }
            #[doc = "Bit 15 - Own Address 2 enable"]
            #[inline ( always )]
            pub fn oa2en(&self) -> Oa2enR {
                Oa2enR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 15;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:7 - Interface address"]
            #[inline ( always )]
            pub fn oa2(&mut self) -> _Oa2W {
                _Oa2W { w: self }
            }
            #[doc = "Bits 8:10 - Own Address 2 masks"]
            #[inline ( always )]
            pub fn oa2msk(&mut self) -> _Oa2mskW {
                _Oa2mskW { w: self }
            }
            #[doc = "Bit 15 - Own Address 2 enable"]
            #[inline ( always )]
            pub fn oa2en(&mut self) -> _Oa2enW {
                _Oa2enW { w: self }
            }
        }
    }
    #[doc = "Timing register"]
    pub struct Timingr {
        register: VolatileCell<u32>,
    }
    #[doc = "Timing register"]
    pub mod timingr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Timingr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ScllR {
            bits: u8,
        }
        impl ScllR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SclhR {
            bits: u8,
        }
        impl SclhR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SdadelR {
            bits: u8,
        }
        impl SdadelR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ScldelR {
            bits: u8,
        }
        impl ScldelR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PrescR {
            bits: u8,
        }
        impl PrescR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ScllW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScllW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SclhW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SclhW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SdadelW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SdadelW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ScldelW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScldelW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PrescW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrescW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SCL low period (master mode)"]
            #[inline ( always )]
            pub fn scll(&self) -> ScllR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScllR { bits }
            }
            #[doc = "Bits 8:15 - SCL high period (master mode)"]
            #[inline ( always )]
            pub fn sclh(&self) -> SclhR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SclhR { bits }
            }
            #[doc = "Bits 16:19 - Data hold time"]
            #[inline ( always )]
            pub fn sdadel(&self) -> SdadelR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SdadelR { bits }
            }
            #[doc = "Bits 20:23 - Data setup time"]
            #[inline ( always )]
            pub fn scldel(&self) -> ScldelR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScldelR { bits }
            }
            #[doc = "Bits 28:31 - Timing prescaler"]
            #[inline ( always )]
            pub fn presc(&self) -> PrescR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrescR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SCL low period (master mode)"]
            #[inline ( always )]
            pub fn scll(&mut self) -> _ScllW {
                _ScllW { w: self }
            }
            #[doc = "Bits 8:15 - SCL high period (master mode)"]
            #[inline ( always )]
            pub fn sclh(&mut self) -> _SclhW {
                _SclhW { w: self }
            }
            #[doc = "Bits 16:19 - Data hold time"]
            #[inline ( always )]
            pub fn sdadel(&mut self) -> _SdadelW {
                _SdadelW { w: self }
            }
            #[doc = "Bits 20:23 - Data setup time"]
            #[inline ( always )]
            pub fn scldel(&mut self) -> _ScldelW {
                _ScldelW { w: self }
            }
            #[doc = "Bits 28:31 - Timing prescaler"]
            #[inline ( always )]
            pub fn presc(&mut self) -> _PrescW {
                _PrescW { w: self }
            }
        }
    }
    #[doc = "Status register 1"]
    pub struct Timeoutr {
        register: VolatileCell<u32>,
    }
    #[doc = "Status register 1"]
    pub mod timeoutr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Timeoutr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TimeoutaR {
            bits: u16,
        }
        impl TimeoutaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TidleR {
            bits: u8,
        }
        impl TidleR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TIMOUTEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TimoutenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TimoutenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TimoutenR::Disabled => 0,
                    TimoutenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TimoutenR {
                match bits {
                    0 => TimoutenR::Disabled,
                    1 => TimoutenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TimoutenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TimoutenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct TimeoutbR {
            bits: u16,
        }
        impl TimeoutbR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TEXTEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TextenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TextenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TextenR::Disabled => 0,
                    TextenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TextenR {
                match bits {
                    0 => TextenR::Disabled,
                    1 => TextenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TextenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TextenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _TimeoutaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimeoutaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TidleW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TidleW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIMOUTEN`"]
        pub enum TimoutenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TimoutenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TimoutenW::Disabled => 0,
                    TimoutenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TimoutenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimoutenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TimoutenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TimoutenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TimoutenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TimeoutbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimeoutbW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TEXTEN`"]
        pub enum TextenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TextenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TextenW::Disabled => 0,
                    TextenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TextenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TextenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TextenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TextenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TextenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Bus timeout A"]
            #[inline ( always )]
            pub fn timeouta(&self) -> TimeoutaR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TimeoutaR { bits }
            }
            #[doc = "Bit 12 - Idle clock timeout detection"]
            #[inline ( always )]
            pub fn tidle(&self) -> TidleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TidleR { bits }
            }
            #[doc = "Bit 15 - Clock timeout enable"]
            #[inline ( always )]
            pub fn timouten(&self) -> TimoutenR {
                TimoutenR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 15;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bits 16:27 - Bus timeout B"]
            #[inline ( always )]
            pub fn timeoutb(&self) -> TimeoutbR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TimeoutbR { bits }
            }
            #[doc = "Bit 31 - Extended clock timeout enable"]
            #[inline ( always )]
            pub fn texten(&self) -> TextenR {
                TextenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 31;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Bus timeout A"]
            #[inline ( always )]
            pub fn timeouta(&mut self) -> _TimeoutaW {
                _TimeoutaW { w: self }
            }
            #[doc = "Bit 12 - Idle clock timeout detection"]
            #[inline ( always )]
            pub fn tidle(&mut self) -> _TidleW {
                _TidleW { w: self }
            }
            #[doc = "Bit 15 - Clock timeout enable"]
            #[inline ( always )]
            pub fn timouten(&mut self) -> _TimoutenW {
                _TimoutenW { w: self }
            }
            #[doc = "Bits 16:27 - Bus timeout B"]
            #[inline ( always )]
            pub fn timeoutb(&mut self) -> _TimeoutbW {
                _TimeoutbW { w: self }
            }
            #[doc = "Bit 31 - Extended clock timeout enable"]
            #[inline ( always )]
            pub fn texten(&mut self) -> _TextenW {
                _TextenW { w: self }
            }
        }
    }
    #[doc = "Interrupt and Status register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt and Status register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AddcodeR {
            bits: u8,
        }
        impl AddcodeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BusyR {
            bits: u8,
        }
        impl BusyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlertR {
            bits: u8,
        }
        impl AlertR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TimeoutR {
            bits: u8,
        }
        impl TimeoutR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PecerrR {
            bits: u8,
        }
        impl PecerrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrR {
            bits: u8,
        }
        impl OvrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArloR {
            bits: u8,
        }
        impl ArloR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BerrR {
            bits: u8,
        }
        impl BerrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcrR {
            bits: u8,
        }
        impl TcrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcR {
            bits: u8,
        }
        impl TcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StopfR {
            bits: u8,
        }
        impl StopfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NackfR {
            bits: u8,
        }
        impl NackfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AddrR {
            bits: u8,
        }
        impl AddrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxisR {
            bits: u8,
        }
        impl TxisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 17:23 - Address match code (Slave mode)"]
            #[inline ( always )]
            pub fn addcode(&self) -> AddcodeR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddcodeR { bits }
            }
            #[doc = "Bit 16 - Transfer direction (Slave mode)"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 15 - Bus busy"]
            #[inline ( always )]
            pub fn busy(&self) -> BusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusyR { bits }
            }
            #[doc = "Bit 13 - SMBus alert"]
            #[inline ( always )]
            pub fn alert(&self) -> AlertR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlertR { bits }
            }
            #[doc = "Bit 12 - Timeout or t_low detection flag"]
            #[inline ( always )]
            pub fn timeout(&self) -> TimeoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TimeoutR { bits }
            }
            #[doc = "Bit 11 - PEC Error in reception"]
            #[inline ( always )]
            pub fn pecerr(&self) -> PecerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecerrR { bits }
            }
            #[doc = "Bit 10 - Overrun/Underrun (slave mode)"]
            #[inline ( always )]
            pub fn ovr(&self) -> OvrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrR { bits }
            }
            #[doc = "Bit 9 - Arbitration lost"]
            #[inline ( always )]
            pub fn arlo(&self) -> ArloR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArloR { bits }
            }
            #[doc = "Bit 8 - Bus error"]
            #[inline ( always )]
            pub fn berr(&self) -> BerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BerrR { bits }
            }
            #[doc = "Bit 7 - Transfer Complete Reload"]
            #[inline ( always )]
            pub fn tcr(&self) -> TcrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcrR { bits }
            }
            #[doc = "Bit 6 - Transfer Complete (master mode)"]
            #[inline ( always )]
            pub fn tc(&self) -> TcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcR { bits }
            }
            #[doc = "Bit 5 - Stop detection flag"]
            #[inline ( always )]
            pub fn stopf(&self) -> StopfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopfR { bits }
            }
            #[doc = "Bit 4 - Not acknowledge received flag"]
            #[inline ( always )]
            pub fn nackf(&self) -> NackfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NackfR { bits }
            }
            #[doc = "Bit 3 - Address matched (slave mode)"]
            #[inline ( always )]
            pub fn addr(&self) -> AddrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddrR { bits }
            }
            #[doc = "Bit 2 - Receive data register not empty (receivers)"]
            #[inline ( always )]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            #[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
            #[inline ( always )]
            pub fn txis(&self) -> TxisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxisR { bits }
            }
            #[doc = "Bit 0 - Transmit data register empty (transmitters)"]
            #[inline ( always )]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Transmit interrupt status (transmitters)"]
            #[inline ( always )]
            pub fn txis(&mut self) -> _TxisW {
                _TxisW { w: self }
            }
            #[doc = "Bit 0 - Transmit data register empty (transmitters)"]
            #[inline ( always )]
            pub fn txe(&mut self) -> _TxeW {
                _TxeW { w: self }
            }
        }
    }
    #[doc = "Interrupt clear register"]
    pub struct Icr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt clear register"]
    pub mod icr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Icr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlertcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlertcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TimoutcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TimoutcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PeccfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeccfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OvrcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArlocfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArlocfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BerrcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BerrcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StopcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NackcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NackcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AddrcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddrcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - Alert flag clear"]
            #[inline ( always )]
            pub fn alertcf(&mut self) -> _AlertcfW {
                _AlertcfW { w: self }
            }
            #[doc = "Bit 12 - Timeout detection flag clear"]
            #[inline ( always )]
            pub fn timoutcf(&mut self) -> _TimoutcfW {
                _TimoutcfW { w: self }
            }
            #[doc = "Bit 11 - PEC Error flag clear"]
            #[inline ( always )]
            pub fn peccf(&mut self) -> _PeccfW {
                _PeccfW { w: self }
            }
            #[doc = "Bit 10 - Overrun/Underrun flag clear"]
            #[inline ( always )]
            pub fn ovrcf(&mut self) -> _OvrcfW {
                _OvrcfW { w: self }
            }
            #[doc = "Bit 9 - Arbitration lost flag clear"]
            #[inline ( always )]
            pub fn arlocf(&mut self) -> _ArlocfW {
                _ArlocfW { w: self }
            }
            #[doc = "Bit 8 - Bus error flag clear"]
            #[inline ( always )]
            pub fn berrcf(&mut self) -> _BerrcfW {
                _BerrcfW { w: self }
            }
            #[doc = "Bit 5 - Stop detection flag clear"]
            #[inline ( always )]
            pub fn stopcf(&mut self) -> _StopcfW {
                _StopcfW { w: self }
            }
            #[doc = "Bit 4 - Not Acknowledge flag clear"]
            #[inline ( always )]
            pub fn nackcf(&mut self) -> _NackcfW {
                _NackcfW { w: self }
            }
            #[doc = "Bit 3 - Address Matched flag clear"]
            #[inline ( always )]
            pub fn addrcf(&mut self) -> _AddrcfW {
                _AddrcfW { w: self }
            }
        }
    }
    #[doc = "PEC register"]
    pub struct Pecr {
        register: VolatileCell<u32>,
    }
    #[doc = "PEC register"]
    pub mod pecr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Pecr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PecR {
            bits: u8,
        }
        impl PecR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Packet error checking register"]
            #[inline ( always )]
            pub fn pec(&self) -> PecR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecR { bits }
            }
        }
    }
    #[doc = "Receive data register"]
    pub struct Rxdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Receive data register"]
    pub mod rxdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Rxdr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxdataR {
            bits: u8,
        }
        impl RxdataR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit receive data"]
            #[inline ( always )]
            pub fn rxdata(&self) -> RxdataR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdataR { bits }
            }
        }
    }
    #[doc = "Transmit data register"]
    pub struct Txdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Transmit data register"]
    pub mod txdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Txdr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxdataR {
            bits: u8,
        }
        impl TxdataR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxdataW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdataW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit transmit data"]
            #[inline ( always )]
            pub fn txdata(&self) -> TxdataR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxdataR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - 8-bit transmit data"]
            #[inline ( always )]
            pub fn txdata(&mut self) -> _TxdataW {
                _TxdataW { w: self }
            }
        }
    }
}
#[doc = "Inter-integrated circuit"]
pub struct I2c1 {
    register_block: i2c1::RegisterBlock,
}
impl Deref for I2c1 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "I2C2"]
pub const I2C2: Peripheral<I2c2> = unsafe { Peripheral::new(1073764352) };
#[doc = r" Register block"]
pub struct I2c2 {
    register_block: i2c1::RegisterBlock,
}
impl Deref for I2c2 {
    type Target = i2c1::RegisterBlock;
    fn deref(&self) -> &i2c1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Independent watchdog"]
pub const IWDG: Peripheral<Iwdg> = unsafe { Peripheral::new(1073754112) };
#[doc = "Independent watchdog"]
pub mod iwdg {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Key register"]
        pub kr: Kr,
        #[doc = "0x04 - Prescaler register"]
        pub pr: Pr,
        #[doc = "0x08 - Reload register"]
        pub rlr: Rlr,
        #[doc = "0x0c - Status register"]
        pub sr: Sr,
        #[doc = "0x10 - Window register"]
        pub winr: Winr,
    }
    #[doc = "Key register"]
    pub struct Kr {
        register: VolatileCell<u32>,
    }
    #[doc = "Key register"]
    pub mod kr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Kr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _KeyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KeyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Key value"]
            #[inline ( always )]
            pub fn key(&mut self) -> _KeyW {
                _KeyW { w: self }
            }
        }
    }
    #[doc = "Prescaler register"]
    pub struct Pr {
        register: VolatileCell<u32>,
    }
    #[doc = "Prescaler register"]
    pub mod pr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Pr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PrR {
            bits: u8,
        }
        impl PrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline ( always )]
            pub fn pr(&self) -> PrR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Prescaler divider"]
            #[inline ( always )]
            pub fn pr(&mut self) -> _PrW {
                _PrW { w: self }
            }
        }
    }
    #[doc = "Reload register"]
    pub struct Rlr {
        register: VolatileCell<u32>,
    }
    #[doc = "Reload register"]
    pub mod rlr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rlr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RlR {
            bits: u16,
        }
        impl RlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline ( always )]
            pub fn rl(&self) -> RlR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RlR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4095 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Watchdog counter reload value"]
            #[inline ( always )]
            pub fn rl(&mut self) -> _RlW {
                _RlW { w: self }
            }
        }
    }
    #[doc = "Status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PvuR {
            bits: u8,
        }
        impl PvuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RvuR {
            bits: u8,
        }
        impl RvuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WvuR {
            bits: u8,
        }
        impl WvuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog prescaler value update"]
            #[inline ( always )]
            pub fn pvu(&self) -> PvuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvuR { bits }
            }
            #[doc = "Bit 1 - Watchdog counter reload value update"]
            #[inline ( always )]
            pub fn rvu(&self) -> RvuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RvuR { bits }
            }
            #[doc = "Bit 2 - Watchdog counter window value update"]
            #[inline ( always )]
            pub fn wvu(&self) -> WvuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WvuR { bits }
            }
        }
    }
    #[doc = "Window register"]
    pub struct Winr {
        register: VolatileCell<u32>,
    }
    #[doc = "Window register"]
    pub mod winr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Winr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct WinR {
            bits: u16,
        }
        impl WinR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WinW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WinW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Watchdog counter window value"]
            #[inline ( always )]
            pub fn win(&self) -> WinR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                WinR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4095 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - Watchdog counter window value"]
            #[inline ( always )]
            pub fn win(&mut self) -> _WinW {
                _WinW { w: self }
            }
        }
    }
}
#[doc = "Independent watchdog"]
pub struct Iwdg {
    register_block: iwdg::RegisterBlock,
}
impl Deref for Iwdg {
    type Target = iwdg::RegisterBlock;
    fn deref(&self) -> &iwdg::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Window watchdog"]
pub const WWDG: Peripheral<Wwdg> = unsafe { Peripheral::new(1073753088) };
#[doc = "Window watchdog"]
pub mod wwdg {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register"]
        pub cr: Cr,
        #[doc = "0x04 - Configuration register"]
        pub cfr: Cfr,
        #[doc = "0x08 - Status register"]
        pub sr: Sr,
    }
    #[doc = "Control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct WdgaR {
            bits: u8,
        }
        impl WdgaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TR {
            bits: u8,
        }
        impl TR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WdgaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdgaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline ( always )]
            pub fn wdga(&self) -> WdgaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgaR { bits }
            }
            #[doc = "Bits 0:6 - 7-bit counter"]
            #[inline ( always )]
            pub fn t(&self) -> TR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Activation bit"]
            #[inline ( always )]
            pub fn wdga(&mut self) -> _WdgaW {
                _WdgaW { w: self }
            }
            #[doc = "Bits 0:6 - 7-bit counter"]
            #[inline ( always )]
            pub fn t(&mut self) -> _TW {
                _TW { w: self }
            }
        }
    }
    #[doc = "Configuration register"]
    pub struct Cfr {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register"]
    pub mod cfr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EwiR {
            bits: u8,
        }
        impl EwiR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WdgtbR {
            bits: u8,
        }
        impl WdgtbR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WR {
            bits: u8,
        }
        impl WR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EwiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwiW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WdgtbW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdgtbW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Early wakeup interrupt"]
            #[inline ( always )]
            pub fn ewi(&self) -> EwiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwiR { bits }
            }
            #[doc = "Bits 7:8 - Timer base"]
            #[inline ( always )]
            pub fn wdgtb(&self) -> WdgtbR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgtbR { bits }
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline ( always )]
            pub fn w(&self) -> WR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 127 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Early wakeup interrupt"]
            #[inline ( always )]
            pub fn ewi(&mut self) -> _EwiW {
                _EwiW { w: self }
            }
            #[doc = "Bits 7:8 - Timer base"]
            #[inline ( always )]
            pub fn wdgtb(&mut self) -> _WdgtbW {
                _WdgtbW { w: self }
            }
            #[doc = "Bits 0:6 - 7-bit window value"]
            #[inline ( always )]
            pub fn w(&mut self) -> _WW {
                _WW { w: self }
            }
        }
    }
    #[doc = "Status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "Status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EwifR {
            bits: u8,
        }
        impl EwifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EwifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EwifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Early wakeup interrupt flag"]
            #[inline ( always )]
            pub fn ewif(&self) -> EwifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EwifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Early wakeup interrupt flag"]
            #[inline ( always )]
            pub fn ewif(&mut self) -> _EwifW {
                _EwifW { w: self }
            }
        }
    }
}
#[doc = "Window watchdog"]
pub struct Wwdg {
    register_block: wwdg::RegisterBlock,
}
impl Deref for Wwdg {
    type Target = wwdg::RegisterBlock;
    fn deref(&self) -> &wwdg::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Advanced-timers"]
pub const TIM1: Peripheral<Tim1> = unsafe { Peripheral::new(1073818624) };
#[doc = "Advanced-timers"]
pub mod tim1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: Smcr,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: Ccmr1Output,
        #[doc = "0x1c - capture/compare mode register (output mode)"]
        pub ccmr2_output: Ccmr2Output,
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: Ccer,
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: Rcr,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: Ccr1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: Ccr2,
        #[doc = "0x3c - capture/compare register 3"]
        pub ccr3: Ccr3,
        #[doc = "0x40 - capture/compare register 4"]
        pub ccr4: Ccr4,
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: Bdtr,
        #[doc = "0x48 - DMA control register"]
        pub dcr: Dcr,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: Dmar,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CmsR {
            bits: u8,
        }
        impl CmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline ( always )]
            pub fn cms(&self) -> CmsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmsR { bits }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline ( always )]
            pub fn cms(&mut self) -> _CmsW {
                _CmsW { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois4R {
            bits: u8,
        }
        impl Ois4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois3nR {
            bits: u8,
        }
        impl Ois3nR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois3R {
            bits: u8,
        }
        impl Ois3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois2nR {
            bits: u8,
        }
        impl Ois2nR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois2R {
            bits: u8,
        }
        impl Ois2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ti1sR {
            bits: u8,
        }
        impl Ti1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois3nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois3nW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois2nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2nW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ti1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ti1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline ( always )]
            pub fn ois4(&self) -> Ois4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois4R { bits }
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline ( always )]
            pub fn ois3n(&self) -> Ois3nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois3nR { bits }
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline ( always )]
            pub fn ois3(&self) -> Ois3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois3R { bits }
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2n(&self) -> Ois2nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2nR { bits }
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2(&self) -> Ois2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2R { bits }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline ( always )]
            pub fn ti1s(&self) -> Ti1sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ti1sR { bits }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Output Idle state 4"]
            #[inline ( always )]
            pub fn ois4(&mut self) -> _Ois4W {
                _Ois4W { w: self }
            }
            #[doc = "Bit 13 - Output Idle state 3"]
            #[inline ( always )]
            pub fn ois3n(&mut self) -> _Ois3nW {
                _Ois3nW { w: self }
            }
            #[doc = "Bit 12 - Output Idle state 3"]
            #[inline ( always )]
            pub fn ois3(&mut self) -> _Ois3W {
                _Ois3W { w: self }
            }
            #[doc = "Bit 11 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2n(&mut self) -> _Ois2nW {
                _Ois2nW { w: self }
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2(&mut self) -> _Ois2W {
                _Ois2W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline ( always )]
            pub fn ti1s(&mut self) -> _Ti1sW {
                _Ti1sW { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtpR {
            bits: u8,
        }
        impl EtpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EceR {
            bits: u8,
        }
        impl EceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtpsR {
            bits: u8,
        }
        impl EtpsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtfR {
            bits: u8,
        }
        impl EtfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtpsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline ( always )]
            pub fn etp(&self) -> EtpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpR { bits }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline ( always )]
            pub fn ece(&self) -> EceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EceR { bits }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline ( always )]
            pub fn etps(&self) -> EtpsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpsR { bits }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline ( always )]
            pub fn etf(&self) -> EtfR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtfR { bits }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline ( always )]
            pub fn etp(&mut self) -> _EtpW {
                _EtpW { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline ( always )]
            pub fn ece(&mut self) -> _EceW {
                _EceW { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline ( always )]
            pub fn etps(&mut self) -> _EtpsW {
                _EtpsW { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline ( always )]
            pub fn etf(&mut self) -> _EtfW {
                _EtfW { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComdeR {
            bits: u8,
        }
        impl ComdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4deR {
            bits: u8,
        }
        impl Cc4deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3deR {
            bits: u8,
        }
        impl Cc3deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ieR {
            bits: u8,
        }
        impl Cc4ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ieR {
            bits: u8,
        }
        impl Cc3ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn comde(&self) -> ComdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComdeR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline ( always )]
            pub fn cc4de(&self) -> Cc4deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4deR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline ( always )]
            pub fn cc3de(&self) -> Cc3deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3deR { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline ( always )]
            pub fn cc4ie(&self) -> Cc4ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ieR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline ( always )]
            pub fn cc3ie(&self) -> Cc3ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ieR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn comde(&mut self) -> _ComdeW {
                _ComdeW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline ( always )]
            pub fn cc4de(&mut self) -> _Cc4deW {
                _Cc4deW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline ( always )]
            pub fn cc3de(&mut self) -> _Cc3deW {
                _Cc3deW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline ( always )]
            pub fn cc4ie(&mut self) -> _Cc4ieW {
                _Cc4ieW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline ( always )]
            pub fn cc3ie(&mut self) -> _Cc3ieW {
                _Cc3ieW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ofR {
            bits: u8,
        }
        impl Cc4ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ofR {
            bits: u8,
        }
        impl Cc3ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ifR {
            bits: u8,
        }
        impl Cc4ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ifR {
            bits: u8,
        }
        impl Cc3ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline ( always )]
            pub fn cc4of(&self) -> Cc4ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ofR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline ( always )]
            pub fn cc3of(&self) -> Cc3ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ofR { bits }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline ( always )]
            pub fn cc4if(&self) -> Cc4ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ifR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline ( always )]
            pub fn cc3if(&self) -> Cc3ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ifR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline ( always )]
            pub fn cc4of(&mut self) -> _Cc4ofW {
                _Cc4ofW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline ( always )]
            pub fn cc3of(&mut self) -> _Cc3ofW {
                _Cc3ofW { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline ( always )]
            pub fn cc4if(&mut self) -> _Cc4ifW {
                _Cc4ifW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline ( always )]
            pub fn cc3if(&mut self) -> _Cc3ifW {
                _Cc3ifW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline ( always )]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline ( always )]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline ( always )]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline ( always )]
            pub fn cc4g(&mut self) -> _Cc4gW {
                _Cc4gW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline ( always )]
            pub fn cc3g(&mut self) -> _Cc3gW {
                _Cc3gW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline ( always )]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline ( always )]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2ceR {
            bits: u8,
        }
        impl Oc2ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1ceR {
            bits: u8,
        }
        impl Oc1ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline ( always )]
            pub fn oc2ce(&self) -> Oc2ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2ceR { bits }
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline ( always )]
            pub fn oc1ce(&self) -> Oc1ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1ceR { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output Compare 2 clear enable"]
            #[inline ( always )]
            pub fn oc2ce(&mut self) -> _Oc2ceW {
                _Oc2ceW { w: self }
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bit 7 - Output Compare 1 clear enable"]
            #[inline ( always )]
            pub fn oc1ce(&mut self) -> _Oc1ceW {
                _Oc1ceW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2pcsR {
            bits: u8,
        }
        impl Ic2pcsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1pcsR {
            bits: u8,
        }
        impl Ic1pcsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2pcsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pcsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1pcsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pcsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2pcs(&self) -> Ic2pcsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pcsR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1pcs(&self) -> Ic1pcsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pcsR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2pcs(&mut self) -> _Ic2pcsW {
                _Ic2pcsW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1pcs(&mut self) -> _Ic1pcsW {
                _Ic1pcsW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct Ccmr2Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr2_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4ceR {
            bits: u8,
        }
        impl Oc4ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4mR {
            bits: u8,
        }
        impl Oc4mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4peR {
            bits: u8,
        }
        impl Oc4peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4feR {
            bits: u8,
        }
        impl Oc4feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3ceR {
            bits: u8,
        }
        impl Oc3ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3mR {
            bits: u8,
        }
        impl Oc3mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3peR {
            bits: u8,
        }
        impl Oc3peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3feR {
            bits: u8,
        }
        impl Oc3feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline ( always )]
            pub fn oc4ce(&self) -> Oc4ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4ceR { bits }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline ( always )]
            pub fn oc4m(&self) -> Oc4mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4mR { bits }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline ( always )]
            pub fn oc4pe(&self) -> Oc4peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4peR { bits }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline ( always )]
            pub fn oc4fe(&self) -> Oc4feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4feR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline ( always )]
            pub fn oc3ce(&self) -> Oc3ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3ceR { bits }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline ( always )]
            pub fn oc3m(&self) -> Oc3mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3mR { bits }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline ( always )]
            pub fn oc3pe(&self) -> Oc3peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3peR { bits }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline ( always )]
            pub fn oc3fe(&self) -> Oc3feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline ( always )]
            pub fn oc4ce(&mut self) -> _Oc4ceW {
                _Oc4ceW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline ( always )]
            pub fn oc4m(&mut self) -> _Oc4mW {
                _Oc4mW { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline ( always )]
            pub fn oc4pe(&mut self) -> _Oc4peW {
                _Oc4peW { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline ( always )]
            pub fn oc4fe(&mut self) -> _Oc4feW {
                _Oc4feW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline ( always )]
            pub fn oc3ce(&mut self) -> _Oc3ceW {
                _Oc3ceW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline ( always )]
            pub fn oc3m(&mut self) -> _Oc3mW {
                _Oc3mW { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline ( always )]
            pub fn oc3pe(&mut self) -> _Oc3peW {
                _Oc3peW { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline ( always )]
            pub fn oc3fe(&mut self) -> _Oc3feW {
                _Oc3feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub struct Ccmr2Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic4fR {
            bits: u8,
        }
        impl Ic4fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic4pscR {
            bits: u8,
        }
        impl Ic4pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic3fR {
            bits: u8,
        }
        impl Ic3fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic3pscR {
            bits: u8,
        }
        impl Ic3pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic4fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic4pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic3fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic3pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline ( always )]
            pub fn ic4f(&self) -> Ic4fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4fR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline ( always )]
            pub fn ic4psc(&self) -> Ic4pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4pscR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline ( always )]
            pub fn ic3f(&self) -> Ic3fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline ( always )]
            pub fn ic3psc(&self) -> Ic3pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline ( always )]
            pub fn ic4f(&mut self) -> _Ic4fW {
                _Ic4fW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline ( always )]
            pub fn ic4psc(&mut self) -> _Ic4pscW {
                _Ic4pscW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline ( always )]
            pub fn ic3f(&mut self) -> _Ic3fW {
                _Ic3fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline ( always )]
            pub fn ic3psc(&mut self) -> _Ic3pscW {
                _Ic3pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4pR {
            bits: u8,
        }
        impl Cc4pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4eR {
            bits: u8,
        }
        impl Cc4eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3npR {
            bits: u8,
        }
        impl Cc3npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3neR {
            bits: u8,
        }
        impl Cc3neR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3pR {
            bits: u8,
        }
        impl Cc3pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3eR {
            bits: u8,
        }
        impl Cc3eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2neR {
            bits: u8,
        }
        impl Cc2neR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3neW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2neW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc4p(&self) -> Cc4pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4pR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline ( always )]
            pub fn cc4e(&self) -> Cc4eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4eR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3np(&self) -> Cc3npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3npR { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline ( always )]
            pub fn cc3ne(&self) -> Cc3neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3neR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3p(&self) -> Cc3pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3pR { bits }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline ( always )]
            pub fn cc3e(&self) -> Cc3eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3eR { bits }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline ( always )]
            pub fn cc2ne(&self) -> Cc2neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2neR { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc4p(&mut self) -> _Cc4pW {
                _Cc4pW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline ( always )]
            pub fn cc4e(&mut self) -> _Cc4eW {
                _Cc4eW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3np(&mut self) -> _Cc3npW {
                _Cc3npW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
            #[inline ( always )]
            pub fn cc3ne(&mut self) -> _Cc3neW {
                _Cc3neW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3p(&mut self) -> _Cc3pW {
                _Cc3pW { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline ( always )]
            pub fn cc3e(&mut self) -> _Cc3eW {
                _Cc3eW { w: self }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            #[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
            #[inline ( always )]
            pub fn cc2ne(&mut self) -> _Cc2neW {
                _Cc2neW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 3"]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 3"]
    pub mod ccr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr3R {
            bits: u16,
        }
        impl Ccr3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 3 value"]
            #[inline ( always )]
            pub fn ccr3(&self) -> Ccr3R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 3 value"]
            #[inline ( always )]
            pub fn ccr3(&mut self) -> _Ccr3W {
                _Ccr3W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 4"]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 4"]
    pub mod ccr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr4R {
            bits: u16,
        }
        impl Ccr4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 3 value"]
            #[inline ( always )]
            pub fn ccr4(&self) -> Ccr4R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 3 value"]
            #[inline ( always )]
            pub fn ccr4(&mut self) -> _Ccr4W {
                _Ccr4W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
#[doc = "Advanced-timers"]
pub struct Tim1 {
    register_block: tim1::RegisterBlock,
}
impl Deref for Tim1 {
    type Target = tim1::RegisterBlock;
    fn deref(&self) -> &tim1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose-timers"]
pub const TIM2: Peripheral<Tim2> = unsafe { Peripheral::new(1073741824) };
#[doc = "General-purpose-timers"]
pub mod tim2 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: Smcr,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        #[doc = "0x18 - capture/compare mode register 1 (output mode)"]
        pub ccmr1_output: Ccmr1Output,
        #[doc = "0x1c - capture/compare mode register 2 (output mode)"]
        pub ccmr2_output: Ccmr2Output,
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: Ccer,
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
        _reserved0: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: Ccr1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: Ccr2,
        #[doc = "0x3c - capture/compare register 3"]
        pub ccr3: Ccr3,
        #[doc = "0x40 - capture/compare register 4"]
        pub ccr4: Ccr4,
        _reserved1: [u8; 4usize],
        #[doc = "0x48 - DMA control register"]
        pub dcr: Dcr,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: Dmar,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CmsR {
            bits: u8,
        }
        impl CmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline ( always )]
            pub fn cms(&self) -> CmsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmsR { bits }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bits 5:6 - Center-aligned mode selection"]
            #[inline ( always )]
            pub fn cms(&mut self) -> _CmsW {
                _CmsW { w: self }
            }
            #[doc = "Bit 4 - Direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ti1sR {
            bits: u8,
        }
        impl Ti1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ti1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ti1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline ( always )]
            pub fn ti1s(&self) -> Ti1sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ti1sR { bits }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - TI1 selection"]
            #[inline ( always )]
            pub fn ti1s(&mut self) -> _Ti1sW {
                _Ti1sW { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtpR {
            bits: u8,
        }
        impl EtpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EceR {
            bits: u8,
        }
        impl EceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtpsR {
            bits: u8,
        }
        impl EtpsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EtfR {
            bits: u8,
        }
        impl EtfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtpsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtpsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EtfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EtfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline ( always )]
            pub fn etp(&self) -> EtpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpR { bits }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline ( always )]
            pub fn ece(&self) -> EceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EceR { bits }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline ( always )]
            pub fn etps(&self) -> EtpsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtpsR { bits }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline ( always )]
            pub fn etf(&self) -> EtfR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EtfR { bits }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - External trigger polarity"]
            #[inline ( always )]
            pub fn etp(&mut self) -> _EtpW {
                _EtpW { w: self }
            }
            #[doc = "Bit 14 - External clock enable"]
            #[inline ( always )]
            pub fn ece(&mut self) -> _EceW {
                _EceW { w: self }
            }
            #[doc = "Bits 12:13 - External trigger prescaler"]
            #[inline ( always )]
            pub fn etps(&mut self) -> _EtpsW {
                _EtpsW { w: self }
            }
            #[doc = "Bits 8:11 - External trigger filter"]
            #[inline ( always )]
            pub fn etf(&mut self) -> _EtfW {
                _EtfW { w: self }
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComdeR {
            bits: u8,
        }
        impl ComdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4deR {
            bits: u8,
        }
        impl Cc4deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3deR {
            bits: u8,
        }
        impl Cc3deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ieR {
            bits: u8,
        }
        impl Cc4ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ieR {
            bits: u8,
        }
        impl Cc3ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn comde(&self) -> ComdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComdeR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline ( always )]
            pub fn cc4de(&self) -> Cc4deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4deR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline ( always )]
            pub fn cc3de(&self) -> Cc3deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3deR { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline ( always )]
            pub fn cc4ie(&self) -> Cc4ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ieR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline ( always )]
            pub fn cc3ie(&self) -> Cc3ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ieR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn comde(&mut self) -> _ComdeW {
                _ComdeW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
            #[inline ( always )]
            pub fn cc4de(&mut self) -> _Cc4deW {
                _Cc4deW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
            #[inline ( always )]
            pub fn cc3de(&mut self) -> _Cc3deW {
                _Cc3deW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
            #[inline ( always )]
            pub fn cc4ie(&mut self) -> _Cc4ieW {
                _Cc4ieW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
            #[inline ( always )]
            pub fn cc3ie(&mut self) -> _Cc3ieW {
                _Cc3ieW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ofR {
            bits: u8,
        }
        impl Cc4ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ofR {
            bits: u8,
        }
        impl Cc3ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4ifR {
            bits: u8,
        }
        impl Cc4ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3ifR {
            bits: u8,
        }
        impl Cc3ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline ( always )]
            pub fn cc4of(&self) -> Cc4ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ofR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline ( always )]
            pub fn cc3of(&self) -> Cc3ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ofR { bits }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline ( always )]
            pub fn cc4if(&self) -> Cc4ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4ifR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline ( always )]
            pub fn cc3if(&self) -> Cc3ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3ifR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
            #[inline ( always )]
            pub fn cc4of(&mut self) -> _Cc4ofW {
                _Cc4ofW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
            #[inline ( always )]
            pub fn cc3of(&mut self) -> _Cc3ofW {
                _Cc3ofW { w: self }
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
            #[inline ( always )]
            pub fn cc4if(&mut self) -> _Cc4ifW {
                _Cc4ifW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
            #[inline ( always )]
            pub fn cc3if(&mut self) -> _Cc3ifW {
                _Cc3ifW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline ( always )]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            #[doc = "Bit 4 - Capture/compare 4 generation"]
            #[inline ( always )]
            pub fn cc4g(&mut self) -> _Cc4gW {
                _Cc4gW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare 3 generation"]
            #[inline ( always )]
            pub fn cc3g(&mut self) -> _Cc3gW {
                _Cc3gW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline ( always )]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline ( always )]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2ceR {
            bits: u8,
        }
        impl Oc2ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1ceR {
            bits: u8,
        }
        impl Oc1ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline ( always )]
            pub fn oc2ce(&self) -> Oc2ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2ceR { bits }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline ( always )]
            pub fn oc1ce(&self) -> Oc1ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1ceR { bits }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 2 clear enable"]
            #[inline ( always )]
            pub fn oc2ce(&mut self) -> _Oc2ceW {
                _Oc2ceW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            #[doc = "Bit 11 - Output compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            #[doc = "Bit 10 - Output compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bit 7 - Output compare 1 clear enable"]
            #[inline ( always )]
            pub fn oc1ce(&mut self) -> _Oc1ceW {
                _Oc1ceW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            #[doc = "Bit 3 - Output compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2pscR {
            bits: u8,
        }
        impl Ic2pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2psc(&self) -> Ic2pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pscR { bits }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2psc(&mut self) -> _Ic2pscW {
                _Ic2pscW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub struct Ccmr2Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (output mode)"]
    pub mod ccmr2_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4ceR {
            bits: u8,
        }
        impl Oc4ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4mR {
            bits: u8,
        }
        impl Oc4mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4peR {
            bits: u8,
        }
        impl Oc4peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc4feR {
            bits: u8,
        }
        impl Oc4feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3ceR {
            bits: u8,
        }
        impl Oc3ceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3mR {
            bits: u8,
        }
        impl Oc3mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3peR {
            bits: u8,
        }
        impl Oc3peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc3feR {
            bits: u8,
        }
        impl Oc3feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc4feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc4feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3ceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3ceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc3feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc3feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline ( always )]
            pub fn oc4ce(&self) -> Oc4ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4ceR { bits }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline ( always )]
            pub fn oc4m(&self) -> Oc4mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4mR { bits }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline ( always )]
            pub fn oc4pe(&self) -> Oc4peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4peR { bits }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline ( always )]
            pub fn oc4fe(&self) -> Oc4feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc4feR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline ( always )]
            pub fn oc3ce(&self) -> Oc3ceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3ceR { bits }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline ( always )]
            pub fn oc3m(&self) -> Oc3mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3mR { bits }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline ( always )]
            pub fn oc3pe(&self) -> Oc3peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3peR { bits }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline ( always )]
            pub fn oc3fe(&self) -> Oc3feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc3feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Output compare 4 clear enable"]
            #[inline ( always )]
            pub fn oc4ce(&mut self) -> _Oc4ceW {
                _Oc4ceW { w: self }
            }
            #[doc = "Bits 12:14 - Output compare 4 mode"]
            #[inline ( always )]
            pub fn oc4m(&mut self) -> _Oc4mW {
                _Oc4mW { w: self }
            }
            #[doc = "Bit 11 - Output compare 4 preload enable"]
            #[inline ( always )]
            pub fn oc4pe(&mut self) -> _Oc4peW {
                _Oc4peW { w: self }
            }
            #[doc = "Bit 10 - Output compare 4 fast enable"]
            #[inline ( always )]
            pub fn oc4fe(&mut self) -> _Oc4feW {
                _Oc4feW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            #[doc = "Bit 7 - Output compare 3 clear enable"]
            #[inline ( always )]
            pub fn oc3ce(&mut self) -> _Oc3ceW {
                _Oc3ceW { w: self }
            }
            #[doc = "Bits 4:6 - Output compare 3 mode"]
            #[inline ( always )]
            pub fn oc3m(&mut self) -> _Oc3mW {
                _Oc3mW { w: self }
            }
            #[doc = "Bit 3 - Output compare 3 preload enable"]
            #[inline ( always )]
            pub fn oc3pe(&mut self) -> _Oc3peW {
                _Oc3peW { w: self }
            }
            #[doc = "Bit 2 - Output compare 3 fast enable"]
            #[inline ( always )]
            pub fn oc3fe(&mut self) -> _Oc3feW {
                _Oc3feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub struct Ccmr2Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 2 (input mode)"]
    pub mod ccmr2_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr2Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic4fR {
            bits: u8,
        }
        impl Ic4fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic4pscR {
            bits: u8,
        }
        impl Ic4pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4sR {
            bits: u8,
        }
        impl Cc4sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic3fR {
            bits: u8,
        }
        impl Ic3fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic3pscR {
            bits: u8,
        }
        impl Ic3pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3sR {
            bits: u8,
        }
        impl Cc3sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic4fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic4pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic4pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic3fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic3pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic3pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline ( always )]
            pub fn ic4f(&self) -> Ic4fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4fR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline ( always )]
            pub fn ic4psc(&self) -> Ic4pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic4pscR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&self) -> Cc4sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4sR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline ( always )]
            pub fn ic3f(&self) -> Ic3fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline ( always )]
            pub fn ic3psc(&self) -> Ic3pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic3pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&self) -> Cc3sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 4 filter"]
            #[inline ( always )]
            pub fn ic4f(&mut self) -> _Ic4fW {
                _Ic4fW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 4 prescaler"]
            #[inline ( always )]
            pub fn ic4psc(&mut self) -> _Ic4pscW {
                _Ic4pscW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 4 selection"]
            #[inline ( always )]
            pub fn cc4s(&mut self) -> _Cc4sW {
                _Cc4sW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 3 filter"]
            #[inline ( always )]
            pub fn ic3f(&mut self) -> _Ic3fW {
                _Ic3fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 3 prescaler"]
            #[inline ( always )]
            pub fn ic3psc(&mut self) -> _Ic3pscW {
                _Ic3pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 3 selection"]
            #[inline ( always )]
            pub fn cc3s(&mut self) -> _Cc3sW {
                _Cc3sW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4npR {
            bits: u8,
        }
        impl Cc4npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4pR {
            bits: u8,
        }
        impl Cc4pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc4eR {
            bits: u8,
        }
        impl Cc4eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3npR {
            bits: u8,
        }
        impl Cc3npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3pR {
            bits: u8,
        }
        impl Cc3pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc3eR {
            bits: u8,
        }
        impl Cc3eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc4eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc4eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc3eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc3eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
            #[inline ( always )]
            pub fn cc4np(&self) -> Cc4npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4npR { bits }
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc4p(&self) -> Cc4pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4pR { bits }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline ( always )]
            pub fn cc4e(&self) -> Cc4eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc4eR { bits }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3np(&self) -> Cc3npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3npR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3p(&self) -> Cc3pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3pR { bits }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline ( always )]
            pub fn cc3e(&self) -> Cc3eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc3eR { bits }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Capture/Compare 4 output Polarity"]
            #[inline ( always )]
            pub fn cc4np(&mut self) -> _Cc4npW {
                _Cc4npW { w: self }
            }
            #[doc = "Bit 13 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc4p(&mut self) -> _Cc4pW {
                _Cc4pW { w: self }
            }
            #[doc = "Bit 12 - Capture/Compare 4 output enable"]
            #[inline ( always )]
            pub fn cc4e(&mut self) -> _Cc4eW {
                _Cc4eW { w: self }
            }
            #[doc = "Bit 11 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3np(&mut self) -> _Cc3npW {
                _Cc3npW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 3 output Polarity"]
            #[inline ( always )]
            pub fn cc3p(&mut self) -> _Cc3pW {
                _Cc3pW { w: self }
            }
            #[doc = "Bit 8 - Capture/Compare 3 output enable"]
            #[inline ( always )]
            pub fn cc3e(&mut self) -> _Cc3eW {
                _Cc3eW { w: self }
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntHR {
            bits: u16,
        }
        impl CntHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntLR {
            bits: u16,
        }
        impl CntLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High counter value (TIM2 only)"]
            #[inline ( always )]
            pub fn cnt_h(&self) -> CntHR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntHR { bits }
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline ( always )]
            pub fn cnt_l(&self) -> CntLR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High counter value (TIM2 only)"]
            #[inline ( always )]
            pub fn cnt_h(&mut self) -> _CntHW {
                _CntHW { w: self }
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline ( always )]
            pub fn cnt_l(&mut self) -> _CntLW {
                _CntLW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrHR {
            bits: u16,
        }
        impl ArrHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrLR {
            bits: u16,
        }
        impl ArrLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High Auto-reload value (TIM2 only)"]
            #[inline ( always )]
            pub fn arr_h(&self) -> ArrHR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrHR { bits }
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline ( always )]
            pub fn arr_l(&self) -> ArrLR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High Auto-reload value (TIM2 only)"]
            #[inline ( always )]
            pub fn arr_h(&mut self) -> _ArrHW {
                _ArrHW { w: self }
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline ( always )]
            pub fn arr_l(&mut self) -> _ArrLW {
                _ArrLW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1HR {
            bits: u16,
        }
        impl Ccr1HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1LR {
            bits: u16,
        }
        impl Ccr1LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High Capture/Compare 1 value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr1_h(&self) -> Ccr1HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1HR { bits }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1_l(&self) -> Ccr1LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1LR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High Capture/Compare 1 value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr1_h(&mut self) -> _Ccr1HW {
                _Ccr1HW { w: self }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1_l(&mut self) -> _Ccr1LW {
                _Ccr1LW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr2HR {
            bits: u16,
        }
        impl Ccr2HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr2LR {
            bits: u16,
        }
        impl Ccr2LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr2HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr2LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High Capture/Compare 2 value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr2_h(&self) -> Ccr2HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2HR { bits }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2_l(&self) -> Ccr2LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2LR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High Capture/Compare 2 value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr2_h(&mut self) -> _Ccr2HW {
                _Ccr2HW { w: self }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2_l(&mut self) -> _Ccr2LW {
                _Ccr2LW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 3"]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 3"]
    pub mod ccr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr3HR {
            bits: u16,
        }
        impl Ccr3HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr3LR {
            bits: u16,
        }
        impl Ccr3LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr3HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr3HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr3LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr3LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr3_h(&self) -> Ccr3HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr3HR { bits }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare value"]
            #[inline ( always )]
            pub fn ccr3_l(&self) -> Ccr3LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr3LR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr3_h(&mut self) -> _Ccr3HW {
                _Ccr3HW { w: self }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare value"]
            #[inline ( always )]
            pub fn ccr3_l(&mut self) -> _Ccr3LW {
                _Ccr3LW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 4"]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 4"]
    pub mod ccr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr4HR {
            bits: u16,
        }
        impl Ccr4HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr4LR {
            bits: u16,
        }
        impl Ccr4LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr4HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr4HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr4LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr4LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr4_h(&self) -> Ccr4HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr4HR { bits }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare value"]
            #[inline ( always )]
            pub fn ccr4_l(&self) -> Ccr4LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr4LR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:31 - High Capture/Compare value (TIM2 only)"]
            #[inline ( always )]
            pub fn ccr4_h(&mut self) -> _Ccr4HW {
                _Ccr4HW { w: self }
            }
            #[doc = "Bits 0:15 - Low Capture/Compare value"]
            #[inline ( always )]
            pub fn ccr4_l(&mut self) -> _Ccr4LW {
                _Ccr4LW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmarR {
            bits: u16,
        }
        impl DmarR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmarW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmar(&self) -> DmarR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmarR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmar(&mut self) -> _DmarW {
                _DmarW { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct Tim2 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim2 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
#[doc = "TIM3"]
pub const TIM3: Peripheral<Tim3> = unsafe { Peripheral::new(1073742848) };
#[doc = r" Register block"]
pub struct Tim3 {
    register_block: tim2::RegisterBlock,
}
impl Deref for Tim3 {
    type Target = tim2::RegisterBlock;
    fn deref(&self) -> &tim2::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose-timers"]
pub const TIM14: Peripheral<Tim14> = unsafe { Peripheral::new(1073750016) };
#[doc = "General-purpose-timers"]
pub mod tim14 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        _reserved0: [u8; 8usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: Ccmr1Output,
        _reserved1: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: Ccer,
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
        _reserved2: [u8; 4usize],
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: Ccr1,
        _reserved3: [u8; 24usize],
        #[doc = "0x50 - option register"]
        pub or: Or,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline ( always )]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
            #[doc = "Bit 2 - Output compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (input mode)"]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    #[doc = "option register"]
    pub struct Or {
        register: VolatileCell<u32>,
    }
    #[doc = "option register"]
    pub mod or {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Or {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RmpR {
            bits: u8,
        }
        impl RmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Timer input 1 remap"]
            #[inline ( always )]
            pub fn rmp(&self) -> RmpR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RmpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Timer input 1 remap"]
            #[inline ( always )]
            pub fn rmp(&mut self) -> _RmpW {
                _RmpW { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct Tim14 {
    register_block: tim14::RegisterBlock,
}
impl Deref for Tim14 {
    type Target = tim14::RegisterBlock;
    fn deref(&self) -> &tim14::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Basic-timers"]
pub const TIM6: Peripheral<Tim6> = unsafe { Peripheral::new(1073745920) };
#[doc = "Basic-timers"]
pub mod tim6 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        _reserved0: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        _reserved1: [u8; 12usize],
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Low counter value"]
            #[inline ( always )]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Low Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
}
#[doc = "Basic-timers"]
pub struct Tim6 {
    register_block: tim6::RegisterBlock,
}
impl Deref for Tim6 {
    type Target = tim6::RegisterBlock;
    fn deref(&self) -> &tim6::RegisterBlock {
        &self.register_block
    }
}
#[doc = "External interrupt/event controller"]
pub const EXTI: Peripheral<Exti> = unsafe { Peripheral::new(1073808384) };
#[doc = "External interrupt/event controller"]
pub mod exti {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt mask register (EXTI_IMR)"]
        pub imr: Imr,
        #[doc = "0x04 - Event mask register (EXTI_EMR)"]
        pub emr: Emr,
        #[doc = "0x08 - Rising Trigger selection register (EXTI_RTSR)"]
        pub rtsr: Rtsr,
        #[doc = "0x0c - Falling Trigger selection register (EXTI_FTSR)"]
        pub ftsr: Ftsr,
        #[doc = "0x10 - Software interrupt event register (EXTI_SWIER)"]
        pub swier: Swier,
        #[doc = "0x14 - Pending register (EXTI_PR)"]
        pub pr: Pr,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub struct Imr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt mask register (EXTI_IMR)"]
    pub mod imr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Imr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `MR0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Mr0R {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Mr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Mr0R::Disabled => 0,
                    Mr0R::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Mr0R {
                match bits {
                    0 => Mr0R::Disabled,
                    1 => Mr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Mr0R::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Mr0R::Enabled
            }
        }
        #[doc = "Possible values of the field `MR1`"]
        pub type Mr1R = Mr0R;
        #[doc = "Possible values of the field `MR2`"]
        pub type Mr2R = Mr0R;
        #[doc = "Possible values of the field `MR3`"]
        pub type Mr3R = Mr0R;
        #[doc = "Possible values of the field `MR4`"]
        pub type Mr4R = Mr0R;
        #[doc = "Possible values of the field `MR5`"]
        pub type Mr5R = Mr0R;
        #[doc = "Possible values of the field `MR6`"]
        pub type Mr6R = Mr0R;
        #[doc = "Possible values of the field `MR7`"]
        pub type Mr7R = Mr0R;
        #[doc = "Possible values of the field `MR8`"]
        pub type Mr8R = Mr0R;
        #[doc = "Possible values of the field `MR9`"]
        pub type Mr9R = Mr0R;
        #[doc = "Possible values of the field `MR10`"]
        pub type Mr10R = Mr0R;
        #[doc = "Possible values of the field `MR11`"]
        pub type Mr11R = Mr0R;
        #[doc = "Possible values of the field `MR12`"]
        pub type Mr12R = Mr0R;
        #[doc = "Possible values of the field `MR13`"]
        pub type Mr13R = Mr0R;
        #[doc = "Possible values of the field `MR14`"]
        pub type Mr14R = Mr0R;
        #[doc = "Possible values of the field `MR15`"]
        pub type Mr15R = Mr0R;
        #[doc = "Possible values of the field `MR16`"]
        pub type Mr16R = Mr0R;
        #[doc = "Possible values of the field `MR17`"]
        pub type Mr17R = Mr0R;
        #[doc = "Possible values of the field `MR18`"]
        pub type Mr18R = Mr0R;
        #[doc = "Possible values of the field `MR19`"]
        pub type Mr19R = Mr0R;
        #[doc = "Possible values of the field `MR20`"]
        pub type Mr20R = Mr0R;
        #[doc = "Possible values of the field `MR21`"]
        pub type Mr21R = Mr0R;
        #[doc = "Possible values of the field `MR22`"]
        pub type Mr22R = Mr0R;
        #[doc = "Possible values of the field `MR23`"]
        pub type Mr23R = Mr0R;
        #[doc = "Possible values of the field `MR24`"]
        pub type Mr24R = Mr0R;
        #[doc = "Possible values of the field `MR25`"]
        pub type Mr25R = Mr0R;
        #[doc = "Possible values of the field `MR26`"]
        pub type Mr26R = Mr0R;
        #[doc = "Possible values of the field `MR27`"]
        pub type Mr27R = Mr0R;
        #[doc = "Values that can be written to the field `MR0`"]
        pub enum Mr0W {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Mr0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Mr0W::Disabled => 0,
                    Mr0W::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1`"]
        pub type Mr1W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2`"]
        pub type Mr2W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3`"]
        pub type Mr3W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR4`"]
        pub type Mr4W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR5`"]
        pub type Mr5W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR6`"]
        pub type Mr6W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR7`"]
        pub type Mr7W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR8`"]
        pub type Mr8W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR9`"]
        pub type Mr9W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR10`"]
        pub type Mr10W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR11`"]
        pub type Mr11W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR12`"]
        pub type Mr12W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR13`"]
        pub type Mr13W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR14`"]
        pub type Mr14W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR15`"]
        pub type Mr15W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR16`"]
        pub type Mr16W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR17`"]
        pub type Mr17W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR18`"]
        pub type Mr18W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr18W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR19`"]
        pub type Mr19W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR20`"]
        pub type Mr20W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR21`"]
        pub type Mr21W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR22`"]
        pub type Mr22W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR23`"]
        pub type Mr23W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR24`"]
        pub type Mr24W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR25`"]
        pub type Mr25W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR26`"]
        pub type Mr26W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR27`"]
        pub type Mr27W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline ( always )]
            pub fn mr0(&self) -> Mr0R {
                Mr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline ( always )]
            pub fn mr1(&self) -> Mr1R {
                Mr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline ( always )]
            pub fn mr2(&self) -> Mr2R {
                Mr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline ( always )]
            pub fn mr3(&self) -> Mr3R {
                Mr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline ( always )]
            pub fn mr4(&self) -> Mr4R {
                Mr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline ( always )]
            pub fn mr5(&self) -> Mr5R {
                Mr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline ( always )]
            pub fn mr6(&self) -> Mr6R {
                Mr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline ( always )]
            pub fn mr7(&self) -> Mr7R {
                Mr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline ( always )]
            pub fn mr8(&self) -> Mr8R {
                Mr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline ( always )]
            pub fn mr9(&self) -> Mr9R {
                Mr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline ( always )]
            pub fn mr10(&self) -> Mr10R {
                Mr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline ( always )]
            pub fn mr11(&self) -> Mr11R {
                Mr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline ( always )]
            pub fn mr12(&self) -> Mr12R {
                Mr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline ( always )]
            pub fn mr13(&self) -> Mr13R {
                Mr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline ( always )]
            pub fn mr14(&self) -> Mr14R {
                Mr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline ( always )]
            pub fn mr15(&self) -> Mr15R {
                Mr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline ( always )]
            pub fn mr16(&self) -> Mr16R {
                Mr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline ( always )]
            pub fn mr17(&self) -> Mr17R {
                Mr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 18 - Interrupt Mask on line 18"]
            #[inline ( always )]
            pub fn mr18(&self) -> Mr18R {
                Mr18R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 18;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 19 - Interrupt Mask on line 19"]
            #[inline ( always )]
            pub fn mr19(&self) -> Mr19R {
                Mr19R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 20 - Interrupt Mask on line 20"]
            #[inline ( always )]
            pub fn mr20(&self) -> Mr20R {
                Mr20R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 20;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 21 - Interrupt Mask on line 21"]
            #[inline ( always )]
            pub fn mr21(&self) -> Mr21R {
                Mr21R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 21;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 22 - Interrupt Mask on line 22"]
            #[inline ( always )]
            pub fn mr22(&self) -> Mr22R {
                Mr22R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 22;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 23 - Interrupt Mask on line 23"]
            #[inline ( always )]
            pub fn mr23(&self) -> Mr23R {
                Mr23R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 23;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 24 - Interrupt Mask on line 24"]
            #[inline ( always )]
            pub fn mr24(&self) -> Mr24R {
                Mr24R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 24;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 25 - Interrupt Mask on line 25"]
            #[inline ( always )]
            pub fn mr25(&self) -> Mr25R {
                Mr25R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 25;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 26 - Interrupt Mask on line 26"]
            #[inline ( always )]
            pub fn mr26(&self) -> Mr26R {
                Mr26R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 26;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 27 - Interrupt Mask on line 27"]
            #[inline ( always )]
            pub fn mr27(&self) -> Mr27R {
                Mr27R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 27;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 261357568 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt Mask on line 0"]
            #[inline ( always )]
            pub fn mr0(&mut self) -> _Mr0W {
                _Mr0W { w: self }
            }
            #[doc = "Bit 1 - Interrupt Mask on line 1"]
            #[inline ( always )]
            pub fn mr1(&mut self) -> _Mr1W {
                _Mr1W { w: self }
            }
            #[doc = "Bit 2 - Interrupt Mask on line 2"]
            #[inline ( always )]
            pub fn mr2(&mut self) -> _Mr2W {
                _Mr2W { w: self }
            }
            #[doc = "Bit 3 - Interrupt Mask on line 3"]
            #[inline ( always )]
            pub fn mr3(&mut self) -> _Mr3W {
                _Mr3W { w: self }
            }
            #[doc = "Bit 4 - Interrupt Mask on line 4"]
            #[inline ( always )]
            pub fn mr4(&mut self) -> _Mr4W {
                _Mr4W { w: self }
            }
            #[doc = "Bit 5 - Interrupt Mask on line 5"]
            #[inline ( always )]
            pub fn mr5(&mut self) -> _Mr5W {
                _Mr5W { w: self }
            }
            #[doc = "Bit 6 - Interrupt Mask on line 6"]
            #[inline ( always )]
            pub fn mr6(&mut self) -> _Mr6W {
                _Mr6W { w: self }
            }
            #[doc = "Bit 7 - Interrupt Mask on line 7"]
            #[inline ( always )]
            pub fn mr7(&mut self) -> _Mr7W {
                _Mr7W { w: self }
            }
            #[doc = "Bit 8 - Interrupt Mask on line 8"]
            #[inline ( always )]
            pub fn mr8(&mut self) -> _Mr8W {
                _Mr8W { w: self }
            }
            #[doc = "Bit 9 - Interrupt Mask on line 9"]
            #[inline ( always )]
            pub fn mr9(&mut self) -> _Mr9W {
                _Mr9W { w: self }
            }
            #[doc = "Bit 10 - Interrupt Mask on line 10"]
            #[inline ( always )]
            pub fn mr10(&mut self) -> _Mr10W {
                _Mr10W { w: self }
            }
            #[doc = "Bit 11 - Interrupt Mask on line 11"]
            #[inline ( always )]
            pub fn mr11(&mut self) -> _Mr11W {
                _Mr11W { w: self }
            }
            #[doc = "Bit 12 - Interrupt Mask on line 12"]
            #[inline ( always )]
            pub fn mr12(&mut self) -> _Mr12W {
                _Mr12W { w: self }
            }
            #[doc = "Bit 13 - Interrupt Mask on line 13"]
            #[inline ( always )]
            pub fn mr13(&mut self) -> _Mr13W {
                _Mr13W { w: self }
            }
            #[doc = "Bit 14 - Interrupt Mask on line 14"]
            #[inline ( always )]
            pub fn mr14(&mut self) -> _Mr14W {
                _Mr14W { w: self }
            }
            #[doc = "Bit 15 - Interrupt Mask on line 15"]
            #[inline ( always )]
            pub fn mr15(&mut self) -> _Mr15W {
                _Mr15W { w: self }
            }
            #[doc = "Bit 16 - Interrupt Mask on line 16"]
            #[inline ( always )]
            pub fn mr16(&mut self) -> _Mr16W {
                _Mr16W { w: self }
            }
            #[doc = "Bit 17 - Interrupt Mask on line 17"]
            #[inline ( always )]
            pub fn mr17(&mut self) -> _Mr17W {
                _Mr17W { w: self }
            }
            #[doc = "Bit 18 - Interrupt Mask on line 18"]
            #[inline ( always )]
            pub fn mr18(&mut self) -> _Mr18W {
                _Mr18W { w: self }
            }
            #[doc = "Bit 19 - Interrupt Mask on line 19"]
            #[inline ( always )]
            pub fn mr19(&mut self) -> _Mr19W {
                _Mr19W { w: self }
            }
            #[doc = "Bit 20 - Interrupt Mask on line 20"]
            #[inline ( always )]
            pub fn mr20(&mut self) -> _Mr20W {
                _Mr20W { w: self }
            }
            #[doc = "Bit 21 - Interrupt Mask on line 21"]
            #[inline ( always )]
            pub fn mr21(&mut self) -> _Mr21W {
                _Mr21W { w: self }
            }
            #[doc = "Bit 22 - Interrupt Mask on line 22"]
            #[inline ( always )]
            pub fn mr22(&mut self) -> _Mr22W {
                _Mr22W { w: self }
            }
            #[doc = "Bit 23 - Interrupt Mask on line 23"]
            #[inline ( always )]
            pub fn mr23(&mut self) -> _Mr23W {
                _Mr23W { w: self }
            }
            #[doc = "Bit 24 - Interrupt Mask on line 24"]
            #[inline ( always )]
            pub fn mr24(&mut self) -> _Mr24W {
                _Mr24W { w: self }
            }
            #[doc = "Bit 25 - Interrupt Mask on line 25"]
            #[inline ( always )]
            pub fn mr25(&mut self) -> _Mr25W {
                _Mr25W { w: self }
            }
            #[doc = "Bit 26 - Interrupt Mask on line 26"]
            #[inline ( always )]
            pub fn mr26(&mut self) -> _Mr26W {
                _Mr26W { w: self }
            }
            #[doc = "Bit 27 - Interrupt Mask on line 27"]
            #[inline ( always )]
            pub fn mr27(&mut self) -> _Mr27W {
                _Mr27W { w: self }
            }
        }
    }
    #[doc = "Event mask register (EXTI_EMR)"]
    pub struct Emr {
        register: VolatileCell<u32>,
    }
    #[doc = "Event mask register (EXTI_EMR)"]
    pub mod emr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Emr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `MR0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Mr0R {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Mr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Mr0R::Disabled => 0,
                    Mr0R::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Mr0R {
                match bits {
                    0 => Mr0R::Disabled,
                    1 => Mr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Mr0R::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Mr0R::Enabled
            }
        }
        #[doc = "Possible values of the field `MR1`"]
        pub type Mr1R = Mr0R;
        #[doc = "Possible values of the field `MR2`"]
        pub type Mr2R = Mr0R;
        #[doc = "Possible values of the field `MR3`"]
        pub type Mr3R = Mr0R;
        #[doc = "Possible values of the field `MR4`"]
        pub type Mr4R = Mr0R;
        #[doc = "Possible values of the field `MR5`"]
        pub type Mr5R = Mr0R;
        #[doc = "Possible values of the field `MR6`"]
        pub type Mr6R = Mr0R;
        #[doc = "Possible values of the field `MR7`"]
        pub type Mr7R = Mr0R;
        #[doc = "Possible values of the field `MR8`"]
        pub type Mr8R = Mr0R;
        #[doc = "Possible values of the field `MR9`"]
        pub type Mr9R = Mr0R;
        #[doc = "Possible values of the field `MR10`"]
        pub type Mr10R = Mr0R;
        #[doc = "Possible values of the field `MR11`"]
        pub type Mr11R = Mr0R;
        #[doc = "Possible values of the field `MR12`"]
        pub type Mr12R = Mr0R;
        #[doc = "Possible values of the field `MR13`"]
        pub type Mr13R = Mr0R;
        #[doc = "Possible values of the field `MR14`"]
        pub type Mr14R = Mr0R;
        #[doc = "Possible values of the field `MR15`"]
        pub type Mr15R = Mr0R;
        #[doc = "Possible values of the field `MR16`"]
        pub type Mr16R = Mr0R;
        #[doc = "Possible values of the field `MR17`"]
        pub type Mr17R = Mr0R;
        #[doc = "Possible values of the field `MR18`"]
        pub type Mr18R = Mr0R;
        #[doc = "Possible values of the field `MR19`"]
        pub type Mr19R = Mr0R;
        #[doc = "Possible values of the field `MR20`"]
        pub type Mr20R = Mr0R;
        #[doc = "Possible values of the field `MR21`"]
        pub type Mr21R = Mr0R;
        #[doc = "Possible values of the field `MR22`"]
        pub type Mr22R = Mr0R;
        #[doc = "Possible values of the field `MR23`"]
        pub type Mr23R = Mr0R;
        #[doc = "Possible values of the field `MR24`"]
        pub type Mr24R = Mr0R;
        #[doc = "Possible values of the field `MR25`"]
        pub type Mr25R = Mr0R;
        #[doc = "Possible values of the field `MR26`"]
        pub type Mr26R = Mr0R;
        #[doc = "Possible values of the field `MR27`"]
        pub type Mr27R = Mr0R;
        #[doc = "Values that can be written to the field `MR0`"]
        pub enum Mr0W {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Mr0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Mr0W::Disabled => 0,
                    Mr0W::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1`"]
        pub type Mr1W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2`"]
        pub type Mr2W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3`"]
        pub type Mr3W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR4`"]
        pub type Mr4W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR5`"]
        pub type Mr5W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR6`"]
        pub type Mr6W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR7`"]
        pub type Mr7W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR8`"]
        pub type Mr8W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR9`"]
        pub type Mr9W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR10`"]
        pub type Mr10W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR11`"]
        pub type Mr11W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR12`"]
        pub type Mr12W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR13`"]
        pub type Mr13W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR14`"]
        pub type Mr14W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR15`"]
        pub type Mr15W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR16`"]
        pub type Mr16W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR17`"]
        pub type Mr17W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR18`"]
        pub type Mr18W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr18W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR19`"]
        pub type Mr19W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR20`"]
        pub type Mr20W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr20W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR21`"]
        pub type Mr21W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr21W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR22`"]
        pub type Mr22W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr22W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR23`"]
        pub type Mr23W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr23W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR24`"]
        pub type Mr24W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr24W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR25`"]
        pub type Mr25W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr25W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR26`"]
        pub type Mr26W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr26W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR27`"]
        pub type Mr27W = Mr0W;
        #[doc = r" Proxy"]
        pub struct _Mr27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mr27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Mr27W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Mr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Mr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline ( always )]
            pub fn mr0(&self) -> Mr0R {
                Mr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline ( always )]
            pub fn mr1(&self) -> Mr1R {
                Mr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline ( always )]
            pub fn mr2(&self) -> Mr2R {
                Mr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline ( always )]
            pub fn mr3(&self) -> Mr3R {
                Mr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline ( always )]
            pub fn mr4(&self) -> Mr4R {
                Mr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline ( always )]
            pub fn mr5(&self) -> Mr5R {
                Mr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline ( always )]
            pub fn mr6(&self) -> Mr6R {
                Mr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline ( always )]
            pub fn mr7(&self) -> Mr7R {
                Mr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline ( always )]
            pub fn mr8(&self) -> Mr8R {
                Mr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline ( always )]
            pub fn mr9(&self) -> Mr9R {
                Mr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline ( always )]
            pub fn mr10(&self) -> Mr10R {
                Mr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline ( always )]
            pub fn mr11(&self) -> Mr11R {
                Mr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline ( always )]
            pub fn mr12(&self) -> Mr12R {
                Mr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline ( always )]
            pub fn mr13(&self) -> Mr13R {
                Mr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline ( always )]
            pub fn mr14(&self) -> Mr14R {
                Mr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline ( always )]
            pub fn mr15(&self) -> Mr15R {
                Mr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline ( always )]
            pub fn mr16(&self) -> Mr16R {
                Mr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline ( always )]
            pub fn mr17(&self) -> Mr17R {
                Mr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 18 - Event Mask on line 18"]
            #[inline ( always )]
            pub fn mr18(&self) -> Mr18R {
                Mr18R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 18;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 19 - Event Mask on line 19"]
            #[inline ( always )]
            pub fn mr19(&self) -> Mr19R {
                Mr19R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 20 - Event Mask on line 20"]
            #[inline ( always )]
            pub fn mr20(&self) -> Mr20R {
                Mr20R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 20;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 21 - Event Mask on line 21"]
            #[inline ( always )]
            pub fn mr21(&self) -> Mr21R {
                Mr21R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 21;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 22 - Event Mask on line 22"]
            #[inline ( always )]
            pub fn mr22(&self) -> Mr22R {
                Mr22R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 22;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 23 - Event Mask on line 23"]
            #[inline ( always )]
            pub fn mr23(&self) -> Mr23R {
                Mr23R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 23;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 24 - Event Mask on line 24"]
            #[inline ( always )]
            pub fn mr24(&self) -> Mr24R {
                Mr24R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 24;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 25 - Event Mask on line 25"]
            #[inline ( always )]
            pub fn mr25(&self) -> Mr25R {
                Mr25R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 25;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 26 - Event Mask on line 26"]
            #[inline ( always )]
            pub fn mr26(&self) -> Mr26R {
                Mr26R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 26;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 27 - Event Mask on line 27"]
            #[inline ( always )]
            pub fn mr27(&self) -> Mr27R {
                Mr27R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 27;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Event Mask on line 0"]
            #[inline ( always )]
            pub fn mr0(&mut self) -> _Mr0W {
                _Mr0W { w: self }
            }
            #[doc = "Bit 1 - Event Mask on line 1"]
            #[inline ( always )]
            pub fn mr1(&mut self) -> _Mr1W {
                _Mr1W { w: self }
            }
            #[doc = "Bit 2 - Event Mask on line 2"]
            #[inline ( always )]
            pub fn mr2(&mut self) -> _Mr2W {
                _Mr2W { w: self }
            }
            #[doc = "Bit 3 - Event Mask on line 3"]
            #[inline ( always )]
            pub fn mr3(&mut self) -> _Mr3W {
                _Mr3W { w: self }
            }
            #[doc = "Bit 4 - Event Mask on line 4"]
            #[inline ( always )]
            pub fn mr4(&mut self) -> _Mr4W {
                _Mr4W { w: self }
            }
            #[doc = "Bit 5 - Event Mask on line 5"]
            #[inline ( always )]
            pub fn mr5(&mut self) -> _Mr5W {
                _Mr5W { w: self }
            }
            #[doc = "Bit 6 - Event Mask on line 6"]
            #[inline ( always )]
            pub fn mr6(&mut self) -> _Mr6W {
                _Mr6W { w: self }
            }
            #[doc = "Bit 7 - Event Mask on line 7"]
            #[inline ( always )]
            pub fn mr7(&mut self) -> _Mr7W {
                _Mr7W { w: self }
            }
            #[doc = "Bit 8 - Event Mask on line 8"]
            #[inline ( always )]
            pub fn mr8(&mut self) -> _Mr8W {
                _Mr8W { w: self }
            }
            #[doc = "Bit 9 - Event Mask on line 9"]
            #[inline ( always )]
            pub fn mr9(&mut self) -> _Mr9W {
                _Mr9W { w: self }
            }
            #[doc = "Bit 10 - Event Mask on line 10"]
            #[inline ( always )]
            pub fn mr10(&mut self) -> _Mr10W {
                _Mr10W { w: self }
            }
            #[doc = "Bit 11 - Event Mask on line 11"]
            #[inline ( always )]
            pub fn mr11(&mut self) -> _Mr11W {
                _Mr11W { w: self }
            }
            #[doc = "Bit 12 - Event Mask on line 12"]
            #[inline ( always )]
            pub fn mr12(&mut self) -> _Mr12W {
                _Mr12W { w: self }
            }
            #[doc = "Bit 13 - Event Mask on line 13"]
            #[inline ( always )]
            pub fn mr13(&mut self) -> _Mr13W {
                _Mr13W { w: self }
            }
            #[doc = "Bit 14 - Event Mask on line 14"]
            #[inline ( always )]
            pub fn mr14(&mut self) -> _Mr14W {
                _Mr14W { w: self }
            }
            #[doc = "Bit 15 - Event Mask on line 15"]
            #[inline ( always )]
            pub fn mr15(&mut self) -> _Mr15W {
                _Mr15W { w: self }
            }
            #[doc = "Bit 16 - Event Mask on line 16"]
            #[inline ( always )]
            pub fn mr16(&mut self) -> _Mr16W {
                _Mr16W { w: self }
            }
            #[doc = "Bit 17 - Event Mask on line 17"]
            #[inline ( always )]
            pub fn mr17(&mut self) -> _Mr17W {
                _Mr17W { w: self }
            }
            #[doc = "Bit 18 - Event Mask on line 18"]
            #[inline ( always )]
            pub fn mr18(&mut self) -> _Mr18W {
                _Mr18W { w: self }
            }
            #[doc = "Bit 19 - Event Mask on line 19"]
            #[inline ( always )]
            pub fn mr19(&mut self) -> _Mr19W {
                _Mr19W { w: self }
            }
            #[doc = "Bit 20 - Event Mask on line 20"]
            #[inline ( always )]
            pub fn mr20(&mut self) -> _Mr20W {
                _Mr20W { w: self }
            }
            #[doc = "Bit 21 - Event Mask on line 21"]
            #[inline ( always )]
            pub fn mr21(&mut self) -> _Mr21W {
                _Mr21W { w: self }
            }
            #[doc = "Bit 22 - Event Mask on line 22"]
            #[inline ( always )]
            pub fn mr22(&mut self) -> _Mr22W {
                _Mr22W { w: self }
            }
            #[doc = "Bit 23 - Event Mask on line 23"]
            #[inline ( always )]
            pub fn mr23(&mut self) -> _Mr23W {
                _Mr23W { w: self }
            }
            #[doc = "Bit 24 - Event Mask on line 24"]
            #[inline ( always )]
            pub fn mr24(&mut self) -> _Mr24W {
                _Mr24W { w: self }
            }
            #[doc = "Bit 25 - Event Mask on line 25"]
            #[inline ( always )]
            pub fn mr25(&mut self) -> _Mr25W {
                _Mr25W { w: self }
            }
            #[doc = "Bit 26 - Event Mask on line 26"]
            #[inline ( always )]
            pub fn mr26(&mut self) -> _Mr26W {
                _Mr26W { w: self }
            }
            #[doc = "Bit 27 - Event Mask on line 27"]
            #[inline ( always )]
            pub fn mr27(&mut self) -> _Mr27W {
                _Mr27W { w: self }
            }
        }
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub struct Rtsr {
        register: VolatileCell<u32>,
    }
    #[doc = "Rising Trigger selection register (EXTI_RTSR)"]
    pub mod rtsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rtsr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `TR0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tr0R {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tr0R::Disabled => 0,
                    Tr0R::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tr0R {
                match bits {
                    0 => Tr0R::Disabled,
                    1 => Tr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tr0R::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tr0R::Enabled
            }
        }
        #[doc = "Possible values of the field `TR1`"]
        pub type Tr1R = Tr0R;
        #[doc = "Possible values of the field `TR2`"]
        pub type Tr2R = Tr0R;
        #[doc = "Possible values of the field `TR3`"]
        pub type Tr3R = Tr0R;
        #[doc = "Possible values of the field `TR4`"]
        pub type Tr4R = Tr0R;
        #[doc = "Possible values of the field `TR5`"]
        pub type Tr5R = Tr0R;
        #[doc = "Possible values of the field `TR6`"]
        pub type Tr6R = Tr0R;
        #[doc = "Possible values of the field `TR7`"]
        pub type Tr7R = Tr0R;
        #[doc = "Possible values of the field `TR8`"]
        pub type Tr8R = Tr0R;
        #[doc = "Possible values of the field `TR9`"]
        pub type Tr9R = Tr0R;
        #[doc = "Possible values of the field `TR10`"]
        pub type Tr10R = Tr0R;
        #[doc = "Possible values of the field `TR11`"]
        pub type Tr11R = Tr0R;
        #[doc = "Possible values of the field `TR12`"]
        pub type Tr12R = Tr0R;
        #[doc = "Possible values of the field `TR13`"]
        pub type Tr13R = Tr0R;
        #[doc = "Possible values of the field `TR14`"]
        pub type Tr14R = Tr0R;
        #[doc = "Possible values of the field `TR15`"]
        pub type Tr15R = Tr0R;
        #[doc = "Possible values of the field `TR16`"]
        pub type Tr16R = Tr0R;
        #[doc = "Possible values of the field `TR17`"]
        pub type Tr17R = Tr0R;
        #[doc = "Possible values of the field `TR19`"]
        pub type Tr19R = Tr0R;
        #[doc = "Values that can be written to the field `TR0`"]
        pub enum Tr0W {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tr0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tr0W::Disabled => 0,
                    Tr0W::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR1`"]
        pub type Tr1W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR2`"]
        pub type Tr2W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR3`"]
        pub type Tr3W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR4`"]
        pub type Tr4W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR5`"]
        pub type Tr5W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR6`"]
        pub type Tr6W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR7`"]
        pub type Tr7W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR8`"]
        pub type Tr8W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR9`"]
        pub type Tr9W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR10`"]
        pub type Tr10W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR11`"]
        pub type Tr11W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR12`"]
        pub type Tr12W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR13`"]
        pub type Tr13W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR14`"]
        pub type Tr14W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR15`"]
        pub type Tr15W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR16`"]
        pub type Tr16W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR17`"]
        pub type Tr17W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR19`"]
        pub type Tr19W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline ( always )]
            pub fn tr0(&self) -> Tr0R {
                Tr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline ( always )]
            pub fn tr1(&self) -> Tr1R {
                Tr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline ( always )]
            pub fn tr2(&self) -> Tr2R {
                Tr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline ( always )]
            pub fn tr3(&self) -> Tr3R {
                Tr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline ( always )]
            pub fn tr4(&self) -> Tr4R {
                Tr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline ( always )]
            pub fn tr5(&self) -> Tr5R {
                Tr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline ( always )]
            pub fn tr6(&self) -> Tr6R {
                Tr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline ( always )]
            pub fn tr7(&self) -> Tr7R {
                Tr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline ( always )]
            pub fn tr8(&self) -> Tr8R {
                Tr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline ( always )]
            pub fn tr9(&self) -> Tr9R {
                Tr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline ( always )]
            pub fn tr10(&self) -> Tr10R {
                Tr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline ( always )]
            pub fn tr11(&self) -> Tr11R {
                Tr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline ( always )]
            pub fn tr12(&self) -> Tr12R {
                Tr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline ( always )]
            pub fn tr13(&self) -> Tr13R {
                Tr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline ( always )]
            pub fn tr14(&self) -> Tr14R {
                Tr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline ( always )]
            pub fn tr15(&self) -> Tr15R {
                Tr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline ( always )]
            pub fn tr16(&self) -> Tr16R {
                Tr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline ( always )]
            pub fn tr17(&self) -> Tr17R {
                Tr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 19 - Rising trigger event configuration of line 19"]
            #[inline ( always )]
            pub fn tr19(&self) -> Tr19R {
                Tr19R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Rising trigger event configuration of line 0"]
            #[inline ( always )]
            pub fn tr0(&mut self) -> _Tr0W {
                _Tr0W { w: self }
            }
            #[doc = "Bit 1 - Rising trigger event configuration of line 1"]
            #[inline ( always )]
            pub fn tr1(&mut self) -> _Tr1W {
                _Tr1W { w: self }
            }
            #[doc = "Bit 2 - Rising trigger event configuration of line 2"]
            #[inline ( always )]
            pub fn tr2(&mut self) -> _Tr2W {
                _Tr2W { w: self }
            }
            #[doc = "Bit 3 - Rising trigger event configuration of line 3"]
            #[inline ( always )]
            pub fn tr3(&mut self) -> _Tr3W {
                _Tr3W { w: self }
            }
            #[doc = "Bit 4 - Rising trigger event configuration of line 4"]
            #[inline ( always )]
            pub fn tr4(&mut self) -> _Tr4W {
                _Tr4W { w: self }
            }
            #[doc = "Bit 5 - Rising trigger event configuration of line 5"]
            #[inline ( always )]
            pub fn tr5(&mut self) -> _Tr5W {
                _Tr5W { w: self }
            }
            #[doc = "Bit 6 - Rising trigger event configuration of line 6"]
            #[inline ( always )]
            pub fn tr6(&mut self) -> _Tr6W {
                _Tr6W { w: self }
            }
            #[doc = "Bit 7 - Rising trigger event configuration of line 7"]
            #[inline ( always )]
            pub fn tr7(&mut self) -> _Tr7W {
                _Tr7W { w: self }
            }
            #[doc = "Bit 8 - Rising trigger event configuration of line 8"]
            #[inline ( always )]
            pub fn tr8(&mut self) -> _Tr8W {
                _Tr8W { w: self }
            }
            #[doc = "Bit 9 - Rising trigger event configuration of line 9"]
            #[inline ( always )]
            pub fn tr9(&mut self) -> _Tr9W {
                _Tr9W { w: self }
            }
            #[doc = "Bit 10 - Rising trigger event configuration of line 10"]
            #[inline ( always )]
            pub fn tr10(&mut self) -> _Tr10W {
                _Tr10W { w: self }
            }
            #[doc = "Bit 11 - Rising trigger event configuration of line 11"]
            #[inline ( always )]
            pub fn tr11(&mut self) -> _Tr11W {
                _Tr11W { w: self }
            }
            #[doc = "Bit 12 - Rising trigger event configuration of line 12"]
            #[inline ( always )]
            pub fn tr12(&mut self) -> _Tr12W {
                _Tr12W { w: self }
            }
            #[doc = "Bit 13 - Rising trigger event configuration of line 13"]
            #[inline ( always )]
            pub fn tr13(&mut self) -> _Tr13W {
                _Tr13W { w: self }
            }
            #[doc = "Bit 14 - Rising trigger event configuration of line 14"]
            #[inline ( always )]
            pub fn tr14(&mut self) -> _Tr14W {
                _Tr14W { w: self }
            }
            #[doc = "Bit 15 - Rising trigger event configuration of line 15"]
            #[inline ( always )]
            pub fn tr15(&mut self) -> _Tr15W {
                _Tr15W { w: self }
            }
            #[doc = "Bit 16 - Rising trigger event configuration of line 16"]
            #[inline ( always )]
            pub fn tr16(&mut self) -> _Tr16W {
                _Tr16W { w: self }
            }
            #[doc = "Bit 17 - Rising trigger event configuration of line 17"]
            #[inline ( always )]
            pub fn tr17(&mut self) -> _Tr17W {
                _Tr17W { w: self }
            }
            #[doc = "Bit 19 - Rising trigger event configuration of line 19"]
            #[inline ( always )]
            pub fn tr19(&mut self) -> _Tr19W {
                _Tr19W { w: self }
            }
        }
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub struct Ftsr {
        register: VolatileCell<u32>,
    }
    #[doc = "Falling Trigger selection register (EXTI_FTSR)"]
    pub mod ftsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ftsr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `TR0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tr0R {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tr0R::Disabled => 0,
                    Tr0R::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tr0R {
                match bits {
                    0 => Tr0R::Disabled,
                    1 => Tr0R::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tr0R::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tr0R::Enabled
            }
        }
        #[doc = "Possible values of the field `TR1`"]
        pub type Tr1R = Tr0R;
        #[doc = "Possible values of the field `TR2`"]
        pub type Tr2R = Tr0R;
        #[doc = "Possible values of the field `TR3`"]
        pub type Tr3R = Tr0R;
        #[doc = "Possible values of the field `TR4`"]
        pub type Tr4R = Tr0R;
        #[doc = "Possible values of the field `TR5`"]
        pub type Tr5R = Tr0R;
        #[doc = "Possible values of the field `TR6`"]
        pub type Tr6R = Tr0R;
        #[doc = "Possible values of the field `TR7`"]
        pub type Tr7R = Tr0R;
        #[doc = "Possible values of the field `TR8`"]
        pub type Tr8R = Tr0R;
        #[doc = "Possible values of the field `TR9`"]
        pub type Tr9R = Tr0R;
        #[doc = "Possible values of the field `TR10`"]
        pub type Tr10R = Tr0R;
        #[doc = "Possible values of the field `TR11`"]
        pub type Tr11R = Tr0R;
        #[doc = "Possible values of the field `TR12`"]
        pub type Tr12R = Tr0R;
        #[doc = "Possible values of the field `TR13`"]
        pub type Tr13R = Tr0R;
        #[doc = "Possible values of the field `TR14`"]
        pub type Tr14R = Tr0R;
        #[doc = "Possible values of the field `TR15`"]
        pub type Tr15R = Tr0R;
        #[doc = "Possible values of the field `TR16`"]
        pub type Tr16R = Tr0R;
        #[doc = "Possible values of the field `TR17`"]
        pub type Tr17R = Tr0R;
        #[doc = "Possible values of the field `TR19`"]
        pub type Tr19R = Tr0R;
        #[doc = "Values that can be written to the field `TR0`"]
        pub enum Tr0W {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tr0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tr0W::Disabled => 0,
                    Tr0W::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR1`"]
        pub type Tr1W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR2`"]
        pub type Tr2W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR3`"]
        pub type Tr3W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR4`"]
        pub type Tr4W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR5`"]
        pub type Tr5W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR6`"]
        pub type Tr6W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR7`"]
        pub type Tr7W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR8`"]
        pub type Tr8W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR9`"]
        pub type Tr9W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR10`"]
        pub type Tr10W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR11`"]
        pub type Tr11W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR12`"]
        pub type Tr12W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR13`"]
        pub type Tr13W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR14`"]
        pub type Tr14W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR15`"]
        pub type Tr15W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR16`"]
        pub type Tr16W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR17`"]
        pub type Tr17W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TR19`"]
        pub type Tr19W = Tr0W;
        #[doc = r" Proxy"]
        pub struct _Tr19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tr19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tr19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tr0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tr0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline ( always )]
            pub fn tr0(&self) -> Tr0R {
                Tr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline ( always )]
            pub fn tr1(&self) -> Tr1R {
                Tr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline ( always )]
            pub fn tr2(&self) -> Tr2R {
                Tr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline ( always )]
            pub fn tr3(&self) -> Tr3R {
                Tr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline ( always )]
            pub fn tr4(&self) -> Tr4R {
                Tr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline ( always )]
            pub fn tr5(&self) -> Tr5R {
                Tr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline ( always )]
            pub fn tr6(&self) -> Tr6R {
                Tr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline ( always )]
            pub fn tr7(&self) -> Tr7R {
                Tr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline ( always )]
            pub fn tr8(&self) -> Tr8R {
                Tr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline ( always )]
            pub fn tr9(&self) -> Tr9R {
                Tr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline ( always )]
            pub fn tr10(&self) -> Tr10R {
                Tr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline ( always )]
            pub fn tr11(&self) -> Tr11R {
                Tr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline ( always )]
            pub fn tr12(&self) -> Tr12R {
                Tr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline ( always )]
            pub fn tr13(&self) -> Tr13R {
                Tr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline ( always )]
            pub fn tr14(&self) -> Tr14R {
                Tr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline ( always )]
            pub fn tr15(&self) -> Tr15R {
                Tr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline ( always )]
            pub fn tr16(&self) -> Tr16R {
                Tr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline ( always )]
            pub fn tr17(&self) -> Tr17R {
                Tr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 19 - Falling trigger event configuration of line 19"]
            #[inline ( always )]
            pub fn tr19(&self) -> Tr19R {
                Tr19R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Falling trigger event configuration of line 0"]
            #[inline ( always )]
            pub fn tr0(&mut self) -> _Tr0W {
                _Tr0W { w: self }
            }
            #[doc = "Bit 1 - Falling trigger event configuration of line 1"]
            #[inline ( always )]
            pub fn tr1(&mut self) -> _Tr1W {
                _Tr1W { w: self }
            }
            #[doc = "Bit 2 - Falling trigger event configuration of line 2"]
            #[inline ( always )]
            pub fn tr2(&mut self) -> _Tr2W {
                _Tr2W { w: self }
            }
            #[doc = "Bit 3 - Falling trigger event configuration of line 3"]
            #[inline ( always )]
            pub fn tr3(&mut self) -> _Tr3W {
                _Tr3W { w: self }
            }
            #[doc = "Bit 4 - Falling trigger event configuration of line 4"]
            #[inline ( always )]
            pub fn tr4(&mut self) -> _Tr4W {
                _Tr4W { w: self }
            }
            #[doc = "Bit 5 - Falling trigger event configuration of line 5"]
            #[inline ( always )]
            pub fn tr5(&mut self) -> _Tr5W {
                _Tr5W { w: self }
            }
            #[doc = "Bit 6 - Falling trigger event configuration of line 6"]
            #[inline ( always )]
            pub fn tr6(&mut self) -> _Tr6W {
                _Tr6W { w: self }
            }
            #[doc = "Bit 7 - Falling trigger event configuration of line 7"]
            #[inline ( always )]
            pub fn tr7(&mut self) -> _Tr7W {
                _Tr7W { w: self }
            }
            #[doc = "Bit 8 - Falling trigger event configuration of line 8"]
            #[inline ( always )]
            pub fn tr8(&mut self) -> _Tr8W {
                _Tr8W { w: self }
            }
            #[doc = "Bit 9 - Falling trigger event configuration of line 9"]
            #[inline ( always )]
            pub fn tr9(&mut self) -> _Tr9W {
                _Tr9W { w: self }
            }
            #[doc = "Bit 10 - Falling trigger event configuration of line 10"]
            #[inline ( always )]
            pub fn tr10(&mut self) -> _Tr10W {
                _Tr10W { w: self }
            }
            #[doc = "Bit 11 - Falling trigger event configuration of line 11"]
            #[inline ( always )]
            pub fn tr11(&mut self) -> _Tr11W {
                _Tr11W { w: self }
            }
            #[doc = "Bit 12 - Falling trigger event configuration of line 12"]
            #[inline ( always )]
            pub fn tr12(&mut self) -> _Tr12W {
                _Tr12W { w: self }
            }
            #[doc = "Bit 13 - Falling trigger event configuration of line 13"]
            #[inline ( always )]
            pub fn tr13(&mut self) -> _Tr13W {
                _Tr13W { w: self }
            }
            #[doc = "Bit 14 - Falling trigger event configuration of line 14"]
            #[inline ( always )]
            pub fn tr14(&mut self) -> _Tr14W {
                _Tr14W { w: self }
            }
            #[doc = "Bit 15 - Falling trigger event configuration of line 15"]
            #[inline ( always )]
            pub fn tr15(&mut self) -> _Tr15W {
                _Tr15W { w: self }
            }
            #[doc = "Bit 16 - Falling trigger event configuration of line 16"]
            #[inline ( always )]
            pub fn tr16(&mut self) -> _Tr16W {
                _Tr16W { w: self }
            }
            #[doc = "Bit 17 - Falling trigger event configuration of line 17"]
            #[inline ( always )]
            pub fn tr17(&mut self) -> _Tr17W {
                _Tr17W { w: self }
            }
            #[doc = "Bit 19 - Falling trigger event configuration of line 19"]
            #[inline ( always )]
            pub fn tr19(&mut self) -> _Tr19W {
                _Tr19W { w: self }
            }
        }
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub struct Swier {
        register: VolatileCell<u32>,
    }
    #[doc = "Software interrupt event register (EXTI_SWIER)"]
    pub mod swier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Swier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `SWIER0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Swier0R {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Swier0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Swier0R::Disabled => 0,
                    Swier0R::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Swier0R {
                match bits {
                    0 => Swier0R::Disabled,
                    1 => Swier0R::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Swier0R::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Swier0R::Enabled
            }
        }
        #[doc = "Possible values of the field `SWIER1`"]
        pub type Swier1R = Swier0R;
        #[doc = "Possible values of the field `SWIER2`"]
        pub type Swier2R = Swier0R;
        #[doc = "Possible values of the field `SWIER3`"]
        pub type Swier3R = Swier0R;
        #[doc = "Possible values of the field `SWIER4`"]
        pub type Swier4R = Swier0R;
        #[doc = "Possible values of the field `SWIER5`"]
        pub type Swier5R = Swier0R;
        #[doc = "Possible values of the field `SWIER6`"]
        pub type Swier6R = Swier0R;
        #[doc = "Possible values of the field `SWIER7`"]
        pub type Swier7R = Swier0R;
        #[doc = "Possible values of the field `SWIER8`"]
        pub type Swier8R = Swier0R;
        #[doc = "Possible values of the field `SWIER9`"]
        pub type Swier9R = Swier0R;
        #[doc = "Possible values of the field `SWIER10`"]
        pub type Swier10R = Swier0R;
        #[doc = "Possible values of the field `SWIER11`"]
        pub type Swier11R = Swier0R;
        #[doc = "Possible values of the field `SWIER12`"]
        pub type Swier12R = Swier0R;
        #[doc = "Possible values of the field `SWIER13`"]
        pub type Swier13R = Swier0R;
        #[doc = "Possible values of the field `SWIER14`"]
        pub type Swier14R = Swier0R;
        #[doc = "Possible values of the field `SWIER15`"]
        pub type Swier15R = Swier0R;
        #[doc = "Possible values of the field `SWIER16`"]
        pub type Swier16R = Swier0R;
        #[doc = "Possible values of the field `SWIER17`"]
        pub type Swier17R = Swier0R;
        #[doc = "Possible values of the field `SWIER19`"]
        pub type Swier19R = Swier0R;
        #[doc = "Values that can be written to the field `SWIER0`"]
        pub enum Swier0W {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Swier0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Swier0W::Disabled => 0,
                    Swier0W::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Swier0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER1`"]
        pub type Swier1W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER2`"]
        pub type Swier2W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER3`"]
        pub type Swier3W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER4`"]
        pub type Swier4W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER5`"]
        pub type Swier5W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER6`"]
        pub type Swier6W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER7`"]
        pub type Swier7W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER8`"]
        pub type Swier8W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER9`"]
        pub type Swier9W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER10`"]
        pub type Swier10W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER11`"]
        pub type Swier11W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER12`"]
        pub type Swier12W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER13`"]
        pub type Swier13W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER14`"]
        pub type Swier14W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER15`"]
        pub type Swier15W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER16`"]
        pub type Swier16W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER17`"]
        pub type Swier17W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWIER19`"]
        pub type Swier19W = Swier0W;
        #[doc = r" Proxy"]
        pub struct _Swier19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Swier19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Swier19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Swier0W::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Swier0W::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline ( always )]
            pub fn swier0(&self) -> Swier0R {
                Swier0R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 0;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline ( always )]
            pub fn swier1(&self) -> Swier1R {
                Swier1R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline ( always )]
            pub fn swier2(&self) -> Swier2R {
                Swier2R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline ( always )]
            pub fn swier3(&self) -> Swier3R {
                Swier3R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 3;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline ( always )]
            pub fn swier4(&self) -> Swier4R {
                Swier4R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 4;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline ( always )]
            pub fn swier5(&self) -> Swier5R {
                Swier5R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 5;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline ( always )]
            pub fn swier6(&self) -> Swier6R {
                Swier6R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 6;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline ( always )]
            pub fn swier7(&self) -> Swier7R {
                Swier7R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 7;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline ( always )]
            pub fn swier8(&self) -> Swier8R {
                Swier8R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 8;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline ( always )]
            pub fn swier9(&self) -> Swier9R {
                Swier9R::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline ( always )]
            pub fn swier10(&self) -> Swier10R {
                Swier10R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 10;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline ( always )]
            pub fn swier11(&self) -> Swier11R {
                Swier11R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline ( always )]
            pub fn swier12(&self) -> Swier12R {
                Swier12R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 12;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline ( always )]
            pub fn swier13(&self) -> Swier13R {
                Swier13R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 13;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline ( always )]
            pub fn swier14(&self) -> Swier14R {
                Swier14R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 14;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline ( always )]
            pub fn swier15(&self) -> Swier15R {
                Swier15R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 15;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline ( always )]
            pub fn swier16(&self) -> Swier16R {
                Swier16R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 16;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline ( always )]
            pub fn swier17(&self) -> Swier17R {
                Swier17R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 17;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 19 - Software Interrupt on line 19"]
            #[inline ( always )]
            pub fn swier19(&self) -> Swier19R {
                Swier19R::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 19;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software Interrupt on line 0"]
            #[inline ( always )]
            pub fn swier0(&mut self) -> _Swier0W {
                _Swier0W { w: self }
            }
            #[doc = "Bit 1 - Software Interrupt on line 1"]
            #[inline ( always )]
            pub fn swier1(&mut self) -> _Swier1W {
                _Swier1W { w: self }
            }
            #[doc = "Bit 2 - Software Interrupt on line 2"]
            #[inline ( always )]
            pub fn swier2(&mut self) -> _Swier2W {
                _Swier2W { w: self }
            }
            #[doc = "Bit 3 - Software Interrupt on line 3"]
            #[inline ( always )]
            pub fn swier3(&mut self) -> _Swier3W {
                _Swier3W { w: self }
            }
            #[doc = "Bit 4 - Software Interrupt on line 4"]
            #[inline ( always )]
            pub fn swier4(&mut self) -> _Swier4W {
                _Swier4W { w: self }
            }
            #[doc = "Bit 5 - Software Interrupt on line 5"]
            #[inline ( always )]
            pub fn swier5(&mut self) -> _Swier5W {
                _Swier5W { w: self }
            }
            #[doc = "Bit 6 - Software Interrupt on line 6"]
            #[inline ( always )]
            pub fn swier6(&mut self) -> _Swier6W {
                _Swier6W { w: self }
            }
            #[doc = "Bit 7 - Software Interrupt on line 7"]
            #[inline ( always )]
            pub fn swier7(&mut self) -> _Swier7W {
                _Swier7W { w: self }
            }
            #[doc = "Bit 8 - Software Interrupt on line 8"]
            #[inline ( always )]
            pub fn swier8(&mut self) -> _Swier8W {
                _Swier8W { w: self }
            }
            #[doc = "Bit 9 - Software Interrupt on line 9"]
            #[inline ( always )]
            pub fn swier9(&mut self) -> _Swier9W {
                _Swier9W { w: self }
            }
            #[doc = "Bit 10 - Software Interrupt on line 10"]
            #[inline ( always )]
            pub fn swier10(&mut self) -> _Swier10W {
                _Swier10W { w: self }
            }
            #[doc = "Bit 11 - Software Interrupt on line 11"]
            #[inline ( always )]
            pub fn swier11(&mut self) -> _Swier11W {
                _Swier11W { w: self }
            }
            #[doc = "Bit 12 - Software Interrupt on line 12"]
            #[inline ( always )]
            pub fn swier12(&mut self) -> _Swier12W {
                _Swier12W { w: self }
            }
            #[doc = "Bit 13 - Software Interrupt on line 13"]
            #[inline ( always )]
            pub fn swier13(&mut self) -> _Swier13W {
                _Swier13W { w: self }
            }
            #[doc = "Bit 14 - Software Interrupt on line 14"]
            #[inline ( always )]
            pub fn swier14(&mut self) -> _Swier14W {
                _Swier14W { w: self }
            }
            #[doc = "Bit 15 - Software Interrupt on line 15"]
            #[inline ( always )]
            pub fn swier15(&mut self) -> _Swier15W {
                _Swier15W { w: self }
            }
            #[doc = "Bit 16 - Software Interrupt on line 16"]
            #[inline ( always )]
            pub fn swier16(&mut self) -> _Swier16W {
                _Swier16W { w: self }
            }
            #[doc = "Bit 17 - Software Interrupt on line 17"]
            #[inline ( always )]
            pub fn swier17(&mut self) -> _Swier17W {
                _Swier17W { w: self }
            }
            #[doc = "Bit 19 - Software Interrupt on line 19"]
            #[inline ( always )]
            pub fn swier19(&mut self) -> _Swier19W {
                _Swier19W { w: self }
            }
        }
    }
    #[doc = "Pending register (EXTI_PR)"]
    pub struct Pr {
        register: VolatileCell<u32>,
    }
    #[doc = "Pending register (EXTI_PR)"]
    pub mod pr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Pr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `PR0`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Pr0R {
            #[doc = "No interrupt is pending."]
            NotPending,
            #[doc = "An interrupt is pending."]
            Pending,
        }
        impl Pr0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Pr0R::NotPending => 0,
                    Pr0R::Pending => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Pr0R {
                match bits {
                    0 => Pr0R::NotPending,
                    1 => Pr0R::Pending,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotPending`"]
            #[inline ( always )]
            pub fn is_not_pending(&self) -> bool {
                *self == Pr0R::NotPending
            }
            #[doc = "Checks if the value of the field is `Pending`"]
            #[inline ( always )]
            pub fn is_pending(&self) -> bool {
                *self == Pr0R::Pending
            }
        }
        #[doc = "Possible values of the field `PR1`"]
        pub type Pr1R = Pr0R;
        #[doc = "Possible values of the field `PR2`"]
        pub type Pr2R = Pr0R;
        #[doc = "Possible values of the field `PR3`"]
        pub type Pr3R = Pr0R;
        #[doc = "Possible values of the field `PR4`"]
        pub type Pr4R = Pr0R;
        #[doc = "Possible values of the field `PR5`"]
        pub type Pr5R = Pr0R;
        #[doc = "Possible values of the field `PR6`"]
        pub type Pr6R = Pr0R;
        #[doc = "Possible values of the field `PR7`"]
        pub type Pr7R = Pr0R;
        #[doc = "Possible values of the field `PR8`"]
        pub type Pr8R = Pr0R;
        #[doc = "Possible values of the field `PR9`"]
        pub type Pr9R = Pr0R;
        #[doc = "Possible values of the field `PR10`"]
        pub type Pr10R = Pr0R;
        #[doc = "Possible values of the field `PR11`"]
        pub type Pr11R = Pr0R;
        #[doc = "Possible values of the field `PR12`"]
        pub type Pr12R = Pr0R;
        #[doc = "Possible values of the field `PR13`"]
        pub type Pr13R = Pr0R;
        #[doc = "Possible values of the field `PR14`"]
        pub type Pr14R = Pr0R;
        #[doc = "Possible values of the field `PR15`"]
        pub type Pr15R = Pr0R;
        #[doc = "Possible values of the field `PR16`"]
        pub type Pr16R = Pr0R;
        #[doc = "Possible values of the field `PR17`"]
        pub type Pr17R = Pr0R;
        #[doc = "Possible values of the field `PR19`"]
        pub type Pr19R = Pr0R;
        #[doc = "Values that can be written to the field `PR0`"]
        pub enum Pr0W {
            #[doc = "No interrupt is pending."]
            NotPending,
            #[doc = "An interrupt is pending."]
            Pending,
        }
        impl Pr0W {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Pr0W::NotPending => 0,
                    Pr0W::Pending => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pr0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR1`"]
        pub type Pr1W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR2`"]
        pub type Pr2W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR3`"]
        pub type Pr3W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR4`"]
        pub type Pr4W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR5`"]
        pub type Pr5W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR6`"]
        pub type Pr6W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR7`"]
        pub type Pr7W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR8`"]
        pub type Pr8W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr8W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR9`"]
        pub type Pr9W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr9W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR10`"]
        pub type Pr10W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr10W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR11`"]
        pub type Pr11W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr11W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR12`"]
        pub type Pr12W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr12W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR13`"]
        pub type Pr13W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr13W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR14`"]
        pub type Pr14W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr14W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR15`"]
        pub type Pr15W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr15W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR16`"]
        pub type Pr16W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr16W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR17`"]
        pub type Pr17W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr17W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PR19`"]
        pub type Pr19W = Pr0W;
        #[doc = r" Proxy"]
        pub struct _Pr19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pr19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Pr19W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No interrupt is pending."]
            #[inline ( always )]
            pub fn not_pending(self) -> &'a mut W {
                self.variant(Pr0W::NotPending)
            }
            #[doc = "An interrupt is pending."]
            #[inline ( always )]
            pub fn pending(self) -> &'a mut W {
                self.variant(Pr0W::Pending)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline ( always )]
            pub fn pr0(&self) -> Pr0R {
                Pr0R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline ( always )]
            pub fn pr1(&self) -> Pr1R {
                Pr1R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 1;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline ( always )]
            pub fn pr2(&self) -> Pr2R {
                Pr2R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 2;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline ( always )]
            pub fn pr3(&self) -> Pr3R {
                Pr3R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 3;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline ( always )]
            pub fn pr4(&self) -> Pr4R {
                Pr4R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 4;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline ( always )]
            pub fn pr5(&self) -> Pr5R {
                Pr5R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 5;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline ( always )]
            pub fn pr6(&self) -> Pr6R {
                Pr6R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 6;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline ( always )]
            pub fn pr7(&self) -> Pr7R {
                Pr7R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 7;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline ( always )]
            pub fn pr8(&self) -> Pr8R {
                Pr8R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 8;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline ( always )]
            pub fn pr9(&self) -> Pr9R {
                Pr9R::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 9;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline ( always )]
            pub fn pr10(&self) -> Pr10R {
                Pr10R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 10;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline ( always )]
            pub fn pr11(&self) -> Pr11R {
                Pr11R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 11;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline ( always )]
            pub fn pr12(&self) -> Pr12R {
                Pr12R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 12;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline ( always )]
            pub fn pr13(&self) -> Pr13R {
                Pr13R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 13;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline ( always )]
            pub fn pr14(&self) -> Pr14R {
                Pr14R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 14;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline ( always )]
            pub fn pr15(&self) -> Pr15R {
                Pr15R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 15;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline ( always )]
            pub fn pr16(&self) -> Pr16R {
                Pr16R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 16;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline ( always )]
            pub fn pr17(&self) -> Pr17R {
                Pr17R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 17;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 19 - Pending bit 19"]
            #[inline ( always )]
            pub fn pr19(&self) -> Pr19R {
                Pr19R::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 19;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pending bit 0"]
            #[inline ( always )]
            pub fn pr0(&mut self) -> _Pr0W {
                _Pr0W { w: self }
            }
            #[doc = "Bit 1 - Pending bit 1"]
            #[inline ( always )]
            pub fn pr1(&mut self) -> _Pr1W {
                _Pr1W { w: self }
            }
            #[doc = "Bit 2 - Pending bit 2"]
            #[inline ( always )]
            pub fn pr2(&mut self) -> _Pr2W {
                _Pr2W { w: self }
            }
            #[doc = "Bit 3 - Pending bit 3"]
            #[inline ( always )]
            pub fn pr3(&mut self) -> _Pr3W {
                _Pr3W { w: self }
            }
            #[doc = "Bit 4 - Pending bit 4"]
            #[inline ( always )]
            pub fn pr4(&mut self) -> _Pr4W {
                _Pr4W { w: self }
            }
            #[doc = "Bit 5 - Pending bit 5"]
            #[inline ( always )]
            pub fn pr5(&mut self) -> _Pr5W {
                _Pr5W { w: self }
            }
            #[doc = "Bit 6 - Pending bit 6"]
            #[inline ( always )]
            pub fn pr6(&mut self) -> _Pr6W {
                _Pr6W { w: self }
            }
            #[doc = "Bit 7 - Pending bit 7"]
            #[inline ( always )]
            pub fn pr7(&mut self) -> _Pr7W {
                _Pr7W { w: self }
            }
            #[doc = "Bit 8 - Pending bit 8"]
            #[inline ( always )]
            pub fn pr8(&mut self) -> _Pr8W {
                _Pr8W { w: self }
            }
            #[doc = "Bit 9 - Pending bit 9"]
            #[inline ( always )]
            pub fn pr9(&mut self) -> _Pr9W {
                _Pr9W { w: self }
            }
            #[doc = "Bit 10 - Pending bit 10"]
            #[inline ( always )]
            pub fn pr10(&mut self) -> _Pr10W {
                _Pr10W { w: self }
            }
            #[doc = "Bit 11 - Pending bit 11"]
            #[inline ( always )]
            pub fn pr11(&mut self) -> _Pr11W {
                _Pr11W { w: self }
            }
            #[doc = "Bit 12 - Pending bit 12"]
            #[inline ( always )]
            pub fn pr12(&mut self) -> _Pr12W {
                _Pr12W { w: self }
            }
            #[doc = "Bit 13 - Pending bit 13"]
            #[inline ( always )]
            pub fn pr13(&mut self) -> _Pr13W {
                _Pr13W { w: self }
            }
            #[doc = "Bit 14 - Pending bit 14"]
            #[inline ( always )]
            pub fn pr14(&mut self) -> _Pr14W {
                _Pr14W { w: self }
            }
            #[doc = "Bit 15 - Pending bit 15"]
            #[inline ( always )]
            pub fn pr15(&mut self) -> _Pr15W {
                _Pr15W { w: self }
            }
            #[doc = "Bit 16 - Pending bit 16"]
            #[inline ( always )]
            pub fn pr16(&mut self) -> _Pr16W {
                _Pr16W { w: self }
            }
            #[doc = "Bit 17 - Pending bit 17"]
            #[inline ( always )]
            pub fn pr17(&mut self) -> _Pr17W {
                _Pr17W { w: self }
            }
            #[doc = "Bit 19 - Pending bit 19"]
            #[inline ( always )]
            pub fn pr19(&mut self) -> _Pr19W {
                _Pr19W { w: self }
            }
        }
    }
}
#[doc = "External interrupt/event controller"]
pub struct Exti {
    register_block: exti::RegisterBlock,
}
impl Deref for Exti {
    type Target = exti::RegisterBlock;
    fn deref(&self) -> &exti::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Nested Vectored Interrupt Controller"]
pub const NVIC: Peripheral<Nvic> = unsafe { Peripheral::new(3758153984) };
#[doc = "Nested Vectored Interrupt Controller"]
pub mod nvic {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Set Enable Register"]
        pub iser: Iser,
        _reserved0: [u8; 124usize],
        #[doc = "0x80 - Interrupt Clear Enable Register"]
        pub icer: Icer,
        _reserved1: [u8; 124usize],
        #[doc = "0x100 - Interrupt Set-Pending Register"]
        pub ispr: Ispr,
        _reserved2: [u8; 124usize],
        #[doc = "0x180 - Interrupt Clear-Pending Register"]
        pub icpr: Icpr,
        _reserved3: [u8; 380usize],
        #[doc = "0x300 - Interrupt Priority Register 0"]
        pub ipr0: Ipr0,
        #[doc = "0x304 - Interrupt Priority Register 1"]
        pub ipr1: Ipr1,
        #[doc = "0x308 - Interrupt Priority Register 2"]
        pub ipr2: Ipr2,
        #[doc = "0x30c - Interrupt Priority Register 3"]
        pub ipr3: Ipr3,
        #[doc = "0x310 - Interrupt Priority Register 4"]
        pub ipr4: Ipr4,
        #[doc = "0x314 - Interrupt Priority Register 5"]
        pub ipr5: Ipr5,
        #[doc = "0x318 - Interrupt Priority Register 6"]
        pub ipr6: Ipr6,
        #[doc = "0x31c - Interrupt Priority Register 7"]
        pub ipr7: Ipr7,
    }
    #[doc = "Interrupt Set Enable Register"]
    pub struct Iser {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Set Enable Register"]
    pub mod iser {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Iser {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct SetenaR {
            bits: u32,
        }
        impl SetenaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SetenaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SetenaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - SETENA"]
            #[inline ( always )]
            pub fn setena(&self) -> SetenaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SetenaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - SETENA"]
            #[inline ( always )]
            pub fn setena(&mut self) -> _SetenaW {
                _SetenaW { w: self }
            }
        }
    }
    #[doc = "Interrupt Clear Enable Register"]
    pub struct Icer {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear Enable Register"]
    pub mod icer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Icer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ClrenaR {
            bits: u32,
        }
        impl ClrenaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ClrenaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClrenaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - CLRENA"]
            #[inline ( always )]
            pub fn clrena(&self) -> ClrenaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ClrenaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - CLRENA"]
            #[inline ( always )]
            pub fn clrena(&mut self) -> _ClrenaW {
                _ClrenaW { w: self }
            }
        }
    }
    #[doc = "Interrupt Set-Pending Register"]
    pub struct Ispr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Set-Pending Register"]
    pub mod ispr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ispr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct SetpendR {
            bits: u32,
        }
        impl SetpendR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SetpendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SetpendW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - SETPEND"]
            #[inline ( always )]
            pub fn setpend(&self) -> SetpendR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SetpendR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - SETPEND"]
            #[inline ( always )]
            pub fn setpend(&mut self) -> _SetpendW {
                _SetpendW { w: self }
            }
        }
    }
    #[doc = "Interrupt Clear-Pending Register"]
    pub struct Icpr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Clear-Pending Register"]
    pub mod icpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Icpr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ClrpendR {
            bits: u32,
        }
        impl ClrpendR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ClrpendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClrpendW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - CLRPEND"]
            #[inline ( always )]
            pub fn clrpend(&self) -> ClrpendR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                ClrpendR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - CLRPEND"]
            #[inline ( always )]
            pub fn clrpend(&mut self) -> _ClrpendW {
                _ClrpendW { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 0"]
    pub struct Ipr0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 0"]
    pub mod ipr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri00R {
            bits: u8,
        }
        impl Pri00R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri01R {
            bits: u8,
        }
        impl Pri01R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri02R {
            bits: u8,
        }
        impl Pri02R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri03R {
            bits: u8,
        }
        impl Pri03R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri00W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri00W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri01W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri01W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri02W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri02W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri03W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri03W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_00"]
            #[inline ( always )]
            pub fn pri_00(&self) -> Pri00R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri00R { bits }
            }
            #[doc = "Bits 14:15 - PRI_01"]
            #[inline ( always )]
            pub fn pri_01(&self) -> Pri01R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri01R { bits }
            }
            #[doc = "Bits 22:23 - PRI_02"]
            #[inline ( always )]
            pub fn pri_02(&self) -> Pri02R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri02R { bits }
            }
            #[doc = "Bits 30:31 - PRI_03"]
            #[inline ( always )]
            pub fn pri_03(&self) -> Pri03R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri03R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_00"]
            #[inline ( always )]
            pub fn pri_00(&mut self) -> _Pri00W {
                _Pri00W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_01"]
            #[inline ( always )]
            pub fn pri_01(&mut self) -> _Pri01W {
                _Pri01W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_02"]
            #[inline ( always )]
            pub fn pri_02(&mut self) -> _Pri02W {
                _Pri02W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_03"]
            #[inline ( always )]
            pub fn pri_03(&mut self) -> _Pri03W {
                _Pri03W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 1"]
    pub struct Ipr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 1"]
    pub mod ipr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri40R {
            bits: u8,
        }
        impl Pri40R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri41R {
            bits: u8,
        }
        impl Pri41R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri42R {
            bits: u8,
        }
        impl Pri42R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri43R {
            bits: u8,
        }
        impl Pri43R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri40W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri40W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri41W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri41W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri42W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri42W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri43W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri43W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_40"]
            #[inline ( always )]
            pub fn pri_40(&self) -> Pri40R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri40R { bits }
            }
            #[doc = "Bits 14:15 - PRI_41"]
            #[inline ( always )]
            pub fn pri_41(&self) -> Pri41R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri41R { bits }
            }
            #[doc = "Bits 22:23 - PRI_42"]
            #[inline ( always )]
            pub fn pri_42(&self) -> Pri42R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri42R { bits }
            }
            #[doc = "Bits 30:31 - PRI_43"]
            #[inline ( always )]
            pub fn pri_43(&self) -> Pri43R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri43R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_40"]
            #[inline ( always )]
            pub fn pri_40(&mut self) -> _Pri40W {
                _Pri40W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_41"]
            #[inline ( always )]
            pub fn pri_41(&mut self) -> _Pri41W {
                _Pri41W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_42"]
            #[inline ( always )]
            pub fn pri_42(&mut self) -> _Pri42W {
                _Pri42W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_43"]
            #[inline ( always )]
            pub fn pri_43(&mut self) -> _Pri43W {
                _Pri43W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 2"]
    pub struct Ipr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 2"]
    pub mod ipr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri80R {
            bits: u8,
        }
        impl Pri80R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri81R {
            bits: u8,
        }
        impl Pri81R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri82R {
            bits: u8,
        }
        impl Pri82R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri83R {
            bits: u8,
        }
        impl Pri83R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri80W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri80W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri81W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri81W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri82W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri82W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri83W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri83W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_80"]
            #[inline ( always )]
            pub fn pri_80(&self) -> Pri80R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri80R { bits }
            }
            #[doc = "Bits 14:15 - PRI_81"]
            #[inline ( always )]
            pub fn pri_81(&self) -> Pri81R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri81R { bits }
            }
            #[doc = "Bits 22:23 - PRI_82"]
            #[inline ( always )]
            pub fn pri_82(&self) -> Pri82R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri82R { bits }
            }
            #[doc = "Bits 30:31 - PRI_83"]
            #[inline ( always )]
            pub fn pri_83(&self) -> Pri83R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri83R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_80"]
            #[inline ( always )]
            pub fn pri_80(&mut self) -> _Pri80W {
                _Pri80W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_81"]
            #[inline ( always )]
            pub fn pri_81(&mut self) -> _Pri81W {
                _Pri81W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_82"]
            #[inline ( always )]
            pub fn pri_82(&mut self) -> _Pri82W {
                _Pri82W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_83"]
            #[inline ( always )]
            pub fn pri_83(&mut self) -> _Pri83W {
                _Pri83W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 3"]
    pub struct Ipr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 3"]
    pub mod ipr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri120R {
            bits: u8,
        }
        impl Pri120R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri121R {
            bits: u8,
        }
        impl Pri121R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri122R {
            bits: u8,
        }
        impl Pri122R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri123R {
            bits: u8,
        }
        impl Pri123R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri120W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri120W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri121W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri121W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri122W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri122W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri123W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri123W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_120"]
            #[inline ( always )]
            pub fn pri_120(&self) -> Pri120R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri120R { bits }
            }
            #[doc = "Bits 14:15 - PRI_121"]
            #[inline ( always )]
            pub fn pri_121(&self) -> Pri121R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri121R { bits }
            }
            #[doc = "Bits 22:23 - PRI_122"]
            #[inline ( always )]
            pub fn pri_122(&self) -> Pri122R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri122R { bits }
            }
            #[doc = "Bits 30:31 - PRI_123"]
            #[inline ( always )]
            pub fn pri_123(&self) -> Pri123R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri123R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_120"]
            #[inline ( always )]
            pub fn pri_120(&mut self) -> _Pri120W {
                _Pri120W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_121"]
            #[inline ( always )]
            pub fn pri_121(&mut self) -> _Pri121W {
                _Pri121W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_122"]
            #[inline ( always )]
            pub fn pri_122(&mut self) -> _Pri122W {
                _Pri122W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_123"]
            #[inline ( always )]
            pub fn pri_123(&mut self) -> _Pri123W {
                _Pri123W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 4"]
    pub struct Ipr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 4"]
    pub mod ipr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri160R {
            bits: u8,
        }
        impl Pri160R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri161R {
            bits: u8,
        }
        impl Pri161R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri162R {
            bits: u8,
        }
        impl Pri162R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri163R {
            bits: u8,
        }
        impl Pri163R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri160W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri160W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri161W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri161W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri162W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri162W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri163W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri163W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_160"]
            #[inline ( always )]
            pub fn pri_160(&self) -> Pri160R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri160R { bits }
            }
            #[doc = "Bits 14:15 - PRI_161"]
            #[inline ( always )]
            pub fn pri_161(&self) -> Pri161R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri161R { bits }
            }
            #[doc = "Bits 22:23 - PRI_162"]
            #[inline ( always )]
            pub fn pri_162(&self) -> Pri162R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri162R { bits }
            }
            #[doc = "Bits 30:31 - PRI_163"]
            #[inline ( always )]
            pub fn pri_163(&self) -> Pri163R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri163R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_160"]
            #[inline ( always )]
            pub fn pri_160(&mut self) -> _Pri160W {
                _Pri160W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_161"]
            #[inline ( always )]
            pub fn pri_161(&mut self) -> _Pri161W {
                _Pri161W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_162"]
            #[inline ( always )]
            pub fn pri_162(&mut self) -> _Pri162W {
                _Pri162W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_163"]
            #[inline ( always )]
            pub fn pri_163(&mut self) -> _Pri163W {
                _Pri163W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 5"]
    pub struct Ipr5 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 5"]
    pub mod ipr5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri200R {
            bits: u8,
        }
        impl Pri200R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri201R {
            bits: u8,
        }
        impl Pri201R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri202R {
            bits: u8,
        }
        impl Pri202R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri203R {
            bits: u8,
        }
        impl Pri203R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri200W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri200W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri201W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri201W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri202W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri202W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri203W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri203W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_200"]
            #[inline ( always )]
            pub fn pri_200(&self) -> Pri200R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri200R { bits }
            }
            #[doc = "Bits 14:15 - PRI_201"]
            #[inline ( always )]
            pub fn pri_201(&self) -> Pri201R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri201R { bits }
            }
            #[doc = "Bits 22:23 - PRI_202"]
            #[inline ( always )]
            pub fn pri_202(&self) -> Pri202R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri202R { bits }
            }
            #[doc = "Bits 30:31 - PRI_203"]
            #[inline ( always )]
            pub fn pri_203(&self) -> Pri203R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri203R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_200"]
            #[inline ( always )]
            pub fn pri_200(&mut self) -> _Pri200W {
                _Pri200W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_201"]
            #[inline ( always )]
            pub fn pri_201(&mut self) -> _Pri201W {
                _Pri201W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_202"]
            #[inline ( always )]
            pub fn pri_202(&mut self) -> _Pri202W {
                _Pri202W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_203"]
            #[inline ( always )]
            pub fn pri_203(&mut self) -> _Pri203W {
                _Pri203W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 6"]
    pub struct Ipr6 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 6"]
    pub mod ipr6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri240R {
            bits: u8,
        }
        impl Pri240R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri241R {
            bits: u8,
        }
        impl Pri241R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri242R {
            bits: u8,
        }
        impl Pri242R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri243R {
            bits: u8,
        }
        impl Pri243R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri240W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri240W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri241W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri241W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri242W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri242W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri243W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri243W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_240"]
            #[inline ( always )]
            pub fn pri_240(&self) -> Pri240R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri240R { bits }
            }
            #[doc = "Bits 14:15 - PRI_241"]
            #[inline ( always )]
            pub fn pri_241(&self) -> Pri241R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri241R { bits }
            }
            #[doc = "Bits 22:23 - PRI_242"]
            #[inline ( always )]
            pub fn pri_242(&self) -> Pri242R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri242R { bits }
            }
            #[doc = "Bits 30:31 - PRI_243"]
            #[inline ( always )]
            pub fn pri_243(&self) -> Pri243R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri243R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_240"]
            #[inline ( always )]
            pub fn pri_240(&mut self) -> _Pri240W {
                _Pri240W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_241"]
            #[inline ( always )]
            pub fn pri_241(&mut self) -> _Pri241W {
                _Pri241W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_242"]
            #[inline ( always )]
            pub fn pri_242(&mut self) -> _Pri242W {
                _Pri242W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_243"]
            #[inline ( always )]
            pub fn pri_243(&mut self) -> _Pri243W {
                _Pri243W { w: self }
            }
        }
    }
    #[doc = "Interrupt Priority Register 7"]
    pub struct Ipr7 {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Priority Register 7"]
    pub mod ipr7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ipr7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri280R {
            bits: u8,
        }
        impl Pri280R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri281R {
            bits: u8,
        }
        impl Pri281R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri282R {
            bits: u8,
        }
        impl Pri282R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pri283R {
            bits: u8,
        }
        impl Pri283R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri280W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri280W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri281W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri281W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri282W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri282W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pri283W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pri283W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:7 - PRI_280"]
            #[inline ( always )]
            pub fn pri_280(&self) -> Pri280R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri280R { bits }
            }
            #[doc = "Bits 14:15 - PRI_281"]
            #[inline ( always )]
            pub fn pri_281(&self) -> Pri281R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri281R { bits }
            }
            #[doc = "Bits 22:23 - PRI_282"]
            #[inline ( always )]
            pub fn pri_282(&self) -> Pri282R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri282R { bits }
            }
            #[doc = "Bits 30:31 - PRI_283"]
            #[inline ( always )]
            pub fn pri_283(&self) -> Pri283R {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pri283R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:7 - PRI_280"]
            #[inline ( always )]
            pub fn pri_280(&mut self) -> _Pri280W {
                _Pri280W { w: self }
            }
            #[doc = "Bits 14:15 - PRI_281"]
            #[inline ( always )]
            pub fn pri_281(&mut self) -> _Pri281W {
                _Pri281W { w: self }
            }
            #[doc = "Bits 22:23 - PRI_282"]
            #[inline ( always )]
            pub fn pri_282(&mut self) -> _Pri282W {
                _Pri282W { w: self }
            }
            #[doc = "Bits 30:31 - PRI_283"]
            #[inline ( always )]
            pub fn pri_283(&mut self) -> _Pri283W {
                _Pri283W { w: self }
            }
        }
    }
}
#[doc = "Nested Vectored Interrupt Controller"]
pub struct Nvic {
    register_block: nvic::RegisterBlock,
}
impl Deref for Nvic {
    type Target = nvic::RegisterBlock;
    fn deref(&self) -> &nvic::RegisterBlock {
        &self.register_block
    }
}
#[doc = "DMA controller"]
pub const DMA: Peripheral<Dma> = unsafe { Peripheral::new(1073872896) };
#[doc = "DMA controller"]
pub mod dma {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - DMA interrupt status register (DMA_ISR)"]
        pub isr: Isr,
        #[doc = "0x04 - DMA interrupt flag clear register (DMA_IFCR)"]
        pub ifcr: Ifcr,
        #[doc = "0x08 - DMA channel configuration register (DMA_CCR)"]
        pub ccr1: Ccr1,
        #[doc = "0x0c - DMA channel 1 number of data register"]
        pub cndtr1: Cndtr1,
        #[doc = "0x10 - DMA channel 1 peripheral address register"]
        pub cpar1: Cpar1,
        #[doc = "0x14 - DMA channel 1 memory address register"]
        pub cmar1: Cmar1,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - DMA channel configuration register (DMA_CCR)"]
        pub ccr2: Ccr2,
        #[doc = "0x20 - DMA channel 2 number of data register"]
        pub cndtr2: Cndtr2,
        #[doc = "0x24 - DMA channel 2 peripheral address register"]
        pub cpar2: Cpar2,
        #[doc = "0x28 - DMA channel 2 memory address register"]
        pub cmar2: Cmar2,
        _reserved1: [u8; 4usize],
        #[doc = "0x30 - DMA channel configuration register (DMA_CCR)"]
        pub ccr3: Ccr3,
        #[doc = "0x34 - DMA channel 3 number of data register"]
        pub cndtr3: Cndtr3,
        #[doc = "0x38 - DMA channel 3 peripheral address register"]
        pub cpar3: Cpar3,
        #[doc = "0x3c - DMA channel 3 memory address register"]
        pub cmar3: Cmar3,
        _reserved2: [u8; 4usize],
        #[doc = "0x44 - DMA channel configuration register (DMA_CCR)"]
        pub ccr4: Ccr4,
        #[doc = "0x48 - DMA channel 4 number of data register"]
        pub cndtr4: Cndtr4,
        #[doc = "0x4c - DMA channel 4 peripheral address register"]
        pub cpar4: Cpar4,
        #[doc = "0x50 - DMA channel 4 memory address register"]
        pub cmar4: Cmar4,
        _reserved3: [u8; 4usize],
        #[doc = "0x58 - DMA channel configuration register (DMA_CCR)"]
        pub ccr5: Ccr5,
        #[doc = "0x5c - DMA channel 5 number of data register"]
        pub cndtr5: Cndtr5,
        #[doc = "0x60 - DMA channel 5 peripheral address register"]
        pub cpar5: Cpar5,
        #[doc = "0x64 - DMA channel 5 memory address register"]
        pub cmar5: Cmar5,
        _reserved4: [u8; 4usize],
        #[doc = "0x6c - DMA channel configuration register (DMA_CCR)"]
        pub ccr6: Ccr6,
        #[doc = "0x70 - DMA channel 6 number of data register"]
        pub cndtr6: Cndtr6,
        #[doc = "0x74 - DMA channel 6 peripheral address register"]
        pub cpar6: Cpar6,
        #[doc = "0x78 - DMA channel 6 memory address register"]
        pub cmar6: Cmar6,
        _reserved5: [u8; 4usize],
        #[doc = "0x80 - DMA channel configuration register (DMA_CCR)"]
        pub ccr7: Ccr7,
        #[doc = "0x84 - DMA channel 7 number of data register"]
        pub cndtr7: Cndtr7,
        #[doc = "0x88 - DMA channel 7 peripheral address register"]
        pub cpar7: Cpar7,
        #[doc = "0x8c - DMA channel 7 memory address register"]
        pub cmar7: Cmar7,
    }
    #[doc = "DMA interrupt status register (DMA_ISR)"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA interrupt status register (DMA_ISR)"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif1R {
            bits: u8,
        }
        impl Gif1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif1R {
            bits: u8,
        }
        impl Tcif1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif1R {
            bits: u8,
        }
        impl Htif1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif1R {
            bits: u8,
        }
        impl Teif1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif2R {
            bits: u8,
        }
        impl Gif2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif2R {
            bits: u8,
        }
        impl Tcif2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif2R {
            bits: u8,
        }
        impl Htif2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif2R {
            bits: u8,
        }
        impl Teif2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif3R {
            bits: u8,
        }
        impl Gif3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif3R {
            bits: u8,
        }
        impl Tcif3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif3R {
            bits: u8,
        }
        impl Htif3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif3R {
            bits: u8,
        }
        impl Teif3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif4R {
            bits: u8,
        }
        impl Gif4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif4R {
            bits: u8,
        }
        impl Tcif4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif4R {
            bits: u8,
        }
        impl Htif4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif4R {
            bits: u8,
        }
        impl Teif4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif5R {
            bits: u8,
        }
        impl Gif5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif5R {
            bits: u8,
        }
        impl Tcif5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif5R {
            bits: u8,
        }
        impl Htif5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif5R {
            bits: u8,
        }
        impl Teif5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif6R {
            bits: u8,
        }
        impl Gif6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif6R {
            bits: u8,
        }
        impl Tcif6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif6R {
            bits: u8,
        }
        impl Htif6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif6R {
            bits: u8,
        }
        impl Teif6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Gif7R {
            bits: u8,
        }
        impl Gif7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tcif7R {
            bits: u8,
        }
        impl Tcif7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Htif7R {
            bits: u8,
        }
        impl Htif7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Teif7R {
            bits: u8,
        }
        impl Teif7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel 1 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif1(&self) -> Gif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif1R { bits }
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif1(&self) -> Tcif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif1R { bits }
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif1(&self) -> Htif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif1R { bits }
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif1(&self) -> Teif1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif1R { bits }
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif2(&self) -> Gif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif2R { bits }
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif2(&self) -> Tcif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif2R { bits }
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif2(&self) -> Htif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif2R { bits }
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif2(&self) -> Teif2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif2R { bits }
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif3(&self) -> Gif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif3R { bits }
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif3(&self) -> Tcif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif3R { bits }
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif3(&self) -> Htif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif3R { bits }
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif3(&self) -> Teif3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif3R { bits }
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif4(&self) -> Gif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif4R { bits }
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif4(&self) -> Tcif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif4R { bits }
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif4(&self) -> Htif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif4R { bits }
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif4(&self) -> Teif4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif4R { bits }
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif5(&self) -> Gif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif5R { bits }
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif5(&self) -> Tcif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif5R { bits }
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif5(&self) -> Htif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif5R { bits }
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif5(&self) -> Teif5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif5R { bits }
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif6(&self) -> Gif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif6R { bits }
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif6(&self) -> Tcif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif6R { bits }
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif6(&self) -> Htif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif6R { bits }
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif6(&self) -> Teif6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif6R { bits }
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt flag"]
            #[inline ( always )]
            pub fn gif7(&self) -> Gif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Gif7R { bits }
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete flag"]
            #[inline ( always )]
            pub fn tcif7(&self) -> Tcif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tcif7R { bits }
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer Complete flag"]
            #[inline ( always )]
            pub fn htif7(&self) -> Htif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Htif7R { bits }
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error flag"]
            #[inline ( always )]
            pub fn teif7(&self) -> Teif7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Teif7R { bits }
            }
        }
    }
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)"]
    pub struct Ifcr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA interrupt flag clear register (DMA_IFCR)"]
    pub mod ifcr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ifcr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cgif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cgif7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ctcif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ctcif7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chtif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chtif7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cteif7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cteif7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel 1 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif1(&mut self) -> _Cgif1W {
                _Cgif1W { w: self }
            }
            #[doc = "Bit 4 - Channel 2 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif2(&mut self) -> _Cgif2W {
                _Cgif2W { w: self }
            }
            #[doc = "Bit 8 - Channel 3 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif3(&mut self) -> _Cgif3W {
                _Cgif3W { w: self }
            }
            #[doc = "Bit 12 - Channel 4 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif4(&mut self) -> _Cgif4W {
                _Cgif4W { w: self }
            }
            #[doc = "Bit 16 - Channel 5 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif5(&mut self) -> _Cgif5W {
                _Cgif5W { w: self }
            }
            #[doc = "Bit 20 - Channel 6 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif6(&mut self) -> _Cgif6W {
                _Cgif6W { w: self }
            }
            #[doc = "Bit 24 - Channel 7 Global interrupt clear"]
            #[inline ( always )]
            pub fn cgif7(&mut self) -> _Cgif7W {
                _Cgif7W { w: self }
            }
            #[doc = "Bit 1 - Channel 1 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif1(&mut self) -> _Ctcif1W {
                _Ctcif1W { w: self }
            }
            #[doc = "Bit 5 - Channel 2 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif2(&mut self) -> _Ctcif2W {
                _Ctcif2W { w: self }
            }
            #[doc = "Bit 9 - Channel 3 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif3(&mut self) -> _Ctcif3W {
                _Ctcif3W { w: self }
            }
            #[doc = "Bit 13 - Channel 4 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif4(&mut self) -> _Ctcif4W {
                _Ctcif4W { w: self }
            }
            #[doc = "Bit 17 - Channel 5 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif5(&mut self) -> _Ctcif5W {
                _Ctcif5W { w: self }
            }
            #[doc = "Bit 21 - Channel 6 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif6(&mut self) -> _Ctcif6W {
                _Ctcif6W { w: self }
            }
            #[doc = "Bit 25 - Channel 7 Transfer Complete clear"]
            #[inline ( always )]
            pub fn ctcif7(&mut self) -> _Ctcif7W {
                _Ctcif7W { w: self }
            }
            #[doc = "Bit 2 - Channel 1 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif1(&mut self) -> _Chtif1W {
                _Chtif1W { w: self }
            }
            #[doc = "Bit 6 - Channel 2 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif2(&mut self) -> _Chtif2W {
                _Chtif2W { w: self }
            }
            #[doc = "Bit 10 - Channel 3 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif3(&mut self) -> _Chtif3W {
                _Chtif3W { w: self }
            }
            #[doc = "Bit 14 - Channel 4 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif4(&mut self) -> _Chtif4W {
                _Chtif4W { w: self }
            }
            #[doc = "Bit 18 - Channel 5 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif5(&mut self) -> _Chtif5W {
                _Chtif5W { w: self }
            }
            #[doc = "Bit 22 - Channel 6 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif6(&mut self) -> _Chtif6W {
                _Chtif6W { w: self }
            }
            #[doc = "Bit 26 - Channel 7 Half Transfer clear"]
            #[inline ( always )]
            pub fn chtif7(&mut self) -> _Chtif7W {
                _Chtif7W { w: self }
            }
            #[doc = "Bit 3 - Channel 1 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif1(&mut self) -> _Cteif1W {
                _Cteif1W { w: self }
            }
            #[doc = "Bit 7 - Channel 2 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif2(&mut self) -> _Cteif2W {
                _Cteif2W { w: self }
            }
            #[doc = "Bit 11 - Channel 3 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif3(&mut self) -> _Cteif3W {
                _Cteif3W { w: self }
            }
            #[doc = "Bit 15 - Channel 4 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif4(&mut self) -> _Cteif4W {
                _Cteif4W { w: self }
            }
            #[doc = "Bit 19 - Channel 5 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif5(&mut self) -> _Cteif5W {
                _Cteif5W { w: self }
            }
            #[doc = "Bit 23 - Channel 6 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif6(&mut self) -> _Cteif6W {
                _Cteif6W { w: self }
            }
            #[doc = "Bit 27 - Channel 7 Transfer Error clear"]
            #[inline ( always )]
            pub fn cteif7(&mut self) -> _Cteif7W {
                _Cteif7W { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 1 number of data register"]
    pub struct Cndtr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 1 number of data register"]
    pub mod cndtr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 1 peripheral address register"]
    pub struct Cpar1 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 1 peripheral address register"]
    pub mod cpar1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 1 memory address register"]
    pub struct Cmar1 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 1 memory address register"]
    pub mod cmar1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 2 number of data register"]
    pub struct Cndtr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 2 number of data register"]
    pub mod cndtr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 2 peripheral address register"]
    pub struct Cpar2 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 2 peripheral address register"]
    pub mod cpar2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 2 memory address register"]
    pub struct Cmar2 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 2 memory address register"]
    pub mod cmar2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 3 number of data register"]
    pub struct Cndtr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 3 number of data register"]
    pub mod cndtr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 3 peripheral address register"]
    pub struct Cpar3 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 3 peripheral address register"]
    pub mod cpar3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 3 memory address register"]
    pub struct Cmar3 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 3 memory address register"]
    pub mod cmar3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 4 number of data register"]
    pub struct Cndtr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 4 number of data register"]
    pub mod cndtr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 4 peripheral address register"]
    pub struct Cpar4 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 4 peripheral address register"]
    pub mod cpar4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 4 memory address register"]
    pub struct Cmar4 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 4 memory address register"]
    pub mod cmar4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr5 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 5 number of data register"]
    pub struct Cndtr5 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 5 number of data register"]
    pub mod cndtr5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 5 peripheral address register"]
    pub struct Cpar5 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 5 peripheral address register"]
    pub mod cpar5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 5 memory address register"]
    pub struct Cmar5 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 5 memory address register"]
    pub mod cmar5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr6 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 6 number of data register"]
    pub struct Cndtr6 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 6 number of data register"]
    pub mod cndtr6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 6 peripheral address register"]
    pub struct Cpar6 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 6 peripheral address register"]
    pub mod cpar6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 6 memory address register"]
    pub struct Cmar6 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 6 memory address register"]
    pub mod cmar6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub struct Ccr7 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel configuration register (DMA_CCR)"]
    pub mod ccr7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EnR {
            bits: u8,
        }
        impl EnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtieR {
            bits: u8,
        }
        impl HtieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeieR {
            bits: u8,
        }
        impl TeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DirR {
            bits: u8,
        }
        impl DirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CircR {
            bits: u8,
        }
        impl CircR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PincR {
            bits: u8,
        }
        impl PincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MincR {
            bits: u8,
        }
        impl MincR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsizeR {
            bits: u8,
        }
        impl PsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsizeR {
            bits: u8,
        }
        impl MsizeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PlR {
            bits: u8,
        }
        impl PlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Mem2memR {
            bits: u8,
        }
        impl Mem2memR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CircW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CircW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MincW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MincW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsizeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsizeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Mem2memW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Mem2memW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&self) -> EnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EnR { bits }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&self) -> HtieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtieR { bits }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&self) -> TeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeieR { bits }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&self) -> DirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DirR { bits }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&self) -> CircR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CircR { bits }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&self) -> PincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PincR { bits }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&self) -> MincR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MincR { bits }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&self) -> PsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsizeR { bits }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&self) -> MsizeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsizeR { bits }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&self) -> PlR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PlR { bits }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&self) -> Mem2memR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Mem2memR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Channel enable"]
            #[inline ( always )]
            pub fn en(&mut self) -> _EnW {
                _EnW { w: self }
            }
            #[doc = "Bit 1 - Transfer complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 2 - Half Transfer interrupt enable"]
            #[inline ( always )]
            pub fn htie(&mut self) -> _HtieW {
                _HtieW { w: self }
            }
            #[doc = "Bit 3 - Transfer error interrupt enable"]
            #[inline ( always )]
            pub fn teie(&mut self) -> _TeieW {
                _TeieW { w: self }
            }
            #[doc = "Bit 4 - Data transfer direction"]
            #[inline ( always )]
            pub fn dir(&mut self) -> _DirW {
                _DirW { w: self }
            }
            #[doc = "Bit 5 - Circular mode"]
            #[inline ( always )]
            pub fn circ(&mut self) -> _CircW {
                _CircW { w: self }
            }
            #[doc = "Bit 6 - Peripheral increment mode"]
            #[inline ( always )]
            pub fn pinc(&mut self) -> _PincW {
                _PincW { w: self }
            }
            #[doc = "Bit 7 - Memory increment mode"]
            #[inline ( always )]
            pub fn minc(&mut self) -> _MincW {
                _MincW { w: self }
            }
            #[doc = "Bits 8:9 - Peripheral size"]
            #[inline ( always )]
            pub fn psize(&mut self) -> _PsizeW {
                _PsizeW { w: self }
            }
            #[doc = "Bits 10:11 - Memory size"]
            #[inline ( always )]
            pub fn msize(&mut self) -> _MsizeW {
                _MsizeW { w: self }
            }
            #[doc = "Bits 12:13 - Channel Priority level"]
            #[inline ( always )]
            pub fn pl(&mut self) -> _PlW {
                _PlW { w: self }
            }
            #[doc = "Bit 14 - Memory to memory mode"]
            #[inline ( always )]
            pub fn mem2mem(&mut self) -> _Mem2memW {
                _Mem2memW { w: self }
            }
        }
    }
    #[doc = "DMA channel 7 number of data register"]
    pub struct Cndtr7 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 7 number of data register"]
    pub mod cndtr7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cndtr7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct NdtR {
            bits: u16,
        }
        impl NdtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NdtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NdtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&self) -> NdtR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                NdtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Number of data to transfer"]
            #[inline ( always )]
            pub fn ndt(&mut self) -> _NdtW {
                _NdtW { w: self }
            }
        }
    }
    #[doc = "DMA channel 7 peripheral address register"]
    pub struct Cpar7 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 7 peripheral address register"]
    pub mod cpar7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cpar7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PaR {
            bits: u32,
        }
        impl PaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&self) -> PaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Peripheral address"]
            #[inline ( always )]
            pub fn pa(&mut self) -> _PaW {
                _PaW { w: self }
            }
        }
    }
    #[doc = "DMA channel 7 memory address register"]
    pub struct Cmar7 {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA channel 7 memory address register"]
    pub mod cmar7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cmar7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaR {
            bits: u32,
        }
        impl MaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&self) -> MaR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Memory address"]
            #[inline ( always )]
            pub fn ma(&mut self) -> _MaW {
                _MaW { w: self }
            }
        }
    }
}
#[doc = "DMA controller"]
pub struct Dma {
    register_block: dma::RegisterBlock,
}
impl Deref for Dma {
    type Target = dma::RegisterBlock;
    fn deref(&self) -> &dma::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Reset and clock control"]
pub const RCC: Peripheral<Rcc> = unsafe { Peripheral::new(1073876992) };
#[doc = "Reset and clock control"]
pub mod rcc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Clock control register"]
        pub cr: Cr,
        #[doc = "0x04 - Clock configuration register (RCC_CFGR)"]
        pub cfgr: Cfgr,
        #[doc = "0x08 - Clock interrupt register (RCC_CIR)"]
        pub cir: Cir,
        #[doc = "0x0c - APB2 peripheral reset register (RCC_APB2RSTR)"]
        pub apb2rstr: Apb2rstr,
        #[doc = "0x10 - APB1 peripheral reset register (RCC_APB1RSTR)"]
        pub apb1rstr: Apb1rstr,
        #[doc = "0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)"]
        pub ahbenr: Ahbenr,
        #[doc = "0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)"]
        pub apb2enr: Apb2enr,
        #[doc = "0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)"]
        pub apb1enr: Apb1enr,
        #[doc = "0x20 - Backup domain control register (RCC_BDCR)"]
        pub bdcr: Bdcr,
        #[doc = "0x24 - Control/status register (RCC_CSR)"]
        pub csr: Csr,
        #[doc = "0x28 - AHB peripheral reset register"]
        pub ahbrstr: Ahbrstr,
        #[doc = "0x2c - Clock configuration register 2"]
        pub cfgr2: Cfgr2,
        #[doc = "0x30 - Clock configuration register 3"]
        pub cfgr3: Cfgr3,
        #[doc = "0x34 - Clock control register 2"]
        pub cr2: Cr2,
    }
    #[doc = "Clock control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `HSION`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum HsionR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl HsionR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    HsionR::Off => 0,
                    HsionR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> HsionR {
                match bits {
                    0 => HsionR::Off,
                    1 => HsionR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == HsionR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == HsionR::On
            }
        }
        #[doc = "Possible values of the field `HSIRDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum HsirdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl HsirdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    HsirdyR::NotReady => 0,
                    HsirdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> HsirdyR {
                match bits {
                    0 => HsirdyR::NotReady,
                    1 => HsirdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == HsirdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == HsirdyR::Ready
            }
        }
        #[doc = r" Value of the field"]
        pub struct HsitrimR {
            bits: u8,
        }
        impl HsitrimR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HsicalR {
            bits: u8,
        }
        impl HsicalR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HSEON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum HseonR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl HseonR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    HseonR::Off => 0,
                    HseonR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> HseonR {
                match bits {
                    0 => HseonR::Off,
                    1 => HseonR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == HseonR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == HseonR::On
            }
        }
        #[doc = "Possible values of the field `HSERDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum HserdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl HserdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    HserdyR::NotReady => 0,
                    HserdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> HserdyR {
                match bits {
                    0 => HserdyR::NotReady,
                    1 => HserdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == HserdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == HserdyR::Ready
            }
        }
        #[doc = "Possible values of the field `HSEBYP`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum HsebypR {
            #[doc = "Not bypassed."]
            NotBypassed,
            #[doc = "Bypassed."]
            Bypassed,
        }
        impl HsebypR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    HsebypR::NotBypassed => 0,
                    HsebypR::Bypassed => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> HsebypR {
                match bits {
                    0 => HsebypR::NotBypassed,
                    1 => HsebypR::Bypassed,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotBypassed`"]
            #[inline ( always )]
            pub fn is_not_bypassed(&self) -> bool {
                *self == HsebypR::NotBypassed
            }
            #[doc = "Checks if the value of the field is `Bypassed`"]
            #[inline ( always )]
            pub fn is_bypassed(&self) -> bool {
                *self == HsebypR::Bypassed
            }
        }
        #[doc = "Possible values of the field `CSSON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CssonR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl CssonR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CssonR::Off => 0,
                    CssonR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CssonR {
                match bits {
                    0 => CssonR::Off,
                    1 => CssonR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == CssonR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == CssonR::On
            }
        }
        #[doc = "Possible values of the field `PLLON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PllonR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl PllonR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PllonR::Off => 0,
                    PllonR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PllonR {
                match bits {
                    0 => PllonR::Off,
                    1 => PllonR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == PllonR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == PllonR::On
            }
        }
        #[doc = "Possible values of the field `PLLRDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PllrdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl PllrdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PllrdyR::NotReady => 0,
                    PllrdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PllrdyR {
                match bits {
                    0 => PllrdyR::NotReady,
                    1 => PllrdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == PllrdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == PllrdyR::Ready
            }
        }
        #[doc = "Values that can be written to the field `HSION`"]
        pub enum HsionW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl HsionW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HsionW::Off => 0,
                    HsionW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HsionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsionW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: HsionW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(HsionW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(HsionW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HsitrimW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsitrimW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSEON`"]
        pub enum HseonW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl HseonW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HseonW::Off => 0,
                    HseonW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HseonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HseonW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: HseonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(HseonW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(HseonW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HSEBYP`"]
        pub enum HsebypW {
            #[doc = "Not bypassed."]
            NotBypassed,
            #[doc = "Bypassed."]
            Bypassed,
        }
        impl HsebypW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HsebypW::NotBypassed => 0,
                    HsebypW::Bypassed => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HsebypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsebypW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: HsebypW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Not bypassed."]
            #[inline ( always )]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HsebypW::NotBypassed)
            }
            #[doc = "Bypassed."]
            #[inline ( always )]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HsebypW::Bypassed)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CSSON`"]
        pub enum CssonW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl CssonW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CssonW::Off => 0,
                    CssonW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CssonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CssonW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CssonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(CssonW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(CssonW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLON`"]
        pub enum PllonW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl PllonW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PllonW::Off => 0,
                    PllonW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllonW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PllonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(PllonW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(PllonW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline ( always )]
            pub fn hsion(&self) -> HsionR {
                HsionR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 1 - Internal High Speed clock ready flag"]
            #[inline ( always )]
            pub fn hsirdy(&self) -> HsirdyR {
                HsirdyR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline ( always )]
            pub fn hsitrim(&self) -> HsitrimR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsitrimR { bits }
            }
            #[doc = "Bits 8:15 - Internal High Speed clock Calibration"]
            #[inline ( always )]
            pub fn hsical(&self) -> HsicalR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsicalR { bits }
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline ( always )]
            pub fn hseon(&self) -> HseonR {
                HseonR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 16;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 17 - External High Speed clock ready flag"]
            #[inline ( always )]
            pub fn hserdy(&self) -> HserdyR {
                HserdyR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 17;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline ( always )]
            pub fn hsebyp(&self) -> HsebypR {
                HsebypR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 18;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline ( always )]
            pub fn csson(&self) -> CssonR {
                CssonR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 19;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline ( always )]
            pub fn pllon(&self) -> PllonR {
                PllonR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 24;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 25 - PLL clock ready flag"]
            #[inline ( always )]
            pub fn pllrdy(&self) -> PllrdyR {
                PllrdyR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 25;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 131 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Internal High Speed clock enable"]
            #[inline ( always )]
            pub fn hsion(&mut self) -> _HsionW {
                _HsionW { w: self }
            }
            #[doc = "Bits 3:7 - Internal High Speed clock trimming"]
            #[inline ( always )]
            pub fn hsitrim(&mut self) -> _HsitrimW {
                _HsitrimW { w: self }
            }
            #[doc = "Bit 16 - External High Speed clock enable"]
            #[inline ( always )]
            pub fn hseon(&mut self) -> _HseonW {
                _HseonW { w: self }
            }
            #[doc = "Bit 18 - External High Speed clock Bypass"]
            #[inline ( always )]
            pub fn hsebyp(&mut self) -> _HsebypW {
                _HsebypW { w: self }
            }
            #[doc = "Bit 19 - Clock Security System enable"]
            #[inline ( always )]
            pub fn csson(&mut self) -> _CssonW {
                _CssonW { w: self }
            }
            #[doc = "Bit 24 - PLL enable"]
            #[inline ( always )]
            pub fn pllon(&mut self) -> _PllonW {
                _PllonW { w: self }
            }
        }
    }
    #[doc = "Clock configuration register (RCC_CFGR)"]
    pub struct Cfgr {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock configuration register (RCC_CFGR)"]
    pub mod cfgr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct SwR {
            bits: u8,
        }
        impl SwR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SwsR {
            bits: u8,
        }
        impl SwsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HpreR {
            bits: u8,
        }
        impl HpreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PpreR {
            bits: u8,
        }
        impl PpreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdcpreR {
            bits: u8,
        }
        impl AdcpreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PllsrcR {
            bits: u8,
        }
        impl PllsrcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PllxtpreR {
            bits: u8,
        }
        impl PllxtpreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PllmulR {
            bits: u8,
        }
        impl PllmulR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct McoR {
            bits: u8,
        }
        impl McoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SwW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HpreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PpreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcpreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllsrcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllsrcW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllxtpreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllxtpreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllmulW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllmulW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _McoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McoW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline ( always )]
            pub fn sw(&self) -> SwR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwR { bits }
            }
            #[doc = "Bits 2:3 - System Clock Switch Status"]
            #[inline ( always )]
            pub fn sws(&self) -> SwsR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwsR { bits }
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline ( always )]
            pub fn hpre(&self) -> HpreR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HpreR { bits }
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline ( always )]
            pub fn ppre(&self) -> PpreR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PpreR { bits }
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline ( always )]
            pub fn adcpre(&self) -> AdcpreR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdcpreR { bits }
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline ( always )]
            pub fn pllsrc(&self) -> PllsrcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllsrcR { bits }
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline ( always )]
            pub fn pllxtpre(&self) -> PllxtpreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllxtpreR { bits }
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline ( always )]
            pub fn pllmul(&self) -> PllmulR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllmulR { bits }
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline ( always )]
            pub fn mco(&self) -> McoR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                McoR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System clock Switch"]
            #[inline ( always )]
            pub fn sw(&mut self) -> _SwW {
                _SwW { w: self }
            }
            #[doc = "Bits 4:7 - AHB prescaler"]
            #[inline ( always )]
            pub fn hpre(&mut self) -> _HpreW {
                _HpreW { w: self }
            }
            #[doc = "Bits 8:10 - APB Low speed prescaler (APB1)"]
            #[inline ( always )]
            pub fn ppre(&mut self) -> _PpreW {
                _PpreW { w: self }
            }
            #[doc = "Bits 14:15 - ADC prescaler"]
            #[inline ( always )]
            pub fn adcpre(&mut self) -> _AdcpreW {
                _AdcpreW { w: self }
            }
            #[doc = "Bit 16 - PLL entry clock source"]
            #[inline ( always )]
            pub fn pllsrc(&mut self) -> _PllsrcW {
                _PllsrcW { w: self }
            }
            #[doc = "Bit 17 - HSE divider for PLL entry"]
            #[inline ( always )]
            pub fn pllxtpre(&mut self) -> _PllxtpreW {
                _PllxtpreW { w: self }
            }
            #[doc = "Bits 18:21 - PLL Multiplication Factor"]
            #[inline ( always )]
            pub fn pllmul(&mut self) -> _PllmulW {
                _PllmulW { w: self }
            }
            #[doc = "Bits 24:26 - Microcontroller clock output"]
            #[inline ( always )]
            pub fn mco(&mut self) -> _McoW {
                _McoW { w: self }
            }
        }
    }
    #[doc = "Clock interrupt register (RCC_CIR)"]
    pub struct Cir {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock interrupt register (RCC_CIR)"]
    pub mod cir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cir {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct LsirdyfR {
            bits: u8,
        }
        impl LsirdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LserdyfR {
            bits: u8,
        }
        impl LserdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HsirdyfR {
            bits: u8,
        }
        impl HsirdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HserdyfR {
            bits: u8,
        }
        impl HserdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PllrdyfR {
            bits: u8,
        }
        impl PllrdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Hsi14rdyfR {
            bits: u8,
        }
        impl Hsi14rdyfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CssfR {
            bits: u8,
        }
        impl CssfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LsirdyieR {
            bits: u8,
        }
        impl LsirdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LserdyieR {
            bits: u8,
        }
        impl LserdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HsirdyieR {
            bits: u8,
        }
        impl HsirdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HserdyieR {
            bits: u8,
        }
        impl HserdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PllrdyieR {
            bits: u8,
        }
        impl PllrdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Hsi14rdyeR {
            bits: u8,
        }
        impl Hsi14rdyeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsirdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsirdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LserdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LserdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HsirdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsirdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HserdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HserdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllrdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllrdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Hsi14rdyeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hsi14rdyeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsirdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsirdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LserdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LserdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HsirdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HsirdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HserdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HserdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PllrdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PllrdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Hsi14rdycW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hsi14rdycW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CsscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CsscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - LSI Ready Interrupt flag"]
            #[inline ( always )]
            pub fn lsirdyf(&self) -> LsirdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsirdyfR { bits }
            }
            #[doc = "Bit 1 - LSE Ready Interrupt flag"]
            #[inline ( always )]
            pub fn lserdyf(&self) -> LserdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LserdyfR { bits }
            }
            #[doc = "Bit 2 - HSI Ready Interrupt flag"]
            #[inline ( always )]
            pub fn hsirdyf(&self) -> HsirdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsirdyfR { bits }
            }
            #[doc = "Bit 3 - HSE Ready Interrupt flag"]
            #[inline ( always )]
            pub fn hserdyf(&self) -> HserdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HserdyfR { bits }
            }
            #[doc = "Bit 4 - PLL Ready Interrupt flag"]
            #[inline ( always )]
            pub fn pllrdyf(&self) -> PllrdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllrdyfR { bits }
            }
            #[doc = "Bit 5 - HSI14 ready interrupt flag"]
            #[inline ( always )]
            pub fn hsi14rdyf(&self) -> Hsi14rdyfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Hsi14rdyfR { bits }
            }
            #[doc = "Bit 7 - Clock Security System Interrupt flag"]
            #[inline ( always )]
            pub fn cssf(&self) -> CssfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CssfR { bits }
            }
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn lsirdyie(&self) -> LsirdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsirdyieR { bits }
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn lserdyie(&self) -> LserdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LserdyieR { bits }
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn hsirdyie(&self) -> HsirdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HsirdyieR { bits }
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn hserdyie(&self) -> HserdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HserdyieR { bits }
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn pllrdyie(&self) -> PllrdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PllrdyieR { bits }
            }
            #[doc = "Bit 13 - HSI14 ready interrupt enable"]
            #[inline ( always )]
            pub fn hsi14rdye(&self) -> Hsi14rdyeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Hsi14rdyeR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - LSI Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn lsirdyie(&mut self) -> _LsirdyieW {
                _LsirdyieW { w: self }
            }
            #[doc = "Bit 9 - LSE Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn lserdyie(&mut self) -> _LserdyieW {
                _LserdyieW { w: self }
            }
            #[doc = "Bit 10 - HSI Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn hsirdyie(&mut self) -> _HsirdyieW {
                _HsirdyieW { w: self }
            }
            #[doc = "Bit 11 - HSE Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn hserdyie(&mut self) -> _HserdyieW {
                _HserdyieW { w: self }
            }
            #[doc = "Bit 12 - PLL Ready Interrupt Enable"]
            #[inline ( always )]
            pub fn pllrdyie(&mut self) -> _PllrdyieW {
                _PllrdyieW { w: self }
            }
            #[doc = "Bit 13 - HSI14 ready interrupt enable"]
            #[inline ( always )]
            pub fn hsi14rdye(&mut self) -> _Hsi14rdyeW {
                _Hsi14rdyeW { w: self }
            }
            #[doc = "Bit 16 - LSI Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn lsirdyc(&mut self) -> _LsirdycW {
                _LsirdycW { w: self }
            }
            #[doc = "Bit 17 - LSE Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn lserdyc(&mut self) -> _LserdycW {
                _LserdycW { w: self }
            }
            #[doc = "Bit 18 - HSI Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn hsirdyc(&mut self) -> _HsirdycW {
                _HsirdycW { w: self }
            }
            #[doc = "Bit 19 - HSE Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn hserdyc(&mut self) -> _HserdycW {
                _HserdycW { w: self }
            }
            #[doc = "Bit 20 - PLL Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn pllrdyc(&mut self) -> _PllrdycW {
                _PllrdycW { w: self }
            }
            #[doc = "Bit 21 - HSI 14 MHz Ready Interrupt Clear"]
            #[inline ( always )]
            pub fn hsi14rdyc(&mut self) -> _Hsi14rdycW {
                _Hsi14rdycW { w: self }
            }
            #[doc = "Bit 23 - Clock security system interrupt clear"]
            #[inline ( always )]
            pub fn cssc(&mut self) -> _CsscW {
                _CsscW { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"]
    pub struct Apb2rstr {
        register: VolatileCell<u32>,
    }
    #[doc = "APB2 peripheral reset register (RCC_APB2RSTR)"]
    pub mod apb2rstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apb2rstr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `SYSCFGRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SyscfgrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl SyscfgrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SyscfgrstR::NoEffect => 0,
                    SyscfgrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SyscfgrstR {
                match bits {
                    0 => SyscfgrstR::NoEffect,
                    1 => SyscfgrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == SyscfgrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == SyscfgrstR::Reset
            }
        }
        #[doc = "Possible values of the field `ADCRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AdcrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl AdcrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AdcrstR::NoEffect => 0,
                    AdcrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AdcrstR {
                match bits {
                    0 => AdcrstR::NoEffect,
                    1 => AdcrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == AdcrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == AdcrstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM1RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim1rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim1rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim1rstR::NoEffect => 0,
                    Tim1rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim1rstR {
                match bits {
                    0 => Tim1rstR::NoEffect,
                    1 => Tim1rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim1rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim1rstR::Reset
            }
        }
        #[doc = "Possible values of the field `SPI1RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Spi1rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Spi1rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi1rstR::NoEffect => 0,
                    Spi1rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Spi1rstR {
                match bits {
                    0 => Spi1rstR::NoEffect,
                    1 => Spi1rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Spi1rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Spi1rstR::Reset
            }
        }
        #[doc = "Possible values of the field `USART1RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Usart1rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Usart1rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Usart1rstR::NoEffect => 0,
                    Usart1rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Usart1rstR {
                match bits {
                    0 => Usart1rstR::NoEffect,
                    1 => Usart1rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Usart1rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Usart1rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM15RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim15rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim15rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim15rstR::NoEffect => 0,
                    Tim15rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim15rstR {
                match bits {
                    0 => Tim15rstR::NoEffect,
                    1 => Tim15rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim15rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim15rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM16RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim16rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim16rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim16rstR::NoEffect => 0,
                    Tim16rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim16rstR {
                match bits {
                    0 => Tim16rstR::NoEffect,
                    1 => Tim16rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim16rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim16rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM17RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim17rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim17rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim17rstR::NoEffect => 0,
                    Tim17rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim17rstR {
                match bits {
                    0 => Tim17rstR::NoEffect,
                    1 => Tim17rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim17rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim17rstR::Reset
            }
        }
        #[doc = "Possible values of the field `DBGMCURST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DbgmcurstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl DbgmcurstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DbgmcurstR::NoEffect => 0,
                    DbgmcurstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DbgmcurstR {
                match bits {
                    0 => DbgmcurstR::NoEffect,
                    1 => DbgmcurstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == DbgmcurstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == DbgmcurstR::Reset
            }
        }
        #[doc = "Values that can be written to the field `SYSCFGRST`"]
        pub enum SyscfgrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl SyscfgrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SyscfgrstW::NoEffect => 0,
                    SyscfgrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SyscfgrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SyscfgrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SyscfgrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(SyscfgrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(SyscfgrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCRST`"]
        pub enum AdcrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl AdcrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AdcrstW::NoEffect => 0,
                    AdcrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AdcrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(AdcrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(AdcrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM1RST`"]
        pub enum Tim1rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim1rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim1rstW::NoEffect => 0,
                    Tim1rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim1rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim1rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim1rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1RST`"]
        pub enum Spi1rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Spi1rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi1rstW::NoEffect => 0,
                    Spi1rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Spi1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Spi1rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Spi1rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Spi1rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART1RST`"]
        pub enum Usart1rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Usart1rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Usart1rstW::NoEffect => 0,
                    Usart1rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Usart1rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Usart1rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Usart1rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM15RST`"]
        pub enum Tim15rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim15rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim15rstW::NoEffect => 0,
                    Tim15rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim15rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim15rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim15rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim15rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim15rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM16RST`"]
        pub enum Tim16rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim16rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim16rstW::NoEffect => 0,
                    Tim16rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim16rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim16rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim16rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim16rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM17RST`"]
        pub enum Tim17rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim17rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim17rstW::NoEffect => 0,
                    Tim17rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim17rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim17rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim17rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim17rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DBGMCURST`"]
        pub enum DbgmcurstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl DbgmcurstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DbgmcurstW::NoEffect => 0,
                    DbgmcurstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgmcurstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgmcurstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DbgmcurstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(DbgmcurstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(DbgmcurstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SYSCFG and COMP reset"]
            #[inline ( always )]
            pub fn syscfgrst(&self) -> SyscfgrstR {
                SyscfgrstR::_from({
                                      const MASK: u8 = 1;
                                      const OFFSET: u8 = 0;
                                      ((self.bits >> OFFSET) & MASK as u32) as
                                      u8
                                  })
            }
            #[doc = "Bit 9 - ADC interface reset"]
            #[inline ( always )]
            pub fn adcrst(&self) -> AdcrstR {
                AdcrstR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 9;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline ( always )]
            pub fn tim1rst(&self) -> Tim1rstR {
                Tim1rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline ( always )]
            pub fn spi1rst(&self) -> Spi1rstR {
                Spi1rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 12;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline ( always )]
            pub fn usart1rst(&self) -> Usart1rstR {
                Usart1rstR::_from({
                                      const MASK: u8 = 1;
                                      const OFFSET: u8 = 14;
                                      ((self.bits >> OFFSET) & MASK as u32) as
                                      u8
                                  })
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline ( always )]
            pub fn tim15rst(&self) -> Tim15rstR {
                Tim15rstR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 16;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline ( always )]
            pub fn tim16rst(&self) -> Tim16rstR {
                Tim16rstR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 17;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline ( always )]
            pub fn tim17rst(&self) -> Tim17rstR {
                Tim17rstR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 18;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 22 - Debug MCU reset"]
            #[inline ( always )]
            pub fn dbgmcurst(&self) -> DbgmcurstR {
                DbgmcurstR::_from({
                                      const MASK: u8 = 1;
                                      const OFFSET: u8 = 22;
                                      ((self.bits >> OFFSET) & MASK as u32) as
                                      u8
                                  })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SYSCFG and COMP reset"]
            #[inline ( always )]
            pub fn syscfgrst(&mut self) -> _SyscfgrstW {
                _SyscfgrstW { w: self }
            }
            #[doc = "Bit 9 - ADC interface reset"]
            #[inline ( always )]
            pub fn adcrst(&mut self) -> _AdcrstW {
                _AdcrstW { w: self }
            }
            #[doc = "Bit 11 - TIM1 timer reset"]
            #[inline ( always )]
            pub fn tim1rst(&mut self) -> _Tim1rstW {
                _Tim1rstW { w: self }
            }
            #[doc = "Bit 12 - SPI 1 reset"]
            #[inline ( always )]
            pub fn spi1rst(&mut self) -> _Spi1rstW {
                _Spi1rstW { w: self }
            }
            #[doc = "Bit 14 - USART1 reset"]
            #[inline ( always )]
            pub fn usart1rst(&mut self) -> _Usart1rstW {
                _Usart1rstW { w: self }
            }
            #[doc = "Bit 16 - TIM15 timer reset"]
            #[inline ( always )]
            pub fn tim15rst(&mut self) -> _Tim15rstW {
                _Tim15rstW { w: self }
            }
            #[doc = "Bit 17 - TIM16 timer reset"]
            #[inline ( always )]
            pub fn tim16rst(&mut self) -> _Tim16rstW {
                _Tim16rstW { w: self }
            }
            #[doc = "Bit 18 - TIM17 timer reset"]
            #[inline ( always )]
            pub fn tim17rst(&mut self) -> _Tim17rstW {
                _Tim17rstW { w: self }
            }
            #[doc = "Bit 22 - Debug MCU reset"]
            #[inline ( always )]
            pub fn dbgmcurst(&mut self) -> _DbgmcurstW {
                _DbgmcurstW { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"]
    pub struct Apb1rstr {
        register: VolatileCell<u32>,
    }
    #[doc = "APB1 peripheral reset register (RCC_APB1RSTR)"]
    pub mod apb1rstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apb1rstr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `TIM2RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim2rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim2rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim2rstR::NoEffect => 0,
                    Tim2rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim2rstR {
                match bits {
                    0 => Tim2rstR::NoEffect,
                    1 => Tim2rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim2rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim2rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM3RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim3rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim3rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim3rstR::NoEffect => 0,
                    Tim3rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim3rstR {
                match bits {
                    0 => Tim3rstR::NoEffect,
                    1 => Tim3rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim3rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim3rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM6RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim6rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim6rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim6rstR::NoEffect => 0,
                    Tim6rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim6rstR {
                match bits {
                    0 => Tim6rstR::NoEffect,
                    1 => Tim6rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim6rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim6rstR::Reset
            }
        }
        #[doc = "Possible values of the field `TIM14RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim14rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim14rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim14rstR::NoEffect => 0,
                    Tim14rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim14rstR {
                match bits {
                    0 => Tim14rstR::NoEffect,
                    1 => Tim14rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Tim14rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Tim14rstR::Reset
            }
        }
        #[doc = "Possible values of the field `WWDGRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum WwdgrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl WwdgrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    WwdgrstR::NoEffect => 0,
                    WwdgrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> WwdgrstR {
                match bits {
                    0 => WwdgrstR::NoEffect,
                    1 => WwdgrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == WwdgrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == WwdgrstR::Reset
            }
        }
        #[doc = "Possible values of the field `SPI2RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Spi2rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Spi2rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi2rstR::NoEffect => 0,
                    Spi2rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Spi2rstR {
                match bits {
                    0 => Spi2rstR::NoEffect,
                    1 => Spi2rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Spi2rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Spi2rstR::Reset
            }
        }
        #[doc = "Possible values of the field `USART2RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Usart2rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Usart2rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Usart2rstR::NoEffect => 0,
                    Usart2rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Usart2rstR {
                match bits {
                    0 => Usart2rstR::NoEffect,
                    1 => Usart2rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == Usart2rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == Usart2rstR::Reset
            }
        }
        #[doc = "Possible values of the field `I2C1RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum I2c1rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl I2c1rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2c1rstR::NoEffect => 0,
                    I2c1rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> I2c1rstR {
                match bits {
                    0 => I2c1rstR::NoEffect,
                    1 => I2c1rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == I2c1rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == I2c1rstR::Reset
            }
        }
        #[doc = "Possible values of the field `I2C2RST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum I2c2rstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl I2c2rstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2c2rstR::NoEffect => 0,
                    I2c2rstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> I2c2rstR {
                match bits {
                    0 => I2c2rstR::NoEffect,
                    1 => I2c2rstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == I2c2rstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == I2c2rstR::Reset
            }
        }
        #[doc = "Possible values of the field `PWRRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PwrrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl PwrrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PwrrstR::NoEffect => 0,
                    PwrrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PwrrstR {
                match bits {
                    0 => PwrrstR::NoEffect,
                    1 => PwrrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == PwrrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == PwrrstR::Reset
            }
        }
        #[doc = "Possible values of the field `DACRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DacrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl DacrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DacrstR::NoEffect => 0,
                    DacrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DacrstR {
                match bits {
                    0 => DacrstR::NoEffect,
                    1 => DacrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == DacrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == DacrstR::Reset
            }
        }
        #[doc = "Possible values of the field `CECRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CecrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl CecrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CecrstR::NoEffect => 0,
                    CecrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CecrstR {
                match bits {
                    0 => CecrstR::NoEffect,
                    1 => CecrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == CecrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == CecrstR::Reset
            }
        }
        #[doc = "Values that can be written to the field `TIM2RST`"]
        pub enum Tim2rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim2rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim2rstW::NoEffect => 0,
                    Tim2rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim2rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim2rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim2rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim2rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM3RST`"]
        pub enum Tim3rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim3rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim3rstW::NoEffect => 0,
                    Tim3rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim3rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim3rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim3rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim3rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim3rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM6RST`"]
        pub enum Tim6rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim6rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim6rstW::NoEffect => 0,
                    Tim6rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim6rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim6rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim6rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim6rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim6rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM14RST`"]
        pub enum Tim14rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Tim14rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim14rstW::NoEffect => 0,
                    Tim14rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim14rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim14rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim14rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Tim14rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Tim14rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGRST`"]
        pub enum WwdgrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl WwdgrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WwdgrstW::NoEffect => 0,
                    WwdgrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WwdgrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: WwdgrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(WwdgrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(WwdgrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI2RST`"]
        pub enum Spi2rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Spi2rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi2rstW::NoEffect => 0,
                    Spi2rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Spi2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi2rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Spi2rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Spi2rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Spi2rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART2RST`"]
        pub enum Usart2rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl Usart2rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Usart2rstW::NoEffect => 0,
                    Usart2rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart2rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Usart2rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(Usart2rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(Usart2rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1RST`"]
        pub enum I2c1rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl I2c1rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2c1rstW::NoEffect => 0,
                    I2c1rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c1rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: I2c1rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(I2c1rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(I2c1rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2RST`"]
        pub enum I2c2rstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl I2c2rstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2c2rstW::NoEffect => 0,
                    I2c2rstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c2rstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c2rstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: I2c2rstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(I2c2rstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(I2c2rstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWRRST`"]
        pub enum PwrrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl PwrrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PwrrstW::NoEffect => 0,
                    PwrrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PwrrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PwrrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PwrrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(PwrrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(PwrrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DACRST`"]
        pub enum DacrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl DacrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DacrstW::NoEffect => 0,
                    DacrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DacrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DacrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DacrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(DacrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(DacrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CECRST`"]
        pub enum CecrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl CecrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CecrstW::NoEffect => 0,
                    CecrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CecrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CecrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(CecrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(CecrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline ( always )]
            pub fn tim2rst(&self) -> Tim2rstR {
                Tim2rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 0;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline ( always )]
            pub fn tim3rst(&self) -> Tim3rstR {
                Tim3rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 1;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline ( always )]
            pub fn tim6rst(&self) -> Tim6rstR {
                Tim6rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 4;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline ( always )]
            pub fn tim14rst(&self) -> Tim14rstR {
                Tim14rstR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 8;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline ( always )]
            pub fn wwdgrst(&self) -> WwdgrstR {
                WwdgrstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline ( always )]
            pub fn spi2rst(&self) -> Spi2rstR {
                Spi2rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 14;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline ( always )]
            pub fn usart2rst(&self) -> Usart2rstR {
                Usart2rstR::_from({
                                      const MASK: u8 = 1;
                                      const OFFSET: u8 = 17;
                                      ((self.bits >> OFFSET) & MASK as u32) as
                                      u8
                                  })
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline ( always )]
            pub fn i2c1rst(&self) -> I2c1rstR {
                I2c1rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 21;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline ( always )]
            pub fn i2c2rst(&self) -> I2c2rstR {
                I2c2rstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 22;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline ( always )]
            pub fn pwrrst(&self) -> PwrrstR {
                PwrrstR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 28;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline ( always )]
            pub fn dacrst(&self) -> DacrstR {
                DacrstR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 29;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 30 - HDMI CEC reset"]
            #[inline ( always )]
            pub fn cecrst(&self) -> CecrstR {
                CecrstR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 30;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer 2 reset"]
            #[inline ( always )]
            pub fn tim2rst(&mut self) -> _Tim2rstW {
                _Tim2rstW { w: self }
            }
            #[doc = "Bit 1 - Timer 3 reset"]
            #[inline ( always )]
            pub fn tim3rst(&mut self) -> _Tim3rstW {
                _Tim3rstW { w: self }
            }
            #[doc = "Bit 4 - Timer 6 reset"]
            #[inline ( always )]
            pub fn tim6rst(&mut self) -> _Tim6rstW {
                _Tim6rstW { w: self }
            }
            #[doc = "Bit 8 - Timer 14 reset"]
            #[inline ( always )]
            pub fn tim14rst(&mut self) -> _Tim14rstW {
                _Tim14rstW { w: self }
            }
            #[doc = "Bit 11 - Window watchdog reset"]
            #[inline ( always )]
            pub fn wwdgrst(&mut self) -> _WwdgrstW {
                _WwdgrstW { w: self }
            }
            #[doc = "Bit 14 - SPI2 reset"]
            #[inline ( always )]
            pub fn spi2rst(&mut self) -> _Spi2rstW {
                _Spi2rstW { w: self }
            }
            #[doc = "Bit 17 - USART 2 reset"]
            #[inline ( always )]
            pub fn usart2rst(&mut self) -> _Usart2rstW {
                _Usart2rstW { w: self }
            }
            #[doc = "Bit 21 - I2C1 reset"]
            #[inline ( always )]
            pub fn i2c1rst(&mut self) -> _I2c1rstW {
                _I2c1rstW { w: self }
            }
            #[doc = "Bit 22 - I2C2 reset"]
            #[inline ( always )]
            pub fn i2c2rst(&mut self) -> _I2c2rstW {
                _I2c2rstW { w: self }
            }
            #[doc = "Bit 28 - Power interface reset"]
            #[inline ( always )]
            pub fn pwrrst(&mut self) -> _PwrrstW {
                _PwrrstW { w: self }
            }
            #[doc = "Bit 29 - DAC interface reset"]
            #[inline ( always )]
            pub fn dacrst(&mut self) -> _DacrstW {
                _DacrstW { w: self }
            }
            #[doc = "Bit 30 - HDMI CEC reset"]
            #[inline ( always )]
            pub fn cecrst(&mut self) -> _CecrstW {
                _CecrstW { w: self }
            }
        }
    }
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"]
    pub struct Ahbenr {
        register: VolatileCell<u32>,
    }
    #[doc = "AHB Peripheral Clock enable register (RCC_AHBENR)"]
    pub mod ahbenr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ahbenr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `DMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmaenR::Disabled => 0,
                    DmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DmaenR {
                match bits {
                    0 => DmaenR::Disabled,
                    1 => DmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == DmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == DmaenR::Enabled
            }
        }
        #[doc = "Possible values of the field `SRAMEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SramenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SramenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SramenR::Disabled => 0,
                    SramenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SramenR {
                match bits {
                    0 => SramenR::Disabled,
                    1 => SramenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == SramenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == SramenR::Enabled
            }
        }
        #[doc = "Possible values of the field `FLITFEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum FlitfenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl FlitfenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    FlitfenR::Disabled => 0,
                    FlitfenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> FlitfenR {
                match bits {
                    0 => FlitfenR::Disabled,
                    1 => FlitfenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == FlitfenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == FlitfenR::Enabled
            }
        }
        #[doc = "Possible values of the field `CRCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CrcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CrcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CrcenR::Disabled => 0,
                    CrcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CrcenR {
                match bits {
                    0 => CrcenR::Disabled,
                    1 => CrcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CrcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CrcenR::Enabled
            }
        }
        #[doc = "Possible values of the field `IOPAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopaenR::Disabled => 0,
                    IopaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopaenR {
                match bits {
                    0 => IopaenR::Disabled,
                    1 => IopaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IopaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IopaenR::Enabled
            }
        }
        #[doc = "Possible values of the field `IOPBEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopbenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopbenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopbenR::Disabled => 0,
                    IopbenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopbenR {
                match bits {
                    0 => IopbenR::Disabled,
                    1 => IopbenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IopbenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IopbenR::Enabled
            }
        }
        #[doc = "Possible values of the field `IOPCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopcenR::Disabled => 0,
                    IopcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopcenR {
                match bits {
                    0 => IopcenR::Disabled,
                    1 => IopcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IopcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IopcenR::Enabled
            }
        }
        #[doc = "Possible values of the field `IOPDEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopdenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopdenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopdenR::Disabled => 0,
                    IopdenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopdenR {
                match bits {
                    0 => IopdenR::Disabled,
                    1 => IopdenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IopdenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IopdenR::Enabled
            }
        }
        #[doc = "Possible values of the field `IOPFEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopfenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopfenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopfenR::Disabled => 0,
                    IopfenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopfenR {
                match bits {
                    0 => IopfenR::Disabled,
                    1 => IopfenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IopfenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IopfenR::Enabled
            }
        }
        #[doc = "Possible values of the field `TSCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TscenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TscenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TscenR::Disabled => 0,
                    TscenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TscenR {
                match bits {
                    0 => TscenR::Disabled,
                    1 => TscenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TscenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TscenR::Enabled
            }
        }
        #[doc = "Values that can be written to the field `DMAEN`"]
        pub enum DmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmaenW::Disabled => 0,
                    DmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRAMEN`"]
        pub enum SramenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SramenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SramenW::Disabled => 0,
                    SramenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SramenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SramenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SramenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SramenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SramenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLITFEN`"]
        pub enum FlitfenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl FlitfenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FlitfenW::Disabled => 0,
                    FlitfenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FlitfenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FlitfenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: FlitfenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FlitfenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FlitfenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRCEN`"]
        pub enum CrcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CrcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CrcenW::Disabled => 0,
                    CrcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CrcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CrcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CrcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CrcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CrcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPAEN`"]
        pub enum IopaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopaenW::Disabled => 0,
                    IopaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IopaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IopaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPBEN`"]
        pub enum IopbenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopbenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopbenW::Disabled => 0,
                    IopbenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopbenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopbenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopbenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IopbenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IopbenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPCEN`"]
        pub enum IopcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopcenW::Disabled => 0,
                    IopcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IopcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IopcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPDEN`"]
        pub enum IopdenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopdenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopdenW::Disabled => 0,
                    IopdenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopdenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopdenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IopdenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IopdenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPFEN`"]
        pub enum IopfenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IopfenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopfenW::Disabled => 0,
                    IopfenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopfenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopfenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopfenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IopfenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IopfenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TSCEN`"]
        pub enum TscenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TscenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TscenW::Disabled => 0,
                    TscenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TscenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TscenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TscenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TscenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TscenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline ( always )]
            pub fn dmaen(&self) -> DmaenR {
                DmaenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline ( always )]
            pub fn sramen(&self) -> SramenR {
                SramenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline ( always )]
            pub fn flitfen(&self) -> FlitfenR {
                FlitfenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 4;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline ( always )]
            pub fn crcen(&self) -> CrcenR {
                CrcenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 6;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 17 - I/O port A clock enable"]
            #[inline ( always )]
            pub fn iopaen(&self) -> IopaenR {
                IopaenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 17;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 18 - I/O port B clock enable"]
            #[inline ( always )]
            pub fn iopben(&self) -> IopbenR {
                IopbenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 18;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 19 - I/O port C clock enable"]
            #[inline ( always )]
            pub fn iopcen(&self) -> IopcenR {
                IopcenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 19;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 20 - I/O port D clock enable"]
            #[inline ( always )]
            pub fn iopden(&self) -> IopdenR {
                IopdenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 20;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 22 - I/O port F clock enable"]
            #[inline ( always )]
            pub fn iopfen(&self) -> IopfenR {
                IopfenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 22;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 24 - Touch sensing controller clock enable"]
            #[inline ( always )]
            pub fn tscen(&self) -> TscenR {
                TscenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 24;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 20 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DMA1 clock enable"]
            #[inline ( always )]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
            #[doc = "Bit 2 - SRAM interface clock enable"]
            #[inline ( always )]
            pub fn sramen(&mut self) -> _SramenW {
                _SramenW { w: self }
            }
            #[doc = "Bit 4 - FLITF clock enable"]
            #[inline ( always )]
            pub fn flitfen(&mut self) -> _FlitfenW {
                _FlitfenW { w: self }
            }
            #[doc = "Bit 6 - CRC clock enable"]
            #[inline ( always )]
            pub fn crcen(&mut self) -> _CrcenW {
                _CrcenW { w: self }
            }
            #[doc = "Bit 17 - I/O port A clock enable"]
            #[inline ( always )]
            pub fn iopaen(&mut self) -> _IopaenW {
                _IopaenW { w: self }
            }
            #[doc = "Bit 18 - I/O port B clock enable"]
            #[inline ( always )]
            pub fn iopben(&mut self) -> _IopbenW {
                _IopbenW { w: self }
            }
            #[doc = "Bit 19 - I/O port C clock enable"]
            #[inline ( always )]
            pub fn iopcen(&mut self) -> _IopcenW {
                _IopcenW { w: self }
            }
            #[doc = "Bit 20 - I/O port D clock enable"]
            #[inline ( always )]
            pub fn iopden(&mut self) -> _IopdenW {
                _IopdenW { w: self }
            }
            #[doc = "Bit 22 - I/O port F clock enable"]
            #[inline ( always )]
            pub fn iopfen(&mut self) -> _IopfenW {
                _IopfenW { w: self }
            }
            #[doc = "Bit 24 - Touch sensing controller clock enable"]
            #[inline ( always )]
            pub fn tscen(&mut self) -> _TscenW {
                _TscenW { w: self }
            }
        }
    }
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"]
    pub struct Apb2enr {
        register: VolatileCell<u32>,
    }
    #[doc = "APB2 peripheral clock enable register (RCC_APB2ENR)"]
    pub mod apb2enr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apb2enr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `SYSCFGEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SyscfgenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SyscfgenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SyscfgenR::Disabled => 0,
                    SyscfgenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SyscfgenR {
                match bits {
                    0 => SyscfgenR::Disabled,
                    1 => SyscfgenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == SyscfgenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == SyscfgenR::Enabled
            }
        }
        #[doc = "Possible values of the field `ADCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AdcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AdcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AdcenR::Disabled => 0,
                    AdcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AdcenR {
                match bits {
                    0 => AdcenR::Disabled,
                    1 => AdcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == AdcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == AdcenR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim1enR::Disabled => 0,
                    Tim1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim1enR {
                match bits {
                    0 => Tim1enR::Disabled,
                    1 => Tim1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim1enR::Enabled
            }
        }
        #[doc = "Possible values of the field `SPI1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Spi1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Spi1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi1enR::Disabled => 0,
                    Spi1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Spi1enR {
                match bits {
                    0 => Spi1enR::Disabled,
                    1 => Spi1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Spi1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Spi1enR::Enabled
            }
        }
        #[doc = "Possible values of the field `USART1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Usart1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Usart1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Usart1enR::Disabled => 0,
                    Usart1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Usart1enR {
                match bits {
                    0 => Usart1enR::Disabled,
                    1 => Usart1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Usart1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Usart1enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM15EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim15enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim15enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim15enR::Disabled => 0,
                    Tim15enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim15enR {
                match bits {
                    0 => Tim15enR::Disabled,
                    1 => Tim15enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim15enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim15enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM16EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim16enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim16enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim16enR::Disabled => 0,
                    Tim16enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim16enR {
                match bits {
                    0 => Tim16enR::Disabled,
                    1 => Tim16enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim16enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim16enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM17EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim17enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim17enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim17enR::Disabled => 0,
                    Tim17enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim17enR {
                match bits {
                    0 => Tim17enR::Disabled,
                    1 => Tim17enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim17enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim17enR::Enabled
            }
        }
        #[doc = "Possible values of the field `DBGMCUEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DbgmcuenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DbgmcuenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DbgmcuenR::Disabled => 0,
                    DbgmcuenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DbgmcuenR {
                match bits {
                    0 => DbgmcuenR::Disabled,
                    1 => DbgmcuenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == DbgmcuenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == DbgmcuenR::Enabled
            }
        }
        #[doc = "Values that can be written to the field `SYSCFGEN`"]
        pub enum SyscfgenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl SyscfgenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SyscfgenW::Disabled => 0,
                    SyscfgenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SyscfgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SyscfgenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SyscfgenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SyscfgenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SyscfgenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADCEN`"]
        pub enum AdcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AdcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AdcenW::Disabled => 0,
                    AdcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AdcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AdcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AdcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM1EN`"]
        pub enum Tim1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim1enW::Disabled => 0,
                    Tim1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1EN`"]
        pub enum Spi1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Spi1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi1enW::Disabled => 0,
                    Spi1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Spi1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Spi1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Spi1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Spi1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART1EN`"]
        pub enum Usart1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Usart1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Usart1enW::Disabled => 0,
                    Usart1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Usart1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Usart1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Usart1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM15EN`"]
        pub enum Tim15enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim15enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim15enW::Disabled => 0,
                    Tim15enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim15enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim15enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim15enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim15enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim15enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM16EN`"]
        pub enum Tim16enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim16enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim16enW::Disabled => 0,
                    Tim16enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim16enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim16enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim16enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim16enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM17EN`"]
        pub enum Tim17enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim17enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim17enW::Disabled => 0,
                    Tim17enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim17enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim17enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim17enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim17enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DBGMCUEN`"]
        pub enum DbgmcuenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DbgmcuenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DbgmcuenW::Disabled => 0,
                    DbgmcuenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgmcuenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgmcuenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DbgmcuenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DbgmcuenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DbgmcuenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SYSCFG clock enable"]
            #[inline ( always )]
            pub fn syscfgen(&self) -> SyscfgenR {
                SyscfgenR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 0;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline ( always )]
            pub fn adcen(&self) -> AdcenR {
                AdcenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 9;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline ( always )]
            pub fn tim1en(&self) -> Tim1enR {
                Tim1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 11;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline ( always )]
            pub fn spi1en(&self) -> Spi1enR {
                Spi1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 12;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline ( always )]
            pub fn usart1en(&self) -> Usart1enR {
                Usart1enR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 14;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 16 - TIM15 timer clock enable"]
            #[inline ( always )]
            pub fn tim15en(&self) -> Tim15enR {
                Tim15enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 16;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 17 - TIM16 timer clock enable"]
            #[inline ( always )]
            pub fn tim16en(&self) -> Tim16enR {
                Tim16enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 17;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 18 - TIM17 timer clock enable"]
            #[inline ( always )]
            pub fn tim17en(&self) -> Tim17enR {
                Tim17enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 18;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 22 - MCU debug module clock enable"]
            #[inline ( always )]
            pub fn dbgmcuen(&self) -> DbgmcuenR {
                DbgmcuenR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 22;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SYSCFG clock enable"]
            #[inline ( always )]
            pub fn syscfgen(&mut self) -> _SyscfgenW {
                _SyscfgenW { w: self }
            }
            #[doc = "Bit 9 - ADC 1 interface clock enable"]
            #[inline ( always )]
            pub fn adcen(&mut self) -> _AdcenW {
                _AdcenW { w: self }
            }
            #[doc = "Bit 11 - TIM1 Timer clock enable"]
            #[inline ( always )]
            pub fn tim1en(&mut self) -> _Tim1enW {
                _Tim1enW { w: self }
            }
            #[doc = "Bit 12 - SPI 1 clock enable"]
            #[inline ( always )]
            pub fn spi1en(&mut self) -> _Spi1enW {
                _Spi1enW { w: self }
            }
            #[doc = "Bit 14 - USART1 clock enable"]
            #[inline ( always )]
            pub fn usart1en(&mut self) -> _Usart1enW {
                _Usart1enW { w: self }
            }
            #[doc = "Bit 16 - TIM15 timer clock enable"]
            #[inline ( always )]
            pub fn tim15en(&mut self) -> _Tim15enW {
                _Tim15enW { w: self }
            }
            #[doc = "Bit 17 - TIM16 timer clock enable"]
            #[inline ( always )]
            pub fn tim16en(&mut self) -> _Tim16enW {
                _Tim16enW { w: self }
            }
            #[doc = "Bit 18 - TIM17 timer clock enable"]
            #[inline ( always )]
            pub fn tim17en(&mut self) -> _Tim17enW {
                _Tim17enW { w: self }
            }
            #[doc = "Bit 22 - MCU debug module clock enable"]
            #[inline ( always )]
            pub fn dbgmcuen(&mut self) -> _DbgmcuenW {
                _DbgmcuenW { w: self }
            }
        }
    }
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"]
    pub struct Apb1enr {
        register: VolatileCell<u32>,
    }
    #[doc = "APB1 peripheral clock enable register (RCC_APB1ENR)"]
    pub mod apb1enr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apb1enr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `TIM2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim2enR::Disabled => 0,
                    Tim2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim2enR {
                match bits {
                    0 => Tim2enR::Disabled,
                    1 => Tim2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim2enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM3EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim3enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim3enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim3enR::Disabled => 0,
                    Tim3enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim3enR {
                match bits {
                    0 => Tim3enR::Disabled,
                    1 => Tim3enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim3enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim3enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM6EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim6enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim6enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim6enR::Disabled => 0,
                    Tim6enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim6enR {
                match bits {
                    0 => Tim6enR::Disabled,
                    1 => Tim6enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim6enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim6enR::Enabled
            }
        }
        #[doc = "Possible values of the field `TIM14EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Tim14enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim14enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Tim14enR::Disabled => 0,
                    Tim14enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Tim14enR {
                match bits {
                    0 => Tim14enR::Disabled,
                    1 => Tim14enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Tim14enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Tim14enR::Enabled
            }
        }
        #[doc = "Possible values of the field `WWDGEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum WwdgenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WwdgenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    WwdgenR::Disabled => 0,
                    WwdgenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> WwdgenR {
                match bits {
                    0 => WwdgenR::Disabled,
                    1 => WwdgenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == WwdgenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == WwdgenR::Enabled
            }
        }
        #[doc = "Possible values of the field `SPI2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Spi2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Spi2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Spi2enR::Disabled => 0,
                    Spi2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Spi2enR {
                match bits {
                    0 => Spi2enR::Disabled,
                    1 => Spi2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Spi2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Spi2enR::Enabled
            }
        }
        #[doc = "Possible values of the field `USART2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Usart2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Usart2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Usart2enR::Disabled => 0,
                    Usart2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Usart2enR {
                match bits {
                    0 => Usart2enR::Disabled,
                    1 => Usart2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Usart2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Usart2enR::Enabled
            }
        }
        #[doc = "Possible values of the field `I2C1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum I2c1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl I2c1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2c1enR::Disabled => 0,
                    I2c1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> I2c1enR {
                match bits {
                    0 => I2c1enR::Disabled,
                    1 => I2c1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == I2c1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == I2c1enR::Enabled
            }
        }
        #[doc = "Possible values of the field `I2C2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum I2c2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl I2c2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2c2enR::Disabled => 0,
                    I2c2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> I2c2enR {
                match bits {
                    0 => I2c2enR::Disabled,
                    1 => I2c2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == I2c2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == I2c2enR::Enabled
            }
        }
        #[doc = "Possible values of the field `PWREN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PwrenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl PwrenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PwrenR::Disabled => 0,
                    PwrenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PwrenR {
                match bits {
                    0 => PwrenR::Disabled,
                    1 => PwrenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == PwrenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == PwrenR::Enabled
            }
        }
        #[doc = "Possible values of the field `DACEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DacenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DacenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DacenR::Disabled => 0,
                    DacenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DacenR {
                match bits {
                    0 => DacenR::Disabled,
                    1 => DacenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == DacenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == DacenR::Enabled
            }
        }
        #[doc = "Possible values of the field `CECEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CecenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CecenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CecenR::Disabled => 0,
                    CecenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CecenR {
                match bits {
                    0 => CecenR::Disabled,
                    1 => CecenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CecenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CecenR::Enabled
            }
        }
        #[doc = "Values that can be written to the field `TIM2EN`"]
        pub enum Tim2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim2enW::Disabled => 0,
                    Tim2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM3EN`"]
        pub enum Tim3enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim3enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim3enW::Disabled => 0,
                    Tim3enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim3enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim3enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim3enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim3enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim3enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM6EN`"]
        pub enum Tim6enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim6enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim6enW::Disabled => 0,
                    Tim6enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim6enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim6enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim6enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim6enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim6enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIM14EN`"]
        pub enum Tim14enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Tim14enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Tim14enW::Disabled => 0,
                    Tim14enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim14enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim14enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Tim14enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Tim14enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Tim14enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGEN`"]
        pub enum WwdgenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WwdgenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WwdgenW::Disabled => 0,
                    WwdgenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WwdgenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: WwdgenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WwdgenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WwdgenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI2EN`"]
        pub enum Spi2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Spi2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Spi2enW::Disabled => 0,
                    Spi2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Spi2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Spi2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Spi2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Spi2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Spi2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART2EN`"]
        pub enum Usart2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Usart2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Usart2enW::Disabled => 0,
                    Usart2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Usart2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Usart2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Usart2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C1EN`"]
        pub enum I2c1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl I2c1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2c1enW::Disabled => 0,
                    I2c1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: I2c1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2c1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2c1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C2EN`"]
        pub enum I2c2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl I2c2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2c2enW::Disabled => 0,
                    I2c2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: I2c2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2c2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2c2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWREN`"]
        pub enum PwrenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl PwrenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PwrenW::Disabled => 0,
                    PwrenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PwrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PwrenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PwrenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PwrenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PwrenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DACEN`"]
        pub enum DacenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DacenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DacenW::Disabled => 0,
                    DacenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DacenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DacenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DacenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DacenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DacenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CECEN`"]
        pub enum CecenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CecenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CecenW::Disabled => 0,
                    CecenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CecenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CecenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CecenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CecenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline ( always )]
            pub fn tim2en(&self) -> Tim2enR {
                Tim2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 0;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline ( always )]
            pub fn tim3en(&self) -> Tim3enR {
                Tim3enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline ( always )]
            pub fn tim6en(&self) -> Tim6enR {
                Tim6enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 4;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline ( always )]
            pub fn tim14en(&self) -> Tim14enR {
                Tim14enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 8;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline ( always )]
            pub fn wwdgen(&self) -> WwdgenR {
                WwdgenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 11;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline ( always )]
            pub fn spi2en(&self) -> Spi2enR {
                Spi2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 14;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline ( always )]
            pub fn usart2en(&self) -> Usart2enR {
                Usart2enR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 17;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline ( always )]
            pub fn i2c1en(&self) -> I2c1enR {
                I2c1enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 21;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline ( always )]
            pub fn i2c2en(&self) -> I2c2enR {
                I2c2enR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 22;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline ( always )]
            pub fn pwren(&self) -> PwrenR {
                PwrenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 28;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline ( always )]
            pub fn dacen(&self) -> DacenR {
                DacenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 29;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 30 - HDMI CEC interface clock enable"]
            #[inline ( always )]
            pub fn cecen(&self) -> CecenR {
                CecenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 30;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Timer 2 clock enable"]
            #[inline ( always )]
            pub fn tim2en(&mut self) -> _Tim2enW {
                _Tim2enW { w: self }
            }
            #[doc = "Bit 1 - Timer 3 clock enable"]
            #[inline ( always )]
            pub fn tim3en(&mut self) -> _Tim3enW {
                _Tim3enW { w: self }
            }
            #[doc = "Bit 4 - Timer 6 clock enable"]
            #[inline ( always )]
            pub fn tim6en(&mut self) -> _Tim6enW {
                _Tim6enW { w: self }
            }
            #[doc = "Bit 8 - Timer 14 clock enable"]
            #[inline ( always )]
            pub fn tim14en(&mut self) -> _Tim14enW {
                _Tim14enW { w: self }
            }
            #[doc = "Bit 11 - Window watchdog clock enable"]
            #[inline ( always )]
            pub fn wwdgen(&mut self) -> _WwdgenW {
                _WwdgenW { w: self }
            }
            #[doc = "Bit 14 - SPI 2 clock enable"]
            #[inline ( always )]
            pub fn spi2en(&mut self) -> _Spi2enW {
                _Spi2enW { w: self }
            }
            #[doc = "Bit 17 - USART 2 clock enable"]
            #[inline ( always )]
            pub fn usart2en(&mut self) -> _Usart2enW {
                _Usart2enW { w: self }
            }
            #[doc = "Bit 21 - I2C 1 clock enable"]
            #[inline ( always )]
            pub fn i2c1en(&mut self) -> _I2c1enW {
                _I2c1enW { w: self }
            }
            #[doc = "Bit 22 - I2C 2 clock enable"]
            #[inline ( always )]
            pub fn i2c2en(&mut self) -> _I2c2enW {
                _I2c2enW { w: self }
            }
            #[doc = "Bit 28 - Power interface clock enable"]
            #[inline ( always )]
            pub fn pwren(&mut self) -> _PwrenW {
                _PwrenW { w: self }
            }
            #[doc = "Bit 29 - DAC interface clock enable"]
            #[inline ( always )]
            pub fn dacen(&mut self) -> _DacenW {
                _DacenW { w: self }
            }
            #[doc = "Bit 30 - HDMI CEC interface clock enable"]
            #[inline ( always )]
            pub fn cecen(&mut self) -> _CecenW {
                _CecenW { w: self }
            }
        }
    }
    #[doc = "Backup domain control register (RCC_BDCR)"]
    pub struct Bdcr {
        register: VolatileCell<u32>,
    }
    #[doc = "Backup domain control register (RCC_BDCR)"]
    pub mod bdcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bdcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `LSEON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LseonR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl LseonR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LseonR::Off => 0,
                    LseonR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LseonR {
                match bits {
                    0 => LseonR::Off,
                    1 => LseonR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == LseonR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == LseonR::On
            }
        }
        #[doc = "Possible values of the field `LSERDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LserdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl LserdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LserdyR::NotReady => 0,
                    LserdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LserdyR {
                match bits {
                    0 => LserdyR::NotReady,
                    1 => LserdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == LserdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == LserdyR::Ready
            }
        }
        #[doc = "Possible values of the field `LSEBYP`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LsebypR {
            #[doc = "Not bypassed."]
            NotBypassed,
            #[doc = "Bypassed."]
            Bypassed,
        }
        impl LsebypR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LsebypR::NotBypassed => 0,
                    LsebypR::Bypassed => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LsebypR {
                match bits {
                    0 => LsebypR::NotBypassed,
                    1 => LsebypR::Bypassed,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotBypassed`"]
            #[inline ( always )]
            pub fn is_not_bypassed(&self) -> bool {
                *self == LsebypR::NotBypassed
            }
            #[doc = "Checks if the value of the field is `Bypassed`"]
            #[inline ( always )]
            pub fn is_bypassed(&self) -> bool {
                *self == LsebypR::Bypassed
            }
        }
        #[doc = r" Value of the field"]
        pub struct LsedrvR {
            bits: u8,
        }
        impl LsedrvR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtcselR {
            bits: u8,
        }
        impl RtcselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `RTCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum RtcenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RtcenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    RtcenR::Disabled => 0,
                    RtcenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> RtcenR {
                match bits {
                    0 => RtcenR::Disabled,
                    1 => RtcenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == RtcenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == RtcenR::Enabled
            }
        }
        #[doc = "Possible values of the field `BDRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum BdrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl BdrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    BdrstR::NoEffect => 0,
                    BdrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> BdrstR {
                match bits {
                    0 => BdrstR::NoEffect,
                    1 => BdrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == BdrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == BdrstR::Reset
            }
        }
        #[doc = "Values that can be written to the field `LSEON`"]
        pub enum LseonW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl LseonW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LseonW::Off => 0,
                    LseonW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LseonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LseonW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LseonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(LseonW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(LseonW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSEBYP`"]
        pub enum LsebypW {
            #[doc = "Not bypassed."]
            NotBypassed,
            #[doc = "Bypassed."]
            Bypassed,
        }
        impl LsebypW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LsebypW::NotBypassed => 0,
                    LsebypW::Bypassed => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsebypW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsebypW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LsebypW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Not bypassed."]
            #[inline ( always )]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LsebypW::NotBypassed)
            }
            #[doc = "Bypassed."]
            #[inline ( always )]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LsebypW::Bypassed)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsedrvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsedrvW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtcselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RTCEN`"]
        pub enum RtcenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RtcenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RtcenW::Disabled => 0,
                    RtcenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtcenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtcenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: RtcenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RtcenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RtcenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BDRST`"]
        pub enum BdrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl BdrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BdrstW::NoEffect => 0,
                    BdrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BdrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BdrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: BdrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(BdrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(BdrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline ( always )]
            pub fn lseon(&self) -> LseonR {
                LseonR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 1 - External Low Speed oscillator ready"]
            #[inline ( always )]
            pub fn lserdy(&self) -> LserdyR {
                LserdyR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline ( always )]
            pub fn lsebyp(&self) -> LsebypR {
                LsebypR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 2;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bits 3:4 - LSE oscillator drive capability"]
            #[inline ( always )]
            pub fn lsedrv(&self) -> LsedrvR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LsedrvR { bits }
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline ( always )]
            pub fn rtcsel(&self) -> RtcselR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtcselR { bits }
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline ( always )]
            pub fn rtcen(&self) -> RtcenR {
                RtcenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 15;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline ( always )]
            pub fn bdrst(&self) -> BdrstR {
                BdrstR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 16;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Low Speed oscillator enable"]
            #[inline ( always )]
            pub fn lseon(&mut self) -> _LseonW {
                _LseonW { w: self }
            }
            #[doc = "Bit 2 - External Low Speed oscillator bypass"]
            #[inline ( always )]
            pub fn lsebyp(&mut self) -> _LsebypW {
                _LsebypW { w: self }
            }
            #[doc = "Bits 3:4 - LSE oscillator drive capability"]
            #[inline ( always )]
            pub fn lsedrv(&mut self) -> _LsedrvW {
                _LsedrvW { w: self }
            }
            #[doc = "Bits 8:9 - RTC clock source selection"]
            #[inline ( always )]
            pub fn rtcsel(&mut self) -> _RtcselW {
                _RtcselW { w: self }
            }
            #[doc = "Bit 15 - RTC clock enable"]
            #[inline ( always )]
            pub fn rtcen(&mut self) -> _RtcenW {
                _RtcenW { w: self }
            }
            #[doc = "Bit 16 - Backup domain software reset"]
            #[inline ( always )]
            pub fn bdrst(&mut self) -> _BdrstW {
                _BdrstW { w: self }
            }
        }
    }
    #[doc = "Control/status register (RCC_CSR)"]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    #[doc = "Control/status register (RCC_CSR)"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `LSION`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LsionR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl LsionR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LsionR::Off => 0,
                    LsionR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LsionR {
                match bits {
                    0 => LsionR::Off,
                    1 => LsionR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == LsionR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == LsionR::On
            }
        }
        #[doc = "Possible values of the field `LSIRDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LsirdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl LsirdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LsirdyR::NotReady => 0,
                    LsirdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LsirdyR {
                match bits {
                    0 => LsirdyR::NotReady,
                    1 => LsirdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == LsirdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == LsirdyR::Ready
            }
        }
        #[doc = r" Value of the field"]
        pub struct RmvfR {
            bits: u8,
        }
        impl RmvfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `OBLRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum OblrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl OblrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    OblrstfR::NoReset => 0,
                    OblrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> OblrstfR {
                match bits {
                    0 => OblrstfR::NoReset,
                    1 => OblrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == OblrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == OblrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `PINRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PinrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl PinrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PinrstfR::NoReset => 0,
                    PinrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PinrstfR {
                match bits {
                    0 => PinrstfR::NoReset,
                    1 => PinrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == PinrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == PinrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `PORRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum PorrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl PorrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    PorrstfR::NoReset => 0,
                    PorrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> PorrstfR {
                match bits {
                    0 => PorrstfR::NoReset,
                    1 => PorrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == PorrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == PorrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `SFTRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum SftrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl SftrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    SftrstfR::NoReset => 0,
                    SftrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> SftrstfR {
                match bits {
                    0 => SftrstfR::NoReset,
                    1 => SftrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == SftrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == SftrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `IWDGRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IwdgrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl IwdgrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IwdgrstfR::NoReset => 0,
                    IwdgrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IwdgrstfR {
                match bits {
                    0 => IwdgrstfR::NoReset,
                    1 => IwdgrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == IwdgrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IwdgrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `WWDGRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum WwdgrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl WwdgrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    WwdgrstfR::NoReset => 0,
                    WwdgrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> WwdgrstfR {
                match bits {
                    0 => WwdgrstfR::NoReset,
                    1 => WwdgrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == WwdgrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == WwdgrstfR::Reset
            }
        }
        #[doc = "Possible values of the field `LPWRRSTF`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LpwrrstfR {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl LpwrrstfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LpwrrstfR::NoReset => 0,
                    LpwrrstfR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LpwrrstfR {
                match bits {
                    0 => LpwrrstfR::NoReset,
                    1 => LpwrrstfR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoReset`"]
            #[inline ( always )]
            pub fn is_no_reset(&self) -> bool {
                *self == LpwrrstfR::NoReset
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == LpwrrstfR::Reset
            }
        }
        #[doc = "Values that can be written to the field `LSION`"]
        pub enum LsionW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl LsionW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LsionW::Off => 0,
                    LsionW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LsionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LsionW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LsionW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(LsionW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(LsionW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RmvfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RmvfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OBLRSTF`"]
        pub enum OblrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl OblrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    OblrstfW::NoReset => 0,
                    OblrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OblrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OblrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: OblrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(OblrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(OblrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINRSTF`"]
        pub enum PinrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl PinrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PinrstfW::NoReset => 0,
                    PinrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PinrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PinrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PinrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PinrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(PinrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PORRSTF`"]
        pub enum PorrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl PorrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PorrstfW::NoReset => 0,
                    PorrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PorrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PorrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: PorrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PorrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(PorrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SFTRSTF`"]
        pub enum SftrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl SftrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SftrstfW::NoReset => 0,
                    SftrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SftrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SftrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: SftrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(SftrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(SftrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IWDGRSTF`"]
        pub enum IwdgrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl IwdgrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IwdgrstfW::NoReset => 0,
                    IwdgrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IwdgrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IwdgrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IwdgrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(IwdgrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IwdgrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDGRSTF`"]
        pub enum WwdgrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl WwdgrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WwdgrstfW::NoReset => 0,
                    WwdgrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WwdgrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WwdgrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: WwdgrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(WwdgrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(WwdgrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPWRRSTF`"]
        pub enum LpwrrstfW {
            #[doc = "No reset flag."]
            NoReset,
            #[doc = "Reset flag."]
            Reset,
        }
        impl LpwrrstfW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LpwrrstfW::NoReset => 0,
                    LpwrrstfW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LpwrrstfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LpwrrstfW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LpwrrstfW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No reset flag."]
            #[inline ( always )]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LpwrrstfW::NoReset)
            }
            #[doc = "Reset flag."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(LpwrrstfW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline ( always )]
            pub fn lsion(&self) -> LsionR {
                LsionR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 1 - Internal low speed oscillator ready"]
            #[inline ( always )]
            pub fn lsirdy(&self) -> LsirdyR {
                LsirdyR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 1;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline ( always )]
            pub fn rmvf(&self) -> RmvfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RmvfR { bits }
            }
            #[doc = "Bit 25 - Option byte loader reset flag"]
            #[inline ( always )]
            pub fn oblrstf(&self) -> OblrstfR {
                OblrstfR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 25;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline ( always )]
            pub fn pinrstf(&self) -> PinrstfR {
                PinrstfR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 26;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline ( always )]
            pub fn porrstf(&self) -> PorrstfR {
                PorrstfR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 27;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline ( always )]
            pub fn sftrstf(&self) -> SftrstfR {
                SftrstfR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 28;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline ( always )]
            pub fn iwdgrstf(&self) -> IwdgrstfR {
                IwdgrstfR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 29;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline ( always )]
            pub fn wwdgrstf(&self) -> WwdgrstfR {
                WwdgrstfR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 30;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline ( always )]
            pub fn lpwrrstf(&self) -> LpwrrstfR {
                LpwrrstfR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 31;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 201326592 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Internal low speed oscillator enable"]
            #[inline ( always )]
            pub fn lsion(&mut self) -> _LsionW {
                _LsionW { w: self }
            }
            #[doc = "Bit 24 - Remove reset flag"]
            #[inline ( always )]
            pub fn rmvf(&mut self) -> _RmvfW {
                _RmvfW { w: self }
            }
            #[doc = "Bit 25 - Option byte loader reset flag"]
            #[inline ( always )]
            pub fn oblrstf(&mut self) -> _OblrstfW {
                _OblrstfW { w: self }
            }
            #[doc = "Bit 26 - PIN reset flag"]
            #[inline ( always )]
            pub fn pinrstf(&mut self) -> _PinrstfW {
                _PinrstfW { w: self }
            }
            #[doc = "Bit 27 - POR/PDR reset flag"]
            #[inline ( always )]
            pub fn porrstf(&mut self) -> _PorrstfW {
                _PorrstfW { w: self }
            }
            #[doc = "Bit 28 - Software reset flag"]
            #[inline ( always )]
            pub fn sftrstf(&mut self) -> _SftrstfW {
                _SftrstfW { w: self }
            }
            #[doc = "Bit 29 - Independent watchdog reset flag"]
            #[inline ( always )]
            pub fn iwdgrstf(&mut self) -> _IwdgrstfW {
                _IwdgrstfW { w: self }
            }
            #[doc = "Bit 30 - Window watchdog reset flag"]
            #[inline ( always )]
            pub fn wwdgrstf(&mut self) -> _WwdgrstfW {
                _WwdgrstfW { w: self }
            }
            #[doc = "Bit 31 - Low-power reset flag"]
            #[inline ( always )]
            pub fn lpwrrstf(&mut self) -> _LpwrrstfW {
                _LpwrrstfW { w: self }
            }
        }
    }
    #[doc = "AHB peripheral reset register"]
    pub struct Ahbrstr {
        register: VolatileCell<u32>,
    }
    #[doc = "AHB peripheral reset register"]
    pub mod ahbrstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ahbrstr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `IOPARST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IoparstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IoparstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IoparstR::NoEffect => 0,
                    IoparstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IoparstR {
                match bits {
                    0 => IoparstR::NoEffect,
                    1 => IoparstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == IoparstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IoparstR::Reset
            }
        }
        #[doc = "Possible values of the field `IOPBRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopbrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopbrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopbrstR::NoEffect => 0,
                    IopbrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopbrstR {
                match bits {
                    0 => IopbrstR::NoEffect,
                    1 => IopbrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == IopbrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IopbrstR::Reset
            }
        }
        #[doc = "Possible values of the field `IOPCRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopcrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopcrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopcrstR::NoEffect => 0,
                    IopcrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopcrstR {
                match bits {
                    0 => IopcrstR::NoEffect,
                    1 => IopcrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == IopcrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IopcrstR::Reset
            }
        }
        #[doc = "Possible values of the field `IOPDRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopdrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopdrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopdrstR::NoEffect => 0,
                    IopdrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopdrstR {
                match bits {
                    0 => IopdrstR::NoEffect,
                    1 => IopdrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == IopdrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IopdrstR::Reset
            }
        }
        #[doc = "Possible values of the field `IOPFRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IopfrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopfrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IopfrstR::NoEffect => 0,
                    IopfrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IopfrstR {
                match bits {
                    0 => IopfrstR::NoEffect,
                    1 => IopfrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == IopfrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == IopfrstR::Reset
            }
        }
        #[doc = "Possible values of the field `TSCRST`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TscrstR {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl TscrstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TscrstR::NoEffect => 0,
                    TscrstR::Reset => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TscrstR {
                match bits {
                    0 => TscrstR::NoEffect,
                    1 => TscrstR::Reset,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NoEffect`"]
            #[inline ( always )]
            pub fn is_no_effect(&self) -> bool {
                *self == TscrstR::NoEffect
            }
            #[doc = "Checks if the value of the field is `Reset`"]
            #[inline ( always )]
            pub fn is_reset(&self) -> bool {
                *self == TscrstR::Reset
            }
        }
        #[doc = "Values that can be written to the field `IOPARST`"]
        pub enum IoparstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IoparstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IoparstW::NoEffect => 0,
                    IoparstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IoparstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IoparstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IoparstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(IoparstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IoparstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPBRST`"]
        pub enum IopbrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopbrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopbrstW::NoEffect => 0,
                    IopbrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopbrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopbrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopbrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(IopbrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IopbrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPCRST`"]
        pub enum IopcrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopcrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopcrstW::NoEffect => 0,
                    IopcrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopcrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopcrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopcrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(IopcrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IopcrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPDRST`"]
        pub enum IopdrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopdrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopdrstW::NoEffect => 0,
                    IopdrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopdrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopdrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopdrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(IopdrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IopdrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOPFRST`"]
        pub enum IopfrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl IopfrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IopfrstW::NoEffect => 0,
                    IopfrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IopfrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IopfrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IopfrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(IopfrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(IopfrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TSCRST`"]
        pub enum TscrstW {
            #[doc = "No effect."]
            NoEffect,
            #[doc = "Carry out the reset action."]
            Reset,
        }
        impl TscrstW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TscrstW::NoEffect => 0,
                    TscrstW::Reset => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TscrstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TscrstW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TscrstW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline ( always )]
            pub fn no_effect(self) -> &'a mut W {
                self.variant(TscrstW::NoEffect)
            }
            #[doc = "Carry out the reset action."]
            #[inline ( always )]
            pub fn reset(self) -> &'a mut W {
                self.variant(TscrstW::Reset)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 17 - I/O port A reset"]
            #[inline ( always )]
            pub fn ioparst(&self) -> IoparstR {
                IoparstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 17;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 18 - I/O port B reset"]
            #[inline ( always )]
            pub fn iopbrst(&self) -> IopbrstR {
                IopbrstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 18;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 19 - I/O port C reset"]
            #[inline ( always )]
            pub fn iopcrst(&self) -> IopcrstR {
                IopcrstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 19;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 20 - I/O port D reset"]
            #[inline ( always )]
            pub fn iopdrst(&self) -> IopdrstR {
                IopdrstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 20;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 22 - I/O port F reset"]
            #[inline ( always )]
            pub fn iopfrst(&self) -> IopfrstR {
                IopfrstR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 22;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 24 - Touch sensing controller reset"]
            #[inline ( always )]
            pub fn tscrst(&self) -> TscrstR {
                TscrstR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 24;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 17 - I/O port A reset"]
            #[inline ( always )]
            pub fn ioparst(&mut self) -> _IoparstW {
                _IoparstW { w: self }
            }
            #[doc = "Bit 18 - I/O port B reset"]
            #[inline ( always )]
            pub fn iopbrst(&mut self) -> _IopbrstW {
                _IopbrstW { w: self }
            }
            #[doc = "Bit 19 - I/O port C reset"]
            #[inline ( always )]
            pub fn iopcrst(&mut self) -> _IopcrstW {
                _IopcrstW { w: self }
            }
            #[doc = "Bit 20 - I/O port D reset"]
            #[inline ( always )]
            pub fn iopdrst(&mut self) -> _IopdrstW {
                _IopdrstW { w: self }
            }
            #[doc = "Bit 22 - I/O port F reset"]
            #[inline ( always )]
            pub fn iopfrst(&mut self) -> _IopfrstW {
                _IopfrstW { w: self }
            }
            #[doc = "Bit 24 - Touch sensing controller reset"]
            #[inline ( always )]
            pub fn tscrst(&mut self) -> _TscrstW {
                _TscrstW { w: self }
            }
        }
    }
    #[doc = "Clock configuration register 2"]
    pub struct Cfgr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock configuration register 2"]
    pub mod cfgr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PredivR {
            bits: u8,
        }
        impl PredivR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PredivW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PredivW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - PREDIV division factor"]
            #[inline ( always )]
            pub fn prediv(&self) -> PredivR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PredivR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - PREDIV division factor"]
            #[inline ( always )]
            pub fn prediv(&mut self) -> _PredivW {
                _PredivW { w: self }
            }
        }
    }
    #[doc = "Clock configuration register 3"]
    pub struct Cfgr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock configuration register 3"]
    pub mod cfgr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Usart1swR {
            bits: u8,
        }
        impl Usart1swR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2c1swR {
            bits: u8,
        }
        impl I2c1swR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CecswR {
            bits: u8,
        }
        impl CecswR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdcswR {
            bits: u8,
        }
        impl AdcswR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart1swW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1swW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c1swW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1swW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CecswW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecswW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcswW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcswW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - USART1 clock source selection"]
            #[inline ( always )]
            pub fn usart1sw(&self) -> Usart1swR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart1swR { bits }
            }
            #[doc = "Bit 4 - I2C1 clock source selection"]
            #[inline ( always )]
            pub fn i2c1sw(&self) -> I2c1swR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2c1swR { bits }
            }
            #[doc = "Bit 6 - HDMI CEC clock source selection"]
            #[inline ( always )]
            pub fn cecsw(&self) -> CecswR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CecswR { bits }
            }
            #[doc = "Bit 8 - ADC clock source selection"]
            #[inline ( always )]
            pub fn adcsw(&self) -> AdcswR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdcswR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - USART1 clock source selection"]
            #[inline ( always )]
            pub fn usart1sw(&mut self) -> _Usart1swW {
                _Usart1swW { w: self }
            }
            #[doc = "Bit 4 - I2C1 clock source selection"]
            #[inline ( always )]
            pub fn i2c1sw(&mut self) -> _I2c1swW {
                _I2c1swW { w: self }
            }
            #[doc = "Bit 6 - HDMI CEC clock source selection"]
            #[inline ( always )]
            pub fn cecsw(&mut self) -> _CecswW {
                _CecswW { w: self }
            }
            #[doc = "Bit 8 - ADC clock source selection"]
            #[inline ( always )]
            pub fn adcsw(&mut self) -> _AdcswW {
                _AdcswW { w: self }
            }
        }
    }
    #[doc = "Clock control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `HSI14ON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Hsi14onR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl Hsi14onR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Hsi14onR::Off => 0,
                    Hsi14onR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Hsi14onR {
                match bits {
                    0 => Hsi14onR::Off,
                    1 => Hsi14onR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == Hsi14onR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == Hsi14onR::On
            }
        }
        #[doc = "Possible values of the field `HSI14RDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Hsi14rdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl Hsi14rdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Hsi14rdyR::NotReady => 0,
                    Hsi14rdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Hsi14rdyR {
                match bits {
                    0 => Hsi14rdyR::NotReady,
                    1 => Hsi14rdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == Hsi14rdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == Hsi14rdyR::Ready
            }
        }
        #[doc = r" Value of the field"]
        pub struct Hsi14disR {
            bits: u8,
        }
        impl Hsi14disR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Hsi14trimR {
            bits: u8,
        }
        impl Hsi14trimR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Hsi14calR {
            bits: u8,
        }
        impl Hsi14calR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `HSI14ON`"]
        pub enum Hsi14onW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl Hsi14onW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Hsi14onW::Off => 0,
                    Hsi14onW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Hsi14onW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hsi14onW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Hsi14onW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(Hsi14onW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(Hsi14onW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Hsi14disW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hsi14disW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Hsi14trimW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Hsi14trimW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - HSI14 clock enable"]
            #[inline ( always )]
            pub fn hsi14on(&self) -> Hsi14onR {
                Hsi14onR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 0;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 1 - HR14 clock ready flag"]
            #[inline ( always )]
            pub fn hsi14rdy(&self) -> Hsi14rdyR {
                Hsi14rdyR::_from({
                                     const MASK: u8 = 1;
                                     const OFFSET: u8 = 1;
                                     ((self.bits >> OFFSET) & MASK as u32) as u8
                                 })
            }
            #[doc = "Bit 2 - HSI14 clock request from ADC disable"]
            #[inline ( always )]
            pub fn hsi14dis(&self) -> Hsi14disR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Hsi14disR { bits }
            }
            #[doc = "Bits 3:7 - HSI14 clock trimming"]
            #[inline ( always )]
            pub fn hsi14trim(&self) -> Hsi14trimR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Hsi14trimR { bits }
            }
            #[doc = "Bits 8:15 - HSI14 clock calibration"]
            #[inline ( always )]
            pub fn hsi14cal(&self) -> Hsi14calR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Hsi14calR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - HSI14 clock enable"]
            #[inline ( always )]
            pub fn hsi14on(&mut self) -> _Hsi14onW {
                _Hsi14onW { w: self }
            }
            #[doc = "Bit 2 - HSI14 clock request from ADC disable"]
            #[inline ( always )]
            pub fn hsi14dis(&mut self) -> _Hsi14disW {
                _Hsi14disW { w: self }
            }
            #[doc = "Bits 3:7 - HSI14 clock trimming"]
            #[inline ( always )]
            pub fn hsi14trim(&mut self) -> _Hsi14trimW {
                _Hsi14trimW { w: self }
            }
        }
    }
}
#[doc = "Reset and clock control"]
pub struct Rcc {
    register_block: rcc::RegisterBlock,
}
impl Deref for Rcc {
    type Target = rcc::RegisterBlock;
    fn deref(&self) -> &rcc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "System configuration controller"]
pub const SYSCFG: Peripheral<Syscfg> = unsafe { Peripheral::new(1073807360) };
#[doc = "System configuration controller"]
pub mod syscfg {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - configuration register 1"]
        pub cfgr1: Cfgr1,
        _reserved0: [u8; 4usize],
        #[doc = "0x08 - external interrupt configuration register 1"]
        pub exticr1: Exticr1,
        #[doc = "0x0c - external interrupt configuration register 2"]
        pub exticr2: Exticr2,
        #[doc = "0x10 - external interrupt configuration register 3"]
        pub exticr3: Exticr3,
        #[doc = "0x14 - external interrupt configuration register 4"]
        pub exticr4: Exticr4,
        #[doc = "0x18 - configuration register 2"]
        pub cfgr2: Cfgr2,
    }
    #[doc = "configuration register 1"]
    pub struct Cfgr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "configuration register 1"]
    pub mod cfgr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2cPb9FmR {
            bits: u8,
        }
        impl I2cPb9FmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2cPb8FmR {
            bits: u8,
        }
        impl I2cPb8FmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2cPb7FmR {
            bits: u8,
        }
        impl I2cPb7FmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2cPb6FmR {
            bits: u8,
        }
        impl I2cPb6FmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tim17DmaRmpR {
            bits: u8,
        }
        impl Tim17DmaRmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tim16DmaRmpR {
            bits: u8,
        }
        impl Tim16DmaRmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Usart1RxDmaRmpR {
            bits: u8,
        }
        impl Usart1RxDmaRmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Usart1TxDmaRmpR {
            bits: u8,
        }
        impl Usart1TxDmaRmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdcDmaRmpR {
            bits: u8,
        }
        impl AdcDmaRmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MemModeR {
            bits: u8,
        }
        impl MemModeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2cPb9FmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2cPb9FmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2cPb8FmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2cPb8FmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2cPb7FmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2cPb7FmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2cPb6FmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2cPb6FmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim17DmaRmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim17DmaRmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tim16DmaRmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tim16DmaRmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart1RxDmaRmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1RxDmaRmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Usart1TxDmaRmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Usart1TxDmaRmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcDmaRmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcDmaRmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MemModeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MemModeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 19 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb9_fm(&self) -> I2cPb9FmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2cPb9FmR { bits }
            }
            #[doc = "Bit 18 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb8_fm(&self) -> I2cPb8FmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2cPb8FmR { bits }
            }
            #[doc = "Bit 17 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb7_fm(&self) -> I2cPb7FmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2cPb7FmR { bits }
            }
            #[doc = "Bit 16 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb6_fm(&self) -> I2cPb6FmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2cPb6FmR { bits }
            }
            #[doc = "Bit 12 - TIM17 DMA request remapping bit"]
            #[inline ( always )]
            pub fn tim17_dma_rmp(&self) -> Tim17DmaRmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim17DmaRmpR { bits }
            }
            #[doc = "Bit 11 - TIM16 DMA request remapping bit"]
            #[inline ( always )]
            pub fn tim16_dma_rmp(&self) -> Tim16DmaRmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tim16DmaRmpR { bits }
            }
            #[doc = "Bit 10 - USART1_RX DMA request remapping bit"]
            #[inline ( always )]
            pub fn usart1_rx_dma_rmp(&self) -> Usart1RxDmaRmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart1RxDmaRmpR { bits }
            }
            #[doc = "Bit 9 - USART1_TX DMA remapping bit"]
            #[inline ( always )]
            pub fn usart1_tx_dma_rmp(&self) -> Usart1TxDmaRmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Usart1TxDmaRmpR { bits }
            }
            #[doc = "Bit 8 - ADC DMA remapping bit"]
            #[inline ( always )]
            pub fn adc_dma_rmp(&self) -> AdcDmaRmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdcDmaRmpR { bits }
            }
            #[doc = "Bits 0:1 - Memory mapping selection bits"]
            #[inline ( always )]
            pub fn mem_mode(&self) -> MemModeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MemModeR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 19 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb9_fm(&mut self) -> _I2cPb9FmW {
                _I2cPb9FmW { w: self }
            }
            #[doc = "Bit 18 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb8_fm(&mut self) -> _I2cPb8FmW {
                _I2cPb8FmW { w: self }
            }
            #[doc = "Bit 17 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb7_fm(&mut self) -> _I2cPb7FmW {
                _I2cPb7FmW { w: self }
            }
            #[doc = "Bit 16 - Fast Mode Plus (FM+) driving capability activation bits."]
            #[inline ( always )]
            pub fn i2c_pb6_fm(&mut self) -> _I2cPb6FmW {
                _I2cPb6FmW { w: self }
            }
            #[doc = "Bit 12 - TIM17 DMA request remapping bit"]
            #[inline ( always )]
            pub fn tim17_dma_rmp(&mut self) -> _Tim17DmaRmpW {
                _Tim17DmaRmpW { w: self }
            }
            #[doc = "Bit 11 - TIM16 DMA request remapping bit"]
            #[inline ( always )]
            pub fn tim16_dma_rmp(&mut self) -> _Tim16DmaRmpW {
                _Tim16DmaRmpW { w: self }
            }
            #[doc = "Bit 10 - USART1_RX DMA request remapping bit"]
            #[inline ( always )]
            pub fn usart1_rx_dma_rmp(&mut self) -> _Usart1RxDmaRmpW {
                _Usart1RxDmaRmpW { w: self }
            }
            #[doc = "Bit 9 - USART1_TX DMA remapping bit"]
            #[inline ( always )]
            pub fn usart1_tx_dma_rmp(&mut self) -> _Usart1TxDmaRmpW {
                _Usart1TxDmaRmpW { w: self }
            }
            #[doc = "Bit 8 - ADC DMA remapping bit"]
            #[inline ( always )]
            pub fn adc_dma_rmp(&mut self) -> _AdcDmaRmpW {
                _AdcDmaRmpW { w: self }
            }
            #[doc = "Bits 0:1 - Memory mapping selection bits"]
            #[inline ( always )]
            pub fn mem_mode(&mut self) -> _MemModeW {
                _MemModeW { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 1"]
    pub struct Exticr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "external interrupt configuration register 1"]
    pub mod exticr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti3R {
            bits: u8,
        }
        impl Exti3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti2R {
            bits: u8,
        }
        impl Exti2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti1R {
            bits: u8,
        }
        impl Exti1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti0R {
            bits: u8,
        }
        impl Exti0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - EXTI 3 configuration bits"]
            #[inline ( always )]
            pub fn exti3(&self) -> Exti3R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti3R { bits }
            }
            #[doc = "Bits 8:11 - EXTI 2 configuration bits"]
            #[inline ( always )]
            pub fn exti2(&self) -> Exti2R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti2R { bits }
            }
            #[doc = "Bits 4:7 - EXTI 1 configuration bits"]
            #[inline ( always )]
            pub fn exti1(&self) -> Exti1R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti1R { bits }
            }
            #[doc = "Bits 0:3 - EXTI 0 configuration bits"]
            #[inline ( always )]
            pub fn exti0(&self) -> Exti0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - EXTI 3 configuration bits"]
            #[inline ( always )]
            pub fn exti3(&mut self) -> _Exti3W {
                _Exti3W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI 2 configuration bits"]
            #[inline ( always )]
            pub fn exti2(&mut self) -> _Exti2W {
                _Exti2W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI 1 configuration bits"]
            #[inline ( always )]
            pub fn exti1(&mut self) -> _Exti1W {
                _Exti1W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI 0 configuration bits"]
            #[inline ( always )]
            pub fn exti0(&mut self) -> _Exti0W {
                _Exti0W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 2"]
    pub struct Exticr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "external interrupt configuration register 2"]
    pub mod exticr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti7R {
            bits: u8,
        }
        impl Exti7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti6R {
            bits: u8,
        }
        impl Exti6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti5R {
            bits: u8,
        }
        impl Exti5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti4R {
            bits: u8,
        }
        impl Exti4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - EXTI 7 configuration bits"]
            #[inline ( always )]
            pub fn exti7(&self) -> Exti7R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti7R { bits }
            }
            #[doc = "Bits 8:11 - EXTI 6 configuration bits"]
            #[inline ( always )]
            pub fn exti6(&self) -> Exti6R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti6R { bits }
            }
            #[doc = "Bits 4:7 - EXTI 5 configuration bits"]
            #[inline ( always )]
            pub fn exti5(&self) -> Exti5R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti5R { bits }
            }
            #[doc = "Bits 0:3 - EXTI 4 configuration bits"]
            #[inline ( always )]
            pub fn exti4(&self) -> Exti4R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti4R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - EXTI 7 configuration bits"]
            #[inline ( always )]
            pub fn exti7(&mut self) -> _Exti7W {
                _Exti7W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI 6 configuration bits"]
            #[inline ( always )]
            pub fn exti6(&mut self) -> _Exti6W {
                _Exti6W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI 5 configuration bits"]
            #[inline ( always )]
            pub fn exti5(&mut self) -> _Exti5W {
                _Exti5W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI 4 configuration bits"]
            #[inline ( always )]
            pub fn exti4(&mut self) -> _Exti4W {
                _Exti4W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 3"]
    pub struct Exticr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "external interrupt configuration register 3"]
    pub mod exticr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti11R {
            bits: u8,
        }
        impl Exti11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti10R {
            bits: u8,
        }
        impl Exti10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti9R {
            bits: u8,
        }
        impl Exti9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti8R {
            bits: u8,
        }
        impl Exti8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - EXTI 11 configuration bits"]
            #[inline ( always )]
            pub fn exti11(&self) -> Exti11R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti11R { bits }
            }
            #[doc = "Bits 8:11 - EXTI 10 configuration bits"]
            #[inline ( always )]
            pub fn exti10(&self) -> Exti10R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti10R { bits }
            }
            #[doc = "Bits 4:7 - EXTI 9 configuration bits"]
            #[inline ( always )]
            pub fn exti9(&self) -> Exti9R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti9R { bits }
            }
            #[doc = "Bits 0:3 - EXTI 8 configuration bits"]
            #[inline ( always )]
            pub fn exti8(&self) -> Exti8R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti8R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - EXTI 11 configuration bits"]
            #[inline ( always )]
            pub fn exti11(&mut self) -> _Exti11W {
                _Exti11W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI 10 configuration bits"]
            #[inline ( always )]
            pub fn exti10(&mut self) -> _Exti10W {
                _Exti10W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI 9 configuration bits"]
            #[inline ( always )]
            pub fn exti9(&mut self) -> _Exti9W {
                _Exti9W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI 8 configuration bits"]
            #[inline ( always )]
            pub fn exti8(&mut self) -> _Exti8W {
                _Exti8W { w: self }
            }
        }
    }
    #[doc = "external interrupt configuration register 4"]
    pub struct Exticr4 {
        register: VolatileCell<u32>,
    }
    #[doc = "external interrupt configuration register 4"]
    pub mod exticr4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Exticr4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti15R {
            bits: u8,
        }
        impl Exti15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti14R {
            bits: u8,
        }
        impl Exti14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti13R {
            bits: u8,
        }
        impl Exti13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Exti12R {
            bits: u8,
        }
        impl Exti12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Exti12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Exti12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - EXTI 15 configuration bits"]
            #[inline ( always )]
            pub fn exti15(&self) -> Exti15R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti15R { bits }
            }
            #[doc = "Bits 8:11 - EXTI 14 configuration bits"]
            #[inline ( always )]
            pub fn exti14(&self) -> Exti14R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti14R { bits }
            }
            #[doc = "Bits 4:7 - EXTI 13 configuration bits"]
            #[inline ( always )]
            pub fn exti13(&self) -> Exti13R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti13R { bits }
            }
            #[doc = "Bits 0:3 - EXTI 12 configuration bits"]
            #[inline ( always )]
            pub fn exti12(&self) -> Exti12R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Exti12R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - EXTI 15 configuration bits"]
            #[inline ( always )]
            pub fn exti15(&mut self) -> _Exti15W {
                _Exti15W { w: self }
            }
            #[doc = "Bits 8:11 - EXTI 14 configuration bits"]
            #[inline ( always )]
            pub fn exti14(&mut self) -> _Exti14W {
                _Exti14W { w: self }
            }
            #[doc = "Bits 4:7 - EXTI 13 configuration bits"]
            #[inline ( always )]
            pub fn exti13(&mut self) -> _Exti13W {
                _Exti13W { w: self }
            }
            #[doc = "Bits 0:3 - EXTI 12 configuration bits"]
            #[inline ( always )]
            pub fn exti12(&mut self) -> _Exti12W {
                _Exti12W { w: self }
            }
        }
    }
    #[doc = "configuration register 2"]
    pub struct Cfgr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "configuration register 2"]
    pub mod cfgr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct SramPefR {
            bits: u8,
        }
        impl SramPefR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PvdLockR {
            bits: u8,
        }
        impl PvdLockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SramParityLockR {
            bits: u8,
        }
        impl SramParityLockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LocupLockR {
            bits: u8,
        }
        impl LocupLockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SramPefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SramPefW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PvdLockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PvdLockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SramParityLockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SramParityLockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LocupLockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LocupLockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 8 - SRAM parity flag"]
            #[inline ( always )]
            pub fn sram_pef(&self) -> SramPefR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SramPefR { bits }
            }
            #[doc = "Bit 2 - PVD lock enable bit"]
            #[inline ( always )]
            pub fn pvd_lock(&self) -> PvdLockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PvdLockR { bits }
            }
            #[doc = "Bit 1 - SRAM parity lock bit"]
            #[inline ( always )]
            pub fn sram_parity_lock(&self) -> SramParityLockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SramParityLockR { bits }
            }
            #[doc = "Bit 0 - Cortex-M0 LOCKUP bit enable bit"]
            #[inline ( always )]
            pub fn locup_lock(&self) -> LocupLockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LocupLockR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 8 - SRAM parity flag"]
            #[inline ( always )]
            pub fn sram_pef(&mut self) -> _SramPefW {
                _SramPefW { w: self }
            }
            #[doc = "Bit 2 - PVD lock enable bit"]
            #[inline ( always )]
            pub fn pvd_lock(&mut self) -> _PvdLockW {
                _PvdLockW { w: self }
            }
            #[doc = "Bit 1 - SRAM parity lock bit"]
            #[inline ( always )]
            pub fn sram_parity_lock(&mut self) -> _SramParityLockW {
                _SramParityLockW { w: self }
            }
            #[doc = "Bit 0 - Cortex-M0 LOCKUP bit enable bit"]
            #[inline ( always )]
            pub fn locup_lock(&mut self) -> _LocupLockW {
                _LocupLockW { w: self }
            }
        }
    }
}
#[doc = "System configuration controller"]
pub struct Syscfg {
    register_block: syscfg::RegisterBlock,
}
impl Deref for Syscfg {
    type Target = syscfg::RegisterBlock;
    fn deref(&self) -> &syscfg::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Analog-to-digital converter"]
pub const ADC: Peripheral<Adc> = unsafe { Peripheral::new(1073816576) };
#[doc = "Analog-to-digital converter"]
pub mod adc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - interrupt and status register"]
        pub isr: Isr,
        #[doc = "0x04 - interrupt enable register"]
        pub ier: Ier,
        #[doc = "0x08 - control register"]
        pub cr: Cr,
        #[doc = "0x0c - configuration register 1"]
        pub cfgr1: Cfgr1,
        #[doc = "0x10 - configuration register 2"]
        pub cfgr2: Cfgr2,
        #[doc = "0x14 - sampling time register"]
        pub smpr: Smpr,
        _reserved0: [u8; 8usize],
        #[doc = "0x20 - watchdog threshold register"]
        pub tr: Tr,
        _reserved1: [u8; 4usize],
        #[doc = "0x28 - channel selection register"]
        pub chselr: Chselr,
        _reserved2: [u8; 20usize],
        #[doc = "0x40 - data register"]
        pub dr: Dr,
        _reserved3: [u8; 708usize],
        #[doc = "0x308 - common configuration register"]
        pub ccr: Ccr,
    }
    #[doc = "interrupt and status register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt and status register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AwdR {
            bits: u8,
        }
        impl AwdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrR {
            bits: u8,
        }
        impl OvrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EosR {
            bits: u8,
        }
        impl EosR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EocR {
            bits: u8,
        }
        impl EocR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EosmpR {
            bits: u8,
        }
        impl EosmpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ADRDY`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AdrdyR {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl AdrdyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AdrdyR::NotReady => 0,
                    AdrdyR::Ready => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AdrdyR {
                match bits {
                    0 => AdrdyR::NotReady,
                    1 => AdrdyR::Ready,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NotReady`"]
            #[inline ( always )]
            pub fn is_not_ready(&self) -> bool {
                *self == AdrdyR::NotReady
            }
            #[doc = "Checks if the value of the field is `Ready`"]
            #[inline ( always )]
            pub fn is_ready(&self) -> bool {
                *self == AdrdyR::Ready
            }
        }
        #[doc = r" Proxy"]
        pub struct _AwdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OvrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EosW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EosW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EocW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EocW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EosmpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EosmpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADRDY`"]
        pub enum AdrdyW {
            #[doc = "Not ready."]
            NotReady,
            #[doc = "ready."]
            Ready,
        }
        impl AdrdyW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AdrdyW::NotReady => 0,
                    AdrdyW::Ready => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdrdyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdrdyW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AdrdyW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Not ready."]
            #[inline ( always )]
            pub fn not_ready(self) -> &'a mut W {
                self.variant(AdrdyW::NotReady)
            }
            #[doc = "ready."]
            #[inline ( always )]
            pub fn ready(self) -> &'a mut W {
                self.variant(AdrdyW::Ready)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Analog watchdog flag"]
            #[inline ( always )]
            pub fn awd(&self) -> AwdR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdR { bits }
            }
            #[doc = "Bit 4 - ADC overrun"]
            #[inline ( always )]
            pub fn ovr(&self) -> OvrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrR { bits }
            }
            #[doc = "Bit 3 - End of sequence flag"]
            #[inline ( always )]
            pub fn eos(&self) -> EosR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EosR { bits }
            }
            #[doc = "Bit 2 - End of conversion flag"]
            #[inline ( always )]
            pub fn eoc(&self) -> EocR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EocR { bits }
            }
            #[doc = "Bit 1 - End of sampling flag"]
            #[inline ( always )]
            pub fn eosmp(&self) -> EosmpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EosmpR { bits }
            }
            #[doc = "Bit 0 - ADC ready"]
            #[inline ( always )]
            pub fn adrdy(&self) -> AdrdyR {
                AdrdyR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Analog watchdog flag"]
            #[inline ( always )]
            pub fn awd(&mut self) -> _AwdW {
                _AwdW { w: self }
            }
            #[doc = "Bit 4 - ADC overrun"]
            #[inline ( always )]
            pub fn ovr(&mut self) -> _OvrW {
                _OvrW { w: self }
            }
            #[doc = "Bit 3 - End of sequence flag"]
            #[inline ( always )]
            pub fn eos(&mut self) -> _EosW {
                _EosW { w: self }
            }
            #[doc = "Bit 2 - End of conversion flag"]
            #[inline ( always )]
            pub fn eoc(&mut self) -> _EocW {
                _EocW { w: self }
            }
            #[doc = "Bit 1 - End of sampling flag"]
            #[inline ( always )]
            pub fn eosmp(&mut self) -> _EosmpW {
                _EosmpW { w: self }
            }
            #[doc = "Bit 0 - ADC ready"]
            #[inline ( always )]
            pub fn adrdy(&mut self) -> _AdrdyW {
                _AdrdyW { w: self }
            }
        }
    }
    #[doc = "interrupt enable register"]
    pub struct Ier {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt enable register"]
    pub mod ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AwdieR {
            bits: u8,
        }
        impl AwdieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrieR {
            bits: u8,
        }
        impl OvrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EosieR {
            bits: u8,
        }
        impl EosieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EocieR {
            bits: u8,
        }
        impl EocieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EosmpieR {
            bits: u8,
        }
        impl EosmpieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdrdyieR {
            bits: u8,
        }
        impl AdrdyieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AwdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OvrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EosieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EosieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EocieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EocieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EosmpieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EosmpieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdrdyieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdrdyieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Analog watchdog interrupt enable"]
            #[inline ( always )]
            pub fn awdie(&self) -> AwdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdieR { bits }
            }
            #[doc = "Bit 4 - Overrun interrupt enable"]
            #[inline ( always )]
            pub fn ovrie(&self) -> OvrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrieR { bits }
            }
            #[doc = "Bit 3 - End of conversion sequence interrupt enable"]
            #[inline ( always )]
            pub fn eosie(&self) -> EosieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EosieR { bits }
            }
            #[doc = "Bit 2 - End of conversion interrupt enable"]
            #[inline ( always )]
            pub fn eocie(&self) -> EocieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EocieR { bits }
            }
            #[doc = "Bit 1 - End of sampling flag interrupt enable"]
            #[inline ( always )]
            pub fn eosmpie(&self) -> EosmpieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EosmpieR { bits }
            }
            #[doc = "Bit 0 - ADC ready interrupt enable"]
            #[inline ( always )]
            pub fn adrdyie(&self) -> AdrdyieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdrdyieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Analog watchdog interrupt enable"]
            #[inline ( always )]
            pub fn awdie(&mut self) -> _AwdieW {
                _AwdieW { w: self }
            }
            #[doc = "Bit 4 - Overrun interrupt enable"]
            #[inline ( always )]
            pub fn ovrie(&mut self) -> _OvrieW {
                _OvrieW { w: self }
            }
            #[doc = "Bit 3 - End of conversion sequence interrupt enable"]
            #[inline ( always )]
            pub fn eosie(&mut self) -> _EosieW {
                _EosieW { w: self }
            }
            #[doc = "Bit 2 - End of conversion interrupt enable"]
            #[inline ( always )]
            pub fn eocie(&mut self) -> _EocieW {
                _EocieW { w: self }
            }
            #[doc = "Bit 1 - End of sampling flag interrupt enable"]
            #[inline ( always )]
            pub fn eosmpie(&mut self) -> _EosmpieW {
                _EosmpieW { w: self }
            }
            #[doc = "Bit 0 - ADC ready interrupt enable"]
            #[inline ( always )]
            pub fn adrdyie(&mut self) -> _AdrdyieW {
                _AdrdyieW { w: self }
            }
        }
    }
    #[doc = "control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdcalR {
            bits: u8,
        }
        impl AdcalR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdstpR {
            bits: u8,
        }
        impl AdstpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AdstartR {
            bits: u8,
        }
        impl AdstartR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AddisR {
            bits: u8,
        }
        impl AddisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ADEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AdenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AdenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AdenR::Disabled => 0,
                    AdenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AdenR {
                match bits {
                    0 => AdenR::Disabled,
                    1 => AdenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == AdenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == AdenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdcalW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdcalW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdstpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdstpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdstartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdstartW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AddisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AddisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADEN`"]
        pub enum AdenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AdenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AdenW::Disabled => 0,
                    AdenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AdenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AdenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AdenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AdenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 31 - ADC calibration"]
            #[inline ( always )]
            pub fn adcal(&self) -> AdcalR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdcalR { bits }
            }
            #[doc = "Bit 4 - ADC stop conversion command"]
            #[inline ( always )]
            pub fn adstp(&self) -> AdstpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdstpR { bits }
            }
            #[doc = "Bit 2 - ADC start conversion command"]
            #[inline ( always )]
            pub fn adstart(&self) -> AdstartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AdstartR { bits }
            }
            #[doc = "Bit 1 - ADC disable command"]
            #[inline ( always )]
            pub fn addis(&self) -> AddisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AddisR { bits }
            }
            #[doc = "Bit 0 - ADC enable command"]
            #[inline ( always )]
            pub fn aden(&self) -> AdenR {
                AdenR::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 0;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - ADC calibration"]
            #[inline ( always )]
            pub fn adcal(&mut self) -> _AdcalW {
                _AdcalW { w: self }
            }
            #[doc = "Bit 4 - ADC stop conversion command"]
            #[inline ( always )]
            pub fn adstp(&mut self) -> _AdstpW {
                _AdstpW { w: self }
            }
            #[doc = "Bit 2 - ADC start conversion command"]
            #[inline ( always )]
            pub fn adstart(&mut self) -> _AdstartW {
                _AdstartW { w: self }
            }
            #[doc = "Bit 1 - ADC disable command"]
            #[inline ( always )]
            pub fn addis(&mut self) -> _AddisW {
                _AddisW { w: self }
            }
            #[doc = "Bit 0 - ADC enable command"]
            #[inline ( always )]
            pub fn aden(&mut self) -> _AdenW {
                _AdenW { w: self }
            }
        }
    }
    #[doc = "configuration register 1"]
    pub struct Cfgr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "configuration register 1"]
    pub mod cfgr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AwdchR {
            bits: u8,
        }
        impl AwdchR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `AWDEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AwdenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AwdenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AwdenR::Disabled => 0,
                    AwdenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AwdenR {
                match bits {
                    0 => AwdenR::Disabled,
                    1 => AwdenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == AwdenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == AwdenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct AwdsglR {
            bits: u8,
        }
        impl AwdsglR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `DISCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DiscenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DiscenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DiscenR::Disabled => 0,
                    DiscenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DiscenR {
                match bits {
                    0 => DiscenR::Disabled,
                    1 => DiscenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == DiscenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == DiscenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct AutoffR {
            bits: u8,
        }
        impl AutoffR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AutdlyR {
            bits: u8,
        }
        impl AutdlyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ContR {
            bits: u8,
        }
        impl ContR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrmodR {
            bits: u8,
        }
        impl OvrmodR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ExtenR {
            bits: u8,
        }
        impl ExtenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ExtselR {
            bits: u8,
        }
        impl ExtselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlignR {
            bits: u8,
        }
        impl AlignR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ResR {
            bits: u8,
        }
        impl ResR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ScandirR {
            bits: u8,
        }
        impl ScandirR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmacfgR {
            bits: u8,
        }
        impl DmacfgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `DMAEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum DmaenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DmaenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    DmaenR::Disabled => 0,
                    DmaenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> DmaenR {
                match bits {
                    0 => DmaenR::Disabled,
                    1 => DmaenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == DmaenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == DmaenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _AwdchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdchW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AWDEN`"]
        pub enum AwdenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AwdenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AwdenW::Disabled => 0,
                    AwdenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AwdenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AwdenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AwdenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AwdenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AwdsglW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AwdsglW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISCEN`"]
        pub enum DiscenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DiscenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DiscenW::Disabled => 0,
                    DiscenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DiscenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DiscenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DiscenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DiscenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DiscenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AutoffW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AutoffW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AutdlyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AutdlyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ContW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ContW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OvrmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrmodW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ExtenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtenW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ExtselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ExtselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlignW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlignW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ResW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ResW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ScandirW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScandirW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmacfgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmacfgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DMAEN`"]
        pub enum DmaenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl DmaenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DmaenW::Disabled => 0,
                    DmaenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmaenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmaenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: DmaenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DmaenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DmaenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 26:30 - Analog watchdog channel selection"]
            #[inline ( always )]
            pub fn awdch(&self) -> AwdchR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdchR { bits }
            }
            #[doc = "Bit 23 - Analog watchdog enable"]
            #[inline ( always )]
            pub fn awden(&self) -> AwdenR {
                AwdenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 23;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 22 - Enable the watchdog on a single channel or on all channels"]
            #[inline ( always )]
            pub fn awdsgl(&self) -> AwdsglR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AwdsglR { bits }
            }
            #[doc = "Bit 16 - Discontinuous mode"]
            #[inline ( always )]
            pub fn discen(&self) -> DiscenR {
                DiscenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 16;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 15 - Auto-off mode"]
            #[inline ( always )]
            pub fn autoff(&self) -> AutoffR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AutoffR { bits }
            }
            #[doc = "Bit 14 - Auto-delayed conversion mode"]
            #[inline ( always )]
            pub fn autdly(&self) -> AutdlyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AutdlyR { bits }
            }
            #[doc = "Bit 13 - Single / continuous conversion mode"]
            #[inline ( always )]
            pub fn cont(&self) -> ContR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ContR { bits }
            }
            #[doc = "Bit 12 - Overrun management mode"]
            #[inline ( always )]
            pub fn ovrmod(&self) -> OvrmodR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrmodR { bits }
            }
            #[doc = "Bits 10:11 - External trigger enable and polarity selection"]
            #[inline ( always )]
            pub fn exten(&self) -> ExtenR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtenR { bits }
            }
            #[doc = "Bits 6:8 - External trigger selection"]
            #[inline ( always )]
            pub fn extsel(&self) -> ExtselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ExtselR { bits }
            }
            #[doc = "Bit 5 - Data alignment"]
            #[inline ( always )]
            pub fn align(&self) -> AlignR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlignR { bits }
            }
            #[doc = "Bits 3:4 - Data resolution"]
            #[inline ( always )]
            pub fn res(&self) -> ResR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ResR { bits }
            }
            #[doc = "Bit 2 - Scan sequence direction"]
            #[inline ( always )]
            pub fn scandir(&self) -> ScandirR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScandirR { bits }
            }
            #[doc = "Bit 1 - Direct memery access configuration"]
            #[inline ( always )]
            pub fn dmacfg(&self) -> DmacfgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmacfgR { bits }
            }
            #[doc = "Bit 0 - Direct memory access enable"]
            #[inline ( always )]
            pub fn dmaen(&self) -> DmaenR {
                DmaenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 26:30 - Analog watchdog channel selection"]
            #[inline ( always )]
            pub fn awdch(&mut self) -> _AwdchW {
                _AwdchW { w: self }
            }
            #[doc = "Bit 23 - Analog watchdog enable"]
            #[inline ( always )]
            pub fn awden(&mut self) -> _AwdenW {
                _AwdenW { w: self }
            }
            #[doc = "Bit 22 - Enable the watchdog on a single channel or on all channels"]
            #[inline ( always )]
            pub fn awdsgl(&mut self) -> _AwdsglW {
                _AwdsglW { w: self }
            }
            #[doc = "Bit 16 - Discontinuous mode"]
            #[inline ( always )]
            pub fn discen(&mut self) -> _DiscenW {
                _DiscenW { w: self }
            }
            #[doc = "Bit 15 - Auto-off mode"]
            #[inline ( always )]
            pub fn autoff(&mut self) -> _AutoffW {
                _AutoffW { w: self }
            }
            #[doc = "Bit 14 - Auto-delayed conversion mode"]
            #[inline ( always )]
            pub fn autdly(&mut self) -> _AutdlyW {
                _AutdlyW { w: self }
            }
            #[doc = "Bit 13 - Single / continuous conversion mode"]
            #[inline ( always )]
            pub fn cont(&mut self) -> _ContW {
                _ContW { w: self }
            }
            #[doc = "Bit 12 - Overrun management mode"]
            #[inline ( always )]
            pub fn ovrmod(&mut self) -> _OvrmodW {
                _OvrmodW { w: self }
            }
            #[doc = "Bits 10:11 - External trigger enable and polarity selection"]
            #[inline ( always )]
            pub fn exten(&mut self) -> _ExtenW {
                _ExtenW { w: self }
            }
            #[doc = "Bits 6:8 - External trigger selection"]
            #[inline ( always )]
            pub fn extsel(&mut self) -> _ExtselW {
                _ExtselW { w: self }
            }
            #[doc = "Bit 5 - Data alignment"]
            #[inline ( always )]
            pub fn align(&mut self) -> _AlignW {
                _AlignW { w: self }
            }
            #[doc = "Bits 3:4 - Data resolution"]
            #[inline ( always )]
            pub fn res(&mut self) -> _ResW {
                _ResW { w: self }
            }
            #[doc = "Bit 2 - Scan sequence direction"]
            #[inline ( always )]
            pub fn scandir(&mut self) -> _ScandirW {
                _ScandirW { w: self }
            }
            #[doc = "Bit 1 - Direct memery access configuration"]
            #[inline ( always )]
            pub fn dmacfg(&mut self) -> _DmacfgW {
                _DmacfgW { w: self }
            }
            #[doc = "Bit 0 - Direct memory access enable"]
            #[inline ( always )]
            pub fn dmaen(&mut self) -> _DmaenW {
                _DmaenW { w: self }
            }
        }
    }
    #[doc = "configuration register 2"]
    pub struct Cfgr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "configuration register 2"]
    pub mod cfgr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct JitoffD4R {
            bits: u8,
        }
        impl JitoffD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct JitoffD2R {
            bits: u8,
        }
        impl JitoffD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _JitoffD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JitoffD4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _JitoffD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _JitoffD2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 31 - JITOFF_D4"]
            #[inline ( always )]
            pub fn jitoff_d4(&self) -> JitoffD4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JitoffD4R { bits }
            }
            #[doc = "Bit 30 - JITOFF_D2"]
            #[inline ( always )]
            pub fn jitoff_d2(&self) -> JitoffD2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                JitoffD2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 32768 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - JITOFF_D4"]
            #[inline ( always )]
            pub fn jitoff_d4(&mut self) -> _JitoffD4W {
                _JitoffD4W { w: self }
            }
            #[doc = "Bit 30 - JITOFF_D2"]
            #[inline ( always )]
            pub fn jitoff_d2(&mut self) -> _JitoffD2W {
                _JitoffD2W { w: self }
            }
        }
    }
    #[doc = "sampling time register"]
    pub struct Smpr {
        register: VolatileCell<u32>,
    }
    #[doc = "sampling time register"]
    pub mod smpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Smpr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct SmprR {
            bits: u8,
        }
        impl SmprR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmprW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmprW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Sampling time selection"]
            #[inline ( always )]
            pub fn smpr(&self) -> SmprR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmprR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Sampling time selection"]
            #[inline ( always )]
            pub fn smpr(&mut self) -> _SmprW {
                _SmprW { w: self }
            }
        }
    }
    #[doc = "watchdog threshold register"]
    pub struct Tr {
        register: VolatileCell<u32>,
    }
    #[doc = "watchdog threshold register"]
    pub mod tr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Tr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtR {
            bits: u16,
        }
        impl HtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LtR {
            bits: u16,
        }
        impl LtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:27 - Analog watchdog higher threshold"]
            #[inline ( always )]
            pub fn ht(&self) -> HtR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                HtR { bits }
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline ( always )]
            pub fn lt(&self) -> LtR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LtR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4095 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:27 - Analog watchdog higher threshold"]
            #[inline ( always )]
            pub fn ht(&mut self) -> _HtW {
                _HtW { w: self }
            }
            #[doc = "Bits 0:11 - Analog watchdog lower threshold"]
            #[inline ( always )]
            pub fn lt(&mut self) -> _LtW {
                _LtW { w: self }
            }
        }
    }
    #[doc = "channel selection register"]
    pub struct Chselr {
        register: VolatileCell<u32>,
    }
    #[doc = "channel selection register"]
    pub mod chselr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Chselr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel18R {
            bits: u8,
        }
        impl Chsel18R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel17R {
            bits: u8,
        }
        impl Chsel17R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel16R {
            bits: u8,
        }
        impl Chsel16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel15R {
            bits: u8,
        }
        impl Chsel15R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel14R {
            bits: u8,
        }
        impl Chsel14R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel13R {
            bits: u8,
        }
        impl Chsel13R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel12R {
            bits: u8,
        }
        impl Chsel12R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel11R {
            bits: u8,
        }
        impl Chsel11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel10R {
            bits: u8,
        }
        impl Chsel10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel9R {
            bits: u8,
        }
        impl Chsel9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel8R {
            bits: u8,
        }
        impl Chsel8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel7R {
            bits: u8,
        }
        impl Chsel7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel6R {
            bits: u8,
        }
        impl Chsel6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel5R {
            bits: u8,
        }
        impl Chsel5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel4R {
            bits: u8,
        }
        impl Chsel4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel3R {
            bits: u8,
        }
        impl Chsel3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel2R {
            bits: u8,
        }
        impl Chsel2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel1R {
            bits: u8,
        }
        impl Chsel1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Chsel0R {
            bits: u8,
        }
        impl Chsel0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel18W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel17W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel16W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel15W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel14W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel13W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel12W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel11W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel10W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel9W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Chsel0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Chsel0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 18 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel18(&self) -> Chsel18R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel18R { bits }
            }
            #[doc = "Bit 17 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel17(&self) -> Chsel17R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel17R { bits }
            }
            #[doc = "Bit 16 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel16(&self) -> Chsel16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel16R { bits }
            }
            #[doc = "Bit 15 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel15(&self) -> Chsel15R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel15R { bits }
            }
            #[doc = "Bit 14 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel14(&self) -> Chsel14R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel14R { bits }
            }
            #[doc = "Bit 13 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel13(&self) -> Chsel13R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel13R { bits }
            }
            #[doc = "Bit 12 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel12(&self) -> Chsel12R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel12R { bits }
            }
            #[doc = "Bit 11 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel11(&self) -> Chsel11R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel11R { bits }
            }
            #[doc = "Bit 10 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel10(&self) -> Chsel10R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel10R { bits }
            }
            #[doc = "Bit 9 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel9(&self) -> Chsel9R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel9R { bits }
            }
            #[doc = "Bit 8 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel8(&self) -> Chsel8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel8R { bits }
            }
            #[doc = "Bit 7 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel7(&self) -> Chsel7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel7R { bits }
            }
            #[doc = "Bit 6 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel6(&self) -> Chsel6R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel6R { bits }
            }
            #[doc = "Bit 5 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel5(&self) -> Chsel5R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel5R { bits }
            }
            #[doc = "Bit 4 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel4(&self) -> Chsel4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel4R { bits }
            }
            #[doc = "Bit 3 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel3(&self) -> Chsel3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel3R { bits }
            }
            #[doc = "Bit 2 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel2(&self) -> Chsel2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel2R { bits }
            }
            #[doc = "Bit 1 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel1(&self) -> Chsel1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel1R { bits }
            }
            #[doc = "Bit 0 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel0(&self) -> Chsel0R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Chsel0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 18 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel18(&mut self) -> _Chsel18W {
                _Chsel18W { w: self }
            }
            #[doc = "Bit 17 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel17(&mut self) -> _Chsel17W {
                _Chsel17W { w: self }
            }
            #[doc = "Bit 16 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel16(&mut self) -> _Chsel16W {
                _Chsel16W { w: self }
            }
            #[doc = "Bit 15 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel15(&mut self) -> _Chsel15W {
                _Chsel15W { w: self }
            }
            #[doc = "Bit 14 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel14(&mut self) -> _Chsel14W {
                _Chsel14W { w: self }
            }
            #[doc = "Bit 13 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel13(&mut self) -> _Chsel13W {
                _Chsel13W { w: self }
            }
            #[doc = "Bit 12 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel12(&mut self) -> _Chsel12W {
                _Chsel12W { w: self }
            }
            #[doc = "Bit 11 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel11(&mut self) -> _Chsel11W {
                _Chsel11W { w: self }
            }
            #[doc = "Bit 10 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel10(&mut self) -> _Chsel10W {
                _Chsel10W { w: self }
            }
            #[doc = "Bit 9 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel9(&mut self) -> _Chsel9W {
                _Chsel9W { w: self }
            }
            #[doc = "Bit 8 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel8(&mut self) -> _Chsel8W {
                _Chsel8W { w: self }
            }
            #[doc = "Bit 7 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel7(&mut self) -> _Chsel7W {
                _Chsel7W { w: self }
            }
            #[doc = "Bit 6 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel6(&mut self) -> _Chsel6W {
                _Chsel6W { w: self }
            }
            #[doc = "Bit 5 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel5(&mut self) -> _Chsel5W {
                _Chsel5W { w: self }
            }
            #[doc = "Bit 4 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel4(&mut self) -> _Chsel4W {
                _Chsel4W { w: self }
            }
            #[doc = "Bit 3 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel3(&mut self) -> _Chsel3W {
                _Chsel3W { w: self }
            }
            #[doc = "Bit 2 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel2(&mut self) -> _Chsel2W {
                _Chsel2W { w: self }
            }
            #[doc = "Bit 1 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel1(&mut self) -> _Chsel1W {
                _Chsel1W { w: self }
            }
            #[doc = "Bit 0 - Channel-x selection"]
            #[inline ( always )]
            pub fn chsel0(&mut self) -> _Chsel0W {
                _Chsel0W { w: self }
            }
        }
    }
    #[doc = "data register"]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    #[doc = "data register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Dr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DataR {
            bits: u16,
        }
        impl DataR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Converted data"]
            #[inline ( always )]
            pub fn data(&self) -> DataR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DataR { bits }
            }
        }
    }
    #[doc = "common configuration register"]
    pub struct Ccr {
        register: VolatileCell<u32>,
    }
    #[doc = "common configuration register"]
    pub mod ccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `VBATEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum VbatenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl VbatenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    VbatenR::Disabled => 0,
                    VbatenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> VbatenR {
                match bits {
                    0 => VbatenR::Disabled,
                    1 => VbatenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == VbatenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == VbatenR::Enabled
            }
        }
        #[doc = "Possible values of the field `TSEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum TsenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TsenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    TsenR::Disabled => 0,
                    TsenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> TsenR {
                match bits {
                    0 => TsenR::Disabled,
                    1 => TsenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == TsenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == TsenR::Enabled
            }
        }
        #[doc = "Possible values of the field `VREFEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum VrefenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl VrefenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    VrefenR::Disabled => 0,
                    VrefenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> VrefenR {
                match bits {
                    0 => VrefenR::Disabled,
                    1 => VrefenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == VrefenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == VrefenR::Enabled
            }
        }
        #[doc = "Values that can be written to the field `VBATEN`"]
        pub enum VbatenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl VbatenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    VbatenW::Disabled => 0,
                    VbatenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VbatenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VbatenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: VbatenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(VbatenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(VbatenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TSEN`"]
        pub enum TsenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl TsenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TsenW::Disabled => 0,
                    TsenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: TsenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TsenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TsenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `VREFEN`"]
        pub enum VrefenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl VrefenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    VrefenW::Disabled => 0,
                    VrefenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VrefenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VrefenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: VrefenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(VrefenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(VrefenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 24 - VBAT enable"]
            #[inline ( always )]
            pub fn vbaten(&self) -> VbatenR {
                VbatenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 24;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 23 - Temperature sensor enable"]
            #[inline ( always )]
            pub fn tsen(&self) -> TsenR {
                TsenR::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 23;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 22 - Temperature sensor and VREFINT enable"]
            #[inline ( always )]
            pub fn vrefen(&self) -> VrefenR {
                VrefenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 22;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 24 - VBAT enable"]
            #[inline ( always )]
            pub fn vbaten(&mut self) -> _VbatenW {
                _VbatenW { w: self }
            }
            #[doc = "Bit 23 - Temperature sensor enable"]
            #[inline ( always )]
            pub fn tsen(&mut self) -> _TsenW {
                _TsenW { w: self }
            }
            #[doc = "Bit 22 - Temperature sensor and VREFINT enable"]
            #[inline ( always )]
            pub fn vrefen(&mut self) -> _VrefenW {
                _VrefenW { w: self }
            }
        }
    }
}
#[doc = "Analog-to-digital converter"]
pub struct Adc {
    register_block: adc::RegisterBlock,
}
impl Deref for Adc {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub const USART1: Peripheral<Usart1> = unsafe { Peripheral::new(1073821696) };
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub mod usart1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - Control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - Control register 3"]
        pub cr3: Cr3,
        #[doc = "0x0c - Baud rate register"]
        pub brr: Brr,
        #[doc = "0x10 - Guard time and prescaler register"]
        pub gtpr: Gtpr,
        #[doc = "0x14 - Receiver timeout register"]
        pub rtor: Rtor,
        #[doc = "0x18 - Request register"]
        pub rqr: Rqr,
        #[doc = "0x1c - Interrupt & status register"]
        pub isr: Isr,
        #[doc = "0x20 - Interrupt flag clear register"]
        pub icr: Icr,
        #[doc = "0x24 - Receive data register"]
        pub rdr: Rdr,
        #[doc = "0x28 - Transmit data register"]
        pub tdr: Tdr,
    }
    #[doc = "Control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EobieR {
            bits: u8,
        }
        impl EobieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtoieR {
            bits: u8,
        }
        impl RtoieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DeatR {
            bits: u8,
        }
        impl DeatR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DedtR {
            bits: u8,
        }
        impl DedtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Over8R {
            bits: u8,
        }
        impl Over8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CmieR {
            bits: u8,
        }
        impl CmieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmeR {
            bits: u8,
        }
        impl MmeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR {
            bits: u8,
        }
        impl MR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WakeR {
            bits: u8,
        }
        impl WakeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PceR {
            bits: u8,
        }
        impl PceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PsR {
            bits: u8,
        }
        impl PsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PeieR {
            bits: u8,
        }
        impl PeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeieR {
            bits: u8,
        }
        impl TxeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcieR {
            bits: u8,
        }
        impl TcieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxneieR {
            bits: u8,
        }
        impl RxneieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IdleieR {
            bits: u8,
        }
        impl IdleieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeR {
            bits: u8,
        }
        impl TeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ReR {
            bits: u8,
        }
        impl ReR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UesmR {
            bits: u8,
        }
        impl UesmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UeR {
            bits: u8,
        }
        impl UeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EobieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EobieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtoieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtoieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DeatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DeatW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DedtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DedtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Over8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Over8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CmieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WakeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WakeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TcieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TcieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxneieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxneieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IdleieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdleieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ReW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ReW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UesmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UesmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 27 - End of Block interrupt enable"]
            #[inline ( always )]
            pub fn eobie(&self) -> EobieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EobieR { bits }
            }
            #[doc = "Bit 26 - Receiver timeout interrupt enable"]
            #[inline ( always )]
            pub fn rtoie(&self) -> RtoieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtoieR { bits }
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline ( always )]
            pub fn deat(&self) -> DeatR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DeatR { bits }
            }
            #[doc = "Bits 16:20 - Driver Enable deassertion time"]
            #[inline ( always )]
            pub fn dedt(&self) -> DedtR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DedtR { bits }
            }
            #[doc = "Bit 15 - Oversampling mode"]
            #[inline ( always )]
            pub fn over8(&self) -> Over8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Over8R { bits }
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline ( always )]
            pub fn cmie(&self) -> CmieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmieR { bits }
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline ( always )]
            pub fn mme(&self) -> MmeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmeR { bits }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline ( always )]
            pub fn m(&self) -> MR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MR { bits }
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline ( always )]
            pub fn wake(&self) -> WakeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WakeR { bits }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline ( always )]
            pub fn pce(&self) -> PceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PceR { bits }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline ( always )]
            pub fn ps(&self) -> PsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PsR { bits }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline ( always )]
            pub fn peie(&self) -> PeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeieR { bits }
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline ( always )]
            pub fn txeie(&self) -> TxeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeieR { bits }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&self) -> TcieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcieR { bits }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline ( always )]
            pub fn rxneie(&self) -> RxneieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneieR { bits }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline ( always )]
            pub fn idleie(&self) -> IdleieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleieR { bits }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline ( always )]
            pub fn te(&self) -> TeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeR { bits }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline ( always )]
            pub fn re(&self) -> ReR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReR { bits }
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline ( always )]
            pub fn uesm(&self) -> UesmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UesmR { bits }
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline ( always )]
            pub fn ue(&self) -> UeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UeR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 27 - End of Block interrupt enable"]
            #[inline ( always )]
            pub fn eobie(&mut self) -> _EobieW {
                _EobieW { w: self }
            }
            #[doc = "Bit 26 - Receiver timeout interrupt enable"]
            #[inline ( always )]
            pub fn rtoie(&mut self) -> _RtoieW {
                _RtoieW { w: self }
            }
            #[doc = "Bits 21:25 - Driver Enable assertion time"]
            #[inline ( always )]
            pub fn deat(&mut self) -> _DeatW {
                _DeatW { w: self }
            }
            #[doc = "Bits 16:20 - Driver Enable deassertion time"]
            #[inline ( always )]
            pub fn dedt(&mut self) -> _DedtW {
                _DedtW { w: self }
            }
            #[doc = "Bit 15 - Oversampling mode"]
            #[inline ( always )]
            pub fn over8(&mut self) -> _Over8W {
                _Over8W { w: self }
            }
            #[doc = "Bit 14 - Character match interrupt enable"]
            #[inline ( always )]
            pub fn cmie(&mut self) -> _CmieW {
                _CmieW { w: self }
            }
            #[doc = "Bit 13 - Mute mode enable"]
            #[inline ( always )]
            pub fn mme(&mut self) -> _MmeW {
                _MmeW { w: self }
            }
            #[doc = "Bit 12 - Word length"]
            #[inline ( always )]
            pub fn m(&mut self) -> _MW {
                _MW { w: self }
            }
            #[doc = "Bit 11 - Receiver wakeup method"]
            #[inline ( always )]
            pub fn wake(&mut self) -> _WakeW {
                _WakeW { w: self }
            }
            #[doc = "Bit 10 - Parity control enable"]
            #[inline ( always )]
            pub fn pce(&mut self) -> _PceW {
                _PceW { w: self }
            }
            #[doc = "Bit 9 - Parity selection"]
            #[inline ( always )]
            pub fn ps(&mut self) -> _PsW {
                _PsW { w: self }
            }
            #[doc = "Bit 8 - PE interrupt enable"]
            #[inline ( always )]
            pub fn peie(&mut self) -> _PeieW {
                _PeieW { w: self }
            }
            #[doc = "Bit 7 - interrupt enable"]
            #[inline ( always )]
            pub fn txeie(&mut self) -> _TxeieW {
                _TxeieW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete interrupt enable"]
            #[inline ( always )]
            pub fn tcie(&mut self) -> _TcieW {
                _TcieW { w: self }
            }
            #[doc = "Bit 5 - RXNE interrupt enable"]
            #[inline ( always )]
            pub fn rxneie(&mut self) -> _RxneieW {
                _RxneieW { w: self }
            }
            #[doc = "Bit 4 - IDLE interrupt enable"]
            #[inline ( always )]
            pub fn idleie(&mut self) -> _IdleieW {
                _IdleieW { w: self }
            }
            #[doc = "Bit 3 - Transmitter enable"]
            #[inline ( always )]
            pub fn te(&mut self) -> _TeW {
                _TeW { w: self }
            }
            #[doc = "Bit 2 - Receiver enable"]
            #[inline ( always )]
            pub fn re(&mut self) -> _ReW {
                _ReW { w: self }
            }
            #[doc = "Bit 1 - USART enable in Stop mode"]
            #[inline ( always )]
            pub fn uesm(&mut self) -> _UesmW {
                _UesmW { w: self }
            }
            #[doc = "Bit 0 - USART enable"]
            #[inline ( always )]
            pub fn ue(&mut self) -> _UeW {
                _UeW { w: self }
            }
        }
    }
    #[doc = "Control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Add4R {
            bits: u8,
        }
        impl Add4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Add0R {
            bits: u8,
        }
        impl Add0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `RTOEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum RtoenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RtoenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    RtoenR::Disabled => 0,
                    RtoenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> RtoenR {
                match bits {
                    0 => RtoenR::Disabled,
                    1 => RtoenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == RtoenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == RtoenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct AbrmodR {
            bits: u8,
        }
        impl AbrmodR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ABREN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum AbrenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AbrenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    AbrenR::Disabled => 0,
                    AbrenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> AbrenR {
                match bits {
                    0 => AbrenR::Disabled,
                    1 => AbrenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == AbrenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == AbrenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsbfirstR {
            bits: u8,
        }
        impl MsbfirstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DatainvR {
            bits: u8,
        }
        impl DatainvR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxinvR {
            bits: u8,
        }
        impl TxinvR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxinvR {
            bits: u8,
        }
        impl RxinvR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SwapR {
            bits: u8,
        }
        impl SwapR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LINEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LinenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl LinenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LinenR::Disabled => 0,
                    LinenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LinenR {
                match bits {
                    0 => LinenR::Disabled,
                    1 => LinenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == LinenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == LinenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct StopR {
            bits: u8,
        }
        impl StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CLKEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum ClkenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl ClkenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    ClkenR::Disabled => 0,
                    ClkenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> ClkenR {
                match bits {
                    0 => ClkenR::Disabled,
                    1 => ClkenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == ClkenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == ClkenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct CpolR {
            bits: u8,
        }
        impl CpolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CphaR {
            bits: u8,
        }
        impl CphaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbclR {
            bits: u8,
        }
        impl LbclR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbdieR {
            bits: u8,
        }
        impl LbdieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbdlR {
            bits: u8,
        }
        impl LbdlR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Addm7R {
            bits: u8,
        }
        impl Addm7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Add4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Add0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RTOEN`"]
        pub enum RtoenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl RtoenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RtoenW::Disabled => 0,
                    RtoenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtoenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtoenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: RtoenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RtoenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RtoenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AbrmodW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AbrmodW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ABREN`"]
        pub enum AbrenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl AbrenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    AbrenW::Disabled => 0,
                    AbrenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AbrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AbrenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: AbrenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AbrenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AbrenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsbfirstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsbfirstW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DatainvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DatainvW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxinvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxinvW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxinvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxinvW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SwapW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SwapW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LINEN`"]
        pub enum LinenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl LinenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LinenW::Disabled => 0,
                    LinenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LinenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LinenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LinenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LinenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LinenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKEN`"]
        pub enum ClkenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl ClkenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ClkenW::Disabled => 0,
                    ClkenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ClkenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ClkenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: ClkenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ClkenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ClkenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CpolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CphaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CphaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbclW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbclW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbdieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbdlW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdlW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Addm7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Addm7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Address of the USART node"]
            #[inline ( always )]
            pub fn add4(&self) -> Add4R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add4R { bits }
            }
            #[doc = "Bits 24:27 - Address of the USART node"]
            #[inline ( always )]
            pub fn add0(&self) -> Add0R {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Add0R { bits }
            }
            #[doc = "Bit 23 - Receiver timeout enable"]
            #[inline ( always )]
            pub fn rtoen(&self) -> RtoenR {
                RtoenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 23;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bits 21:22 - Auto baud rate mode"]
            #[inline ( always )]
            pub fn abrmod(&self) -> AbrmodR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AbrmodR { bits }
            }
            #[doc = "Bit 20 - Auto baud rate enable"]
            #[inline ( always )]
            pub fn abren(&self) -> AbrenR {
                AbrenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 20;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline ( always )]
            pub fn msbfirst(&self) -> MsbfirstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsbfirstR { bits }
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline ( always )]
            pub fn datainv(&self) -> DatainvR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DatainvR { bits }
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline ( always )]
            pub fn txinv(&self) -> TxinvR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxinvR { bits }
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline ( always )]
            pub fn rxinv(&self) -> RxinvR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxinvR { bits }
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline ( always )]
            pub fn swap(&self) -> SwapR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SwapR { bits }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline ( always )]
            pub fn linen(&self) -> LinenR {
                LinenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 14;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline ( always )]
            pub fn stop(&self) -> StopR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StopR { bits }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline ( always )]
            pub fn clken(&self) -> ClkenR {
                ClkenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 11;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline ( always )]
            pub fn cpol(&self) -> CpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CpolR { bits }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline ( always )]
            pub fn cpha(&self) -> CphaR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CphaR { bits }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline ( always )]
            pub fn lbcl(&self) -> LbclR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbclR { bits }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline ( always )]
            pub fn lbdie(&self) -> LbdieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdieR { bits }
            }
            #[doc = "Bit 5 - LIN break detection length"]
            #[inline ( always )]
            pub fn lbdl(&self) -> LbdlR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdlR { bits }
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline ( always )]
            pub fn addm7(&self) -> Addm7R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Addm7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Address of the USART node"]
            #[inline ( always )]
            pub fn add4(&mut self) -> _Add4W {
                _Add4W { w: self }
            }
            #[doc = "Bits 24:27 - Address of the USART node"]
            #[inline ( always )]
            pub fn add0(&mut self) -> _Add0W {
                _Add0W { w: self }
            }
            #[doc = "Bit 23 - Receiver timeout enable"]
            #[inline ( always )]
            pub fn rtoen(&mut self) -> _RtoenW {
                _RtoenW { w: self }
            }
            #[doc = "Bits 21:22 - Auto baud rate mode"]
            #[inline ( always )]
            pub fn abrmod(&mut self) -> _AbrmodW {
                _AbrmodW { w: self }
            }
            #[doc = "Bit 20 - Auto baud rate enable"]
            #[inline ( always )]
            pub fn abren(&mut self) -> _AbrenW {
                _AbrenW { w: self }
            }
            #[doc = "Bit 19 - Most significant bit first"]
            #[inline ( always )]
            pub fn msbfirst(&mut self) -> _MsbfirstW {
                _MsbfirstW { w: self }
            }
            #[doc = "Bit 18 - Binary data inversion"]
            #[inline ( always )]
            pub fn datainv(&mut self) -> _DatainvW {
                _DatainvW { w: self }
            }
            #[doc = "Bit 17 - TX pin active level inversion"]
            #[inline ( always )]
            pub fn txinv(&mut self) -> _TxinvW {
                _TxinvW { w: self }
            }
            #[doc = "Bit 16 - RX pin active level inversion"]
            #[inline ( always )]
            pub fn rxinv(&mut self) -> _RxinvW {
                _RxinvW { w: self }
            }
            #[doc = "Bit 15 - Swap TX/RX pins"]
            #[inline ( always )]
            pub fn swap(&mut self) -> _SwapW {
                _SwapW { w: self }
            }
            #[doc = "Bit 14 - LIN mode enable"]
            #[inline ( always )]
            pub fn linen(&mut self) -> _LinenW {
                _LinenW { w: self }
            }
            #[doc = "Bits 12:13 - STOP bits"]
            #[inline ( always )]
            pub fn stop(&mut self) -> _StopW {
                _StopW { w: self }
            }
            #[doc = "Bit 11 - Clock enable"]
            #[inline ( always )]
            pub fn clken(&mut self) -> _ClkenW {
                _ClkenW { w: self }
            }
            #[doc = "Bit 10 - Clock polarity"]
            #[inline ( always )]
            pub fn cpol(&mut self) -> _CpolW {
                _CpolW { w: self }
            }
            #[doc = "Bit 9 - Clock phase"]
            #[inline ( always )]
            pub fn cpha(&mut self) -> _CphaW {
                _CphaW { w: self }
            }
            #[doc = "Bit 8 - Last bit clock pulse"]
            #[inline ( always )]
            pub fn lbcl(&mut self) -> _LbclW {
                _LbclW { w: self }
            }
            #[doc = "Bit 6 - LIN break detection interrupt enable"]
            #[inline ( always )]
            pub fn lbdie(&mut self) -> _LbdieW {
                _LbdieW { w: self }
            }
            #[doc = "Bit 5 - LIN break detection length"]
            #[inline ( always )]
            pub fn lbdl(&mut self) -> _LbdlW {
                _LbdlW { w: self }
            }
            #[doc = "Bit 4 - 7-bit Address Detection/4-bit Address Detection"]
            #[inline ( always )]
            pub fn addm7(&mut self) -> _Addm7W {
                _Addm7W { w: self }
            }
        }
    }
    #[doc = "Control register 3"]
    pub struct Cr3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Control register 3"]
    pub mod cr3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct WufieR {
            bits: u8,
        }
        impl WufieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WusR {
            bits: u8,
        }
        impl WusR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ScarcntR {
            bits: u8,
        }
        impl ScarcntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DepR {
            bits: u8,
        }
        impl DepR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DemR {
            bits: u8,
        }
        impl DemR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DdreR {
            bits: u8,
        }
        impl DdreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OvrdisR {
            bits: u8,
        }
        impl OvrdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OnebitR {
            bits: u8,
        }
        impl OnebitR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtsieR {
            bits: u8,
        }
        impl CtsieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtseR {
            bits: u8,
        }
        impl CtseR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtseR {
            bits: u8,
        }
        impl RtseR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmatR {
            bits: u8,
        }
        impl DmatR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmarR {
            bits: u8,
        }
        impl DmarR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `SCEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum ScenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl ScenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    ScenR::Disabled => 0,
                    ScenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> ScenR {
                match bits {
                    0 => ScenR::Disabled,
                    1 => ScenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == ScenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == ScenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct NackR {
            bits: u8,
        }
        impl NackR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HdselR {
            bits: u8,
        }
        impl HdselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IrlpR {
            bits: u8,
        }
        impl IrlpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IREN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum IrenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IrenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    IrenR::Disabled => 0,
                    IrenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> IrenR {
                match bits {
                    0 => IrenR::Disabled,
                    1 => IrenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == IrenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == IrenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct EieR {
            bits: u8,
        }
        impl EieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WufieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WufieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WusW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ScarcntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScarcntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DepW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DemW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DemW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DdreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DdreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OvrdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OvrdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OnebitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OnebitW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CtsieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtsieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CtseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtseW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtseW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmatW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmatW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmarW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCEN`"]
        pub enum ScenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl ScenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ScenW::Disabled => 0,
                    ScenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ScenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ScenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: ScenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ScenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ScenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NackW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NackW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HdselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HdselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IrlpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrlpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IREN`"]
        pub enum IrenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl IrenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IrenW::Disabled => 0,
                    IrenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IrenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IrenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: IrenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IrenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IrenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline ( always )]
            pub fn wufie(&self) -> WufieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WufieR { bits }
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline ( always )]
            pub fn wus(&self) -> WusR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WusR { bits }
            }
            #[doc = "Bits 17:19 - Smartcard auto-retry count"]
            #[inline ( always )]
            pub fn scarcnt(&self) -> ScarcntR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ScarcntR { bits }
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline ( always )]
            pub fn dep(&self) -> DepR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DepR { bits }
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline ( always )]
            pub fn dem(&self) -> DemR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DemR { bits }
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline ( always )]
            pub fn ddre(&self) -> DdreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DdreR { bits }
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline ( always )]
            pub fn ovrdis(&self) -> OvrdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OvrdisR { bits }
            }
            #[doc = "Bit 11 - One sample bit method enable"]
            #[inline ( always )]
            pub fn onebit(&self) -> OnebitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OnebitR { bits }
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline ( always )]
            pub fn ctsie(&self) -> CtsieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtsieR { bits }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline ( always )]
            pub fn ctse(&self) -> CtseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtseR { bits }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline ( always )]
            pub fn rtse(&self) -> RtseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtseR { bits }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline ( always )]
            pub fn dmat(&self) -> DmatR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmatR { bits }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline ( always )]
            pub fn dmar(&self) -> DmarR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DmarR { bits }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline ( always )]
            pub fn scen(&self) -> ScenR {
                ScenR::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 5;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline ( always )]
            pub fn nack(&self) -> NackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NackR { bits }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline ( always )]
            pub fn hdsel(&self) -> HdselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HdselR { bits }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline ( always )]
            pub fn irlp(&self) -> IrlpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IrlpR { bits }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline ( always )]
            pub fn iren(&self) -> IrenR {
                IrenR::_from({
                                 const MASK: u8 = 1;
                                 const OFFSET: u8 = 1;
                                 ((self.bits >> OFFSET) & MASK as u32) as u8
                             })
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline ( always )]
            pub fn eie(&self) -> EieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 22 - Wakeup from Stop mode interrupt enable"]
            #[inline ( always )]
            pub fn wufie(&mut self) -> _WufieW {
                _WufieW { w: self }
            }
            #[doc = "Bits 20:21 - Wakeup from Stop mode interrupt flag selection"]
            #[inline ( always )]
            pub fn wus(&mut self) -> _WusW {
                _WusW { w: self }
            }
            #[doc = "Bits 17:19 - Smartcard auto-retry count"]
            #[inline ( always )]
            pub fn scarcnt(&mut self) -> _ScarcntW {
                _ScarcntW { w: self }
            }
            #[doc = "Bit 15 - Driver enable polarity selection"]
            #[inline ( always )]
            pub fn dep(&mut self) -> _DepW {
                _DepW { w: self }
            }
            #[doc = "Bit 14 - Driver enable mode"]
            #[inline ( always )]
            pub fn dem(&mut self) -> _DemW {
                _DemW { w: self }
            }
            #[doc = "Bit 13 - DMA Disable on Reception Error"]
            #[inline ( always )]
            pub fn ddre(&mut self) -> _DdreW {
                _DdreW { w: self }
            }
            #[doc = "Bit 12 - Overrun Disable"]
            #[inline ( always )]
            pub fn ovrdis(&mut self) -> _OvrdisW {
                _OvrdisW { w: self }
            }
            #[doc = "Bit 11 - One sample bit method enable"]
            #[inline ( always )]
            pub fn onebit(&mut self) -> _OnebitW {
                _OnebitW { w: self }
            }
            #[doc = "Bit 10 - CTS interrupt enable"]
            #[inline ( always )]
            pub fn ctsie(&mut self) -> _CtsieW {
                _CtsieW { w: self }
            }
            #[doc = "Bit 9 - CTS enable"]
            #[inline ( always )]
            pub fn ctse(&mut self) -> _CtseW {
                _CtseW { w: self }
            }
            #[doc = "Bit 8 - RTS enable"]
            #[inline ( always )]
            pub fn rtse(&mut self) -> _RtseW {
                _RtseW { w: self }
            }
            #[doc = "Bit 7 - DMA enable transmitter"]
            #[inline ( always )]
            pub fn dmat(&mut self) -> _DmatW {
                _DmatW { w: self }
            }
            #[doc = "Bit 6 - DMA enable receiver"]
            #[inline ( always )]
            pub fn dmar(&mut self) -> _DmarW {
                _DmarW { w: self }
            }
            #[doc = "Bit 5 - Smartcard mode enable"]
            #[inline ( always )]
            pub fn scen(&mut self) -> _ScenW {
                _ScenW { w: self }
            }
            #[doc = "Bit 4 - Smartcard NACK enable"]
            #[inline ( always )]
            pub fn nack(&mut self) -> _NackW {
                _NackW { w: self }
            }
            #[doc = "Bit 3 - Half-duplex selection"]
            #[inline ( always )]
            pub fn hdsel(&mut self) -> _HdselW {
                _HdselW { w: self }
            }
            #[doc = "Bit 2 - IrDA low-power"]
            #[inline ( always )]
            pub fn irlp(&mut self) -> _IrlpW {
                _IrlpW { w: self }
            }
            #[doc = "Bit 1 - IrDA mode enable"]
            #[inline ( always )]
            pub fn iren(&mut self) -> _IrenW {
                _IrenW { w: self }
            }
            #[doc = "Bit 0 - Error interrupt enable"]
            #[inline ( always )]
            pub fn eie(&mut self) -> _EieW {
                _EieW { w: self }
            }
        }
    }
    #[doc = "Baud rate register"]
    pub struct Brr {
        register: VolatileCell<u32>,
    }
    #[doc = "Baud rate register"]
    pub mod brr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Brr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DivMantissaR {
            bits: u16,
        }
        impl DivMantissaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DivFractionR {
            bits: u8,
        }
        impl DivFractionR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DivMantissaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivMantissaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DivFractionW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DivFractionW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline ( always )]
            pub fn div_mantissa(&self) -> DivMantissaR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DivMantissaR { bits }
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline ( always )]
            pub fn div_fraction(&self) -> DivFractionR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivFractionR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:15 - mantissa of USARTDIV"]
            #[inline ( always )]
            pub fn div_mantissa(&mut self) -> _DivMantissaW {
                _DivMantissaW { w: self }
            }
            #[doc = "Bits 0:3 - fraction of USARTDIV"]
            #[inline ( always )]
            pub fn div_fraction(&mut self) -> _DivFractionW {
                _DivFractionW { w: self }
            }
        }
    }
    #[doc = "Guard time and prescaler register"]
    pub struct Gtpr {
        register: VolatileCell<u32>,
    }
    #[doc = "Guard time and prescaler register"]
    pub mod gtpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Gtpr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct GtR {
            bits: u8,
        }
        impl GtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u8,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline ( always )]
            pub fn gt(&self) -> GtR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GtR { bits }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:15 - Guard time value"]
            #[inline ( always )]
            pub fn gt(&mut self) -> _GtW {
                _GtW { w: self }
            }
            #[doc = "Bits 0:7 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "Receiver timeout register"]
    pub struct Rtor {
        register: VolatileCell<u32>,
    }
    #[doc = "Receiver timeout register"]
    pub mod rtor {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rtor {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BlenR {
            bits: u8,
        }
        impl BlenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtoR {
            bits: u32,
        }
        impl RtoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BlenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BlenW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtoW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 24:31 - Block Length"]
            #[inline ( always )]
            pub fn blen(&self) -> BlenR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BlenR { bits }
            }
            #[doc = "Bits 0:23 - Receiver timeout value"]
            #[inline ( always )]
            pub fn rto(&self) -> RtoR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                RtoR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 24:31 - Block Length"]
            #[inline ( always )]
            pub fn blen(&mut self) -> _BlenW {
                _BlenW { w: self }
            }
            #[doc = "Bits 0:23 - Receiver timeout value"]
            #[inline ( always )]
            pub fn rto(&mut self) -> _RtoW {
                _RtoW { w: self }
            }
        }
    }
    #[doc = "Request register"]
    pub struct Rqr {
        register: VolatileCell<u32>,
    }
    #[doc = "Request register"]
    pub mod rqr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rqr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxfrqR {
            bits: u8,
        }
        impl TxfrqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxfrqR {
            bits: u8,
        }
        impl RxfrqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmrqR {
            bits: u8,
        }
        impl MmrqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbkrqR {
            bits: u8,
        }
        impl SbkrqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AbrrqR {
            bits: u8,
        }
        impl AbrrqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxfrqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxfrqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxfrqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxfrqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmrqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmrqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SbkrqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbkrqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AbrrqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AbrrqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 4 - Transmit data flush request"]
            #[inline ( always )]
            pub fn txfrq(&self) -> TxfrqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxfrqR { bits }
            }
            #[doc = "Bit 3 - Receive data flush request"]
            #[inline ( always )]
            pub fn rxfrq(&self) -> RxfrqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxfrqR { bits }
            }
            #[doc = "Bit 2 - Mute mode request"]
            #[inline ( always )]
            pub fn mmrq(&self) -> MmrqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmrqR { bits }
            }
            #[doc = "Bit 1 - Send break request"]
            #[inline ( always )]
            pub fn sbkrq(&self) -> SbkrqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbkrqR { bits }
            }
            #[doc = "Bit 0 - Auto baud rate request"]
            #[inline ( always )]
            pub fn abrrq(&self) -> AbrrqR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AbrrqR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 4 - Transmit data flush request"]
            #[inline ( always )]
            pub fn txfrq(&mut self) -> _TxfrqW {
                _TxfrqW { w: self }
            }
            #[doc = "Bit 3 - Receive data flush request"]
            #[inline ( always )]
            pub fn rxfrq(&mut self) -> _RxfrqW {
                _RxfrqW { w: self }
            }
            #[doc = "Bit 2 - Mute mode request"]
            #[inline ( always )]
            pub fn mmrq(&mut self) -> _MmrqW {
                _MmrqW { w: self }
            }
            #[doc = "Bit 1 - Send break request"]
            #[inline ( always )]
            pub fn sbkrq(&mut self) -> _SbkrqW {
                _SbkrqW { w: self }
            }
            #[doc = "Bit 0 - Auto baud rate request"]
            #[inline ( always )]
            pub fn abrrq(&mut self) -> _AbrrqW {
                _AbrrqW { w: self }
            }
        }
    }
    #[doc = "Interrupt & status register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt & status register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ReackR {
            bits: u8,
        }
        impl ReackR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TeackR {
            bits: u8,
        }
        impl TeackR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WufR {
            bits: u8,
        }
        impl WufR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RwuR {
            bits: u8,
        }
        impl RwuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbkfR {
            bits: u8,
        }
        impl SbkfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CmfR {
            bits: u8,
        }
        impl CmfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BusyR {
            bits: u8,
        }
        impl BusyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AbrfR {
            bits: u8,
        }
        impl AbrfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AbreR {
            bits: u8,
        }
        impl AbreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EobfR {
            bits: u8,
        }
        impl EobfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtofR {
            bits: u8,
        }
        impl RtofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtsR {
            bits: u8,
        }
        impl CtsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtsifR {
            bits: u8,
        }
        impl CtsifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbdfR {
            bits: u8,
        }
        impl LbdfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeR {
            bits: u8,
        }
        impl TxeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TcR {
            bits: u8,
        }
        impl TcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxneR {
            bits: u8,
        }
        impl RxneR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IdleR {
            bits: u8,
        }
        impl IdleR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OreR {
            bits: u8,
        }
        impl OreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NfR {
            bits: u8,
        }
        impl NfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FeR {
            bits: u8,
        }
        impl FeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PeR {
            bits: u8,
        }
        impl PeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 22 - Receive enable acknowledge flag"]
            #[inline ( always )]
            pub fn reack(&self) -> ReackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ReackR { bits }
            }
            #[doc = "Bit 21 - Transmit enable acknowledge flag"]
            #[inline ( always )]
            pub fn teack(&self) -> TeackR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TeackR { bits }
            }
            #[doc = "Bit 20 - Wakeup from Stop mode flag"]
            #[inline ( always )]
            pub fn wuf(&self) -> WufR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WufR { bits }
            }
            #[doc = "Bit 19 - Receiver wakeup from Mute mode"]
            #[inline ( always )]
            pub fn rwu(&self) -> RwuR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RwuR { bits }
            }
            #[doc = "Bit 18 - Send break flag"]
            #[inline ( always )]
            pub fn sbkf(&self) -> SbkfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbkfR { bits }
            }
            #[doc = "Bit 17 - character match flag"]
            #[inline ( always )]
            pub fn cmf(&self) -> CmfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmfR { bits }
            }
            #[doc = "Bit 16 - Busy flag"]
            #[inline ( always )]
            pub fn busy(&self) -> BusyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BusyR { bits }
            }
            #[doc = "Bit 15 - Auto baud rate flag"]
            #[inline ( always )]
            pub fn abrf(&self) -> AbrfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AbrfR { bits }
            }
            #[doc = "Bit 14 - Auto baud rate error"]
            #[inline ( always )]
            pub fn abre(&self) -> AbreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AbreR { bits }
            }
            #[doc = "Bit 12 - End of block flag"]
            #[inline ( always )]
            pub fn eobf(&self) -> EobfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EobfR { bits }
            }
            #[doc = "Bit 11 - Receiver timeout"]
            #[inline ( always )]
            pub fn rtof(&self) -> RtofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtofR { bits }
            }
            #[doc = "Bit 10 - CTS flag"]
            #[inline ( always )]
            pub fn cts(&self) -> CtsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtsR { bits }
            }
            #[doc = "Bit 9 - CTS interrupt flag"]
            #[inline ( always )]
            pub fn ctsif(&self) -> CtsifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtsifR { bits }
            }
            #[doc = "Bit 8 - LIN break detection flag"]
            #[inline ( always )]
            pub fn lbdf(&self) -> LbdfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdfR { bits }
            }
            #[doc = "Bit 7 - Transmit data register empty"]
            #[inline ( always )]
            pub fn txe(&self) -> TxeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeR { bits }
            }
            #[doc = "Bit 6 - Transmission complete"]
            #[inline ( always )]
            pub fn tc(&self) -> TcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TcR { bits }
            }
            #[doc = "Bit 5 - Read data register not empty"]
            #[inline ( always )]
            pub fn rxne(&self) -> RxneR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxneR { bits }
            }
            #[doc = "Bit 4 - Idle line detected"]
            #[inline ( always )]
            pub fn idle(&self) -> IdleR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdleR { bits }
            }
            #[doc = "Bit 3 - Overrun error"]
            #[inline ( always )]
            pub fn ore(&self) -> OreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OreR { bits }
            }
            #[doc = "Bit 2 - Noise detected flag"]
            #[inline ( always )]
            pub fn nf(&self) -> NfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NfR { bits }
            }
            #[doc = "Bit 1 - Framing error"]
            #[inline ( always )]
            pub fn fe(&self) -> FeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FeR { bits }
            }
            #[doc = "Bit 0 - Parity error"]
            #[inline ( always )]
            pub fn pe(&self) -> PeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PeR { bits }
            }
        }
    }
    #[doc = "Interrupt flag clear register"]
    pub struct Icr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt flag clear register"]
    pub mod icr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Icr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct WucfR {
            bits: u8,
        }
        impl WucfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CmcfR {
            bits: u8,
        }
        impl CmcfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EobcfR {
            bits: u8,
        }
        impl EobcfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RtocfR {
            bits: u8,
        }
        impl RtocfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtscfR {
            bits: u8,
        }
        impl CtscfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbdcfR {
            bits: u8,
        }
        impl LbdcfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TccfR {
            bits: u8,
        }
        impl TccfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IdlecfR {
            bits: u8,
        }
        impl IdlecfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OrecfR {
            bits: u8,
        }
        impl OrecfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NcfR {
            bits: u8,
        }
        impl NcfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FecfR {
            bits: u8,
        }
        impl FecfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PecfR {
            bits: u8,
        }
        impl PecfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WucfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WucfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CmcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CmcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EobcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EobcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RtocfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RtocfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CtscfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtscfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbdcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbdcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TccfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TccfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IdlecfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IdlecfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OrecfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OrecfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NcfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NcfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FecfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FecfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PecfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PecfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 20 - Wakeup from Stop mode clear flag"]
            #[inline ( always )]
            pub fn wucf(&self) -> WucfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WucfR { bits }
            }
            #[doc = "Bit 17 - Character match clear flag"]
            #[inline ( always )]
            pub fn cmcf(&self) -> CmcfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CmcfR { bits }
            }
            #[doc = "Bit 12 - End of timeout clear flag"]
            #[inline ( always )]
            pub fn eobcf(&self) -> EobcfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EobcfR { bits }
            }
            #[doc = "Bit 11 - Receiver timeout clear flag"]
            #[inline ( always )]
            pub fn rtocf(&self) -> RtocfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RtocfR { bits }
            }
            #[doc = "Bit 9 - CTS clear flag"]
            #[inline ( always )]
            pub fn ctscf(&self) -> CtscfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtscfR { bits }
            }
            #[doc = "Bit 8 - LIN break detection clear flag"]
            #[inline ( always )]
            pub fn lbdcf(&self) -> LbdcfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbdcfR { bits }
            }
            #[doc = "Bit 6 - Transmission complete clear flag"]
            #[inline ( always )]
            pub fn tccf(&self) -> TccfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TccfR { bits }
            }
            #[doc = "Bit 4 - Idle line detected clear flag"]
            #[inline ( always )]
            pub fn idlecf(&self) -> IdlecfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IdlecfR { bits }
            }
            #[doc = "Bit 3 - Overrun error clear flag"]
            #[inline ( always )]
            pub fn orecf(&self) -> OrecfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OrecfR { bits }
            }
            #[doc = "Bit 2 - Noise detected clear flag"]
            #[inline ( always )]
            pub fn ncf(&self) -> NcfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NcfR { bits }
            }
            #[doc = "Bit 1 - Framing error clear flag"]
            #[inline ( always )]
            pub fn fecf(&self) -> FecfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FecfR { bits }
            }
            #[doc = "Bit 0 - Parity error clear flag"]
            #[inline ( always )]
            pub fn pecf(&self) -> PecfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PecfR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 20 - Wakeup from Stop mode clear flag"]
            #[inline ( always )]
            pub fn wucf(&mut self) -> _WucfW {
                _WucfW { w: self }
            }
            #[doc = "Bit 17 - Character match clear flag"]
            #[inline ( always )]
            pub fn cmcf(&mut self) -> _CmcfW {
                _CmcfW { w: self }
            }
            #[doc = "Bit 12 - End of timeout clear flag"]
            #[inline ( always )]
            pub fn eobcf(&mut self) -> _EobcfW {
                _EobcfW { w: self }
            }
            #[doc = "Bit 11 - Receiver timeout clear flag"]
            #[inline ( always )]
            pub fn rtocf(&mut self) -> _RtocfW {
                _RtocfW { w: self }
            }
            #[doc = "Bit 9 - CTS clear flag"]
            #[inline ( always )]
            pub fn ctscf(&mut self) -> _CtscfW {
                _CtscfW { w: self }
            }
            #[doc = "Bit 8 - LIN break detection clear flag"]
            #[inline ( always )]
            pub fn lbdcf(&mut self) -> _LbdcfW {
                _LbdcfW { w: self }
            }
            #[doc = "Bit 6 - Transmission complete clear flag"]
            #[inline ( always )]
            pub fn tccf(&mut self) -> _TccfW {
                _TccfW { w: self }
            }
            #[doc = "Bit 4 - Idle line detected clear flag"]
            #[inline ( always )]
            pub fn idlecf(&mut self) -> _IdlecfW {
                _IdlecfW { w: self }
            }
            #[doc = "Bit 3 - Overrun error clear flag"]
            #[inline ( always )]
            pub fn orecf(&mut self) -> _OrecfW {
                _OrecfW { w: self }
            }
            #[doc = "Bit 2 - Noise detected clear flag"]
            #[inline ( always )]
            pub fn ncf(&mut self) -> _NcfW {
                _NcfW { w: self }
            }
            #[doc = "Bit 1 - Framing error clear flag"]
            #[inline ( always )]
            pub fn fecf(&mut self) -> _FecfW {
                _FecfW { w: self }
            }
            #[doc = "Bit 0 - Parity error clear flag"]
            #[inline ( always )]
            pub fn pecf(&mut self) -> _PecfW {
                _PecfW { w: self }
            }
        }
    }
    #[doc = "Receive data register"]
    pub struct Rdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Receive data register"]
    pub mod rdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Rdr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RdrR {
            bits: u16,
        }
        impl RdrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Receive data value"]
            #[inline ( always )]
            pub fn rdr(&self) -> RdrR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RdrR { bits }
            }
        }
    }
    #[doc = "Transmit data register"]
    pub struct Tdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Transmit data register"]
    pub mod tdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Tdr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TdrR {
            bits: u16,
        }
        impl TdrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TdrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline ( always )]
            pub fn tdr(&self) -> TdrR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TdrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Transmit data value"]
            #[inline ( always )]
            pub fn tdr(&mut self) -> _TdrW {
                _TdrW { w: self }
            }
        }
    }
}
#[doc = "Universal synchronous asynchronous receiver transmitter"]
pub struct Usart1 {
    register_block: usart1::RegisterBlock,
}
impl Deref for Usart1 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USART2"]
pub const USART2: Peripheral<Usart2> = unsafe { Peripheral::new(1073759232) };
#[doc = r" Register block"]
pub struct Usart2 {
    register_block: usart1::RegisterBlock,
}
impl Deref for Usart2 {
    type Target = usart1::RegisterBlock;
    fn deref(&self) -> &usart1::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Comparator"]
pub const COMP: Peripheral<Comp> = unsafe { Peripheral::new(1073807388) };
#[doc = "Comparator"]
pub mod comp {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control and status register"]
        pub csr: Csr,
    }
    #[doc = "control and status register"]
    pub struct Csr {
        register: VolatileCell<u32>,
    }
    #[doc = "control and status register"]
    pub mod csr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Csr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `COMP1EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Comp1enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Comp1enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Comp1enR::Disabled => 0,
                    Comp1enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Comp1enR {
                match bits {
                    0 => Comp1enR::Disabled,
                    1 => Comp1enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Comp1enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Comp1enR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1InpDacR {
            bits: u8,
        }
        impl Comp1InpDacR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1modeR {
            bits: u8,
        }
        impl Comp1modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1inselR {
            bits: u8,
        }
        impl Comp1inselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1outselR {
            bits: u8,
        }
        impl Comp1outselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1polR {
            bits: u8,
        }
        impl Comp1polR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1hystR {
            bits: u8,
        }
        impl Comp1hystR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1outR {
            bits: u8,
        }
        impl Comp1outR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp1lockR {
            bits: u8,
        }
        impl Comp1lockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `COMP2EN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum Comp2enR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Comp2enR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    Comp2enR::Disabled => 0,
                    Comp2enR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> Comp2enR {
                match bits {
                    0 => Comp2enR::Disabled,
                    1 => Comp2enR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == Comp2enR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == Comp2enR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2modeR {
            bits: u8,
        }
        impl Comp2modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2inselR {
            bits: u8,
        }
        impl Comp2inselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `WNDWEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum WndwenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WndwenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    WndwenR::Disabled => 0,
                    WndwenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> WndwenR {
                match bits {
                    0 => WndwenR::Disabled,
                    1 => WndwenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == WndwenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == WndwenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2outselR {
            bits: u8,
        }
        impl Comp2outselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2polR {
            bits: u8,
        }
        impl Comp2polR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2hystR {
            bits: u8,
        }
        impl Comp2hystR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2outR {
            bits: u8,
        }
        impl Comp2outR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Comp2lockR {
            bits: u8,
        }
        impl Comp2lockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `COMP1EN`"]
        pub enum Comp1enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Comp1enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Comp1enW::Disabled => 0,
                    Comp1enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Comp1enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Comp1enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Comp1enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1InpDacW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1InpDacW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1inselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1inselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1outselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1outselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1polW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1polW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1hystW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1hystW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp1lockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp1lockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMP2EN`"]
        pub enum Comp2enW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl Comp2enW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    Comp2enW::Disabled => 0,
                    Comp2enW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2enW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2enW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: Comp2enW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(Comp2enW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(Comp2enW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2inselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2inselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WNDWEN`"]
        pub enum WndwenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl WndwenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WndwenW::Disabled => 0,
                    WndwenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WndwenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WndwenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: WndwenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WndwenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WndwenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2outselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2outselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2polW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2polW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2hystW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2hystW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Comp2lockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Comp2lockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Comparator 1 enable"]
            #[inline ( always )]
            pub fn comp1en(&self) -> Comp1enR {
                Comp1enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 0;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 1 - COMP1_INP_DAC"]
            #[inline ( always )]
            pub fn comp1_inp_dac(&self) -> Comp1InpDacR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1InpDacR { bits }
            }
            #[doc = "Bits 2:3 - Comparator 1 mode"]
            #[inline ( always )]
            pub fn comp1mode(&self) -> Comp1modeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1modeR { bits }
            }
            #[doc = "Bits 4:6 - Comparator 1 inverting input selection"]
            #[inline ( always )]
            pub fn comp1insel(&self) -> Comp1inselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1inselR { bits }
            }
            #[doc = "Bits 8:10 - Comparator 1 output selection"]
            #[inline ( always )]
            pub fn comp1outsel(&self) -> Comp1outselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1outselR { bits }
            }
            #[doc = "Bit 11 - Comparator 1 output polarity"]
            #[inline ( always )]
            pub fn comp1pol(&self) -> Comp1polR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1polR { bits }
            }
            #[doc = "Bits 12:13 - Comparator 1 hysteresis"]
            #[inline ( always )]
            pub fn comp1hyst(&self) -> Comp1hystR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1hystR { bits }
            }
            #[doc = "Bit 14 - Comparator 1 output"]
            #[inline ( always )]
            pub fn comp1out(&self) -> Comp1outR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1outR { bits }
            }
            #[doc = "Bit 15 - Comparator 1 lock"]
            #[inline ( always )]
            pub fn comp1lock(&self) -> Comp1lockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp1lockR { bits }
            }
            #[doc = "Bit 16 - Comparator 2 enable"]
            #[inline ( always )]
            pub fn comp2en(&self) -> Comp2enR {
                Comp2enR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 16;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bits 18:19 - Comparator 2 mode"]
            #[inline ( always )]
            pub fn comp2mode(&self) -> Comp2modeR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2modeR { bits }
            }
            #[doc = "Bits 20:22 - Comparator 2 inverting input selection"]
            #[inline ( always )]
            pub fn comp2insel(&self) -> Comp2inselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2inselR { bits }
            }
            #[doc = "Bit 23 - Window mode enable"]
            #[inline ( always )]
            pub fn wndwen(&self) -> WndwenR {
                WndwenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 23;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bits 24:26 - Comparator 2 output selection"]
            #[inline ( always )]
            pub fn comp2outsel(&self) -> Comp2outselR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2outselR { bits }
            }
            #[doc = "Bit 27 - Comparator 2 output polarity"]
            #[inline ( always )]
            pub fn comp2pol(&self) -> Comp2polR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2polR { bits }
            }
            #[doc = "Bits 28:29 - Comparator 2 hysteresis"]
            #[inline ( always )]
            pub fn comp2hyst(&self) -> Comp2hystR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2hystR { bits }
            }
            #[doc = "Bit 30 - Comparator 2 output"]
            #[inline ( always )]
            pub fn comp2out(&self) -> Comp2outR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2outR { bits }
            }
            #[doc = "Bit 31 - Comparator 2 lock"]
            #[inline ( always )]
            pub fn comp2lock(&self) -> Comp2lockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Comp2lockR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Comparator 1 enable"]
            #[inline ( always )]
            pub fn comp1en(&mut self) -> _Comp1enW {
                _Comp1enW { w: self }
            }
            #[doc = "Bit 1 - COMP1_INP_DAC"]
            #[inline ( always )]
            pub fn comp1_inp_dac(&mut self) -> _Comp1InpDacW {
                _Comp1InpDacW { w: self }
            }
            #[doc = "Bits 2:3 - Comparator 1 mode"]
            #[inline ( always )]
            pub fn comp1mode(&mut self) -> _Comp1modeW {
                _Comp1modeW { w: self }
            }
            #[doc = "Bits 4:6 - Comparator 1 inverting input selection"]
            #[inline ( always )]
            pub fn comp1insel(&mut self) -> _Comp1inselW {
                _Comp1inselW { w: self }
            }
            #[doc = "Bits 8:10 - Comparator 1 output selection"]
            #[inline ( always )]
            pub fn comp1outsel(&mut self) -> _Comp1outselW {
                _Comp1outselW { w: self }
            }
            #[doc = "Bit 11 - Comparator 1 output polarity"]
            #[inline ( always )]
            pub fn comp1pol(&mut self) -> _Comp1polW {
                _Comp1polW { w: self }
            }
            #[doc = "Bits 12:13 - Comparator 1 hysteresis"]
            #[inline ( always )]
            pub fn comp1hyst(&mut self) -> _Comp1hystW {
                _Comp1hystW { w: self }
            }
            #[doc = "Bit 15 - Comparator 1 lock"]
            #[inline ( always )]
            pub fn comp1lock(&mut self) -> _Comp1lockW {
                _Comp1lockW { w: self }
            }
            #[doc = "Bit 16 - Comparator 2 enable"]
            #[inline ( always )]
            pub fn comp2en(&mut self) -> _Comp2enW {
                _Comp2enW { w: self }
            }
            #[doc = "Bits 18:19 - Comparator 2 mode"]
            #[inline ( always )]
            pub fn comp2mode(&mut self) -> _Comp2modeW {
                _Comp2modeW { w: self }
            }
            #[doc = "Bits 20:22 - Comparator 2 inverting input selection"]
            #[inline ( always )]
            pub fn comp2insel(&mut self) -> _Comp2inselW {
                _Comp2inselW { w: self }
            }
            #[doc = "Bit 23 - Window mode enable"]
            #[inline ( always )]
            pub fn wndwen(&mut self) -> _WndwenW {
                _WndwenW { w: self }
            }
            #[doc = "Bits 24:26 - Comparator 2 output selection"]
            #[inline ( always )]
            pub fn comp2outsel(&mut self) -> _Comp2outselW {
                _Comp2outselW { w: self }
            }
            #[doc = "Bit 27 - Comparator 2 output polarity"]
            #[inline ( always )]
            pub fn comp2pol(&mut self) -> _Comp2polW {
                _Comp2polW { w: self }
            }
            #[doc = "Bits 28:29 - Comparator 2 hysteresis"]
            #[inline ( always )]
            pub fn comp2hyst(&mut self) -> _Comp2hystW {
                _Comp2hystW { w: self }
            }
            #[doc = "Bit 31 - Comparator 2 lock"]
            #[inline ( always )]
            pub fn comp2lock(&mut self) -> _Comp2lockW {
                _Comp2lockW { w: self }
            }
        }
    }
}
#[doc = "Comparator"]
pub struct Comp {
    register_block: comp::RegisterBlock,
}
impl Deref for Comp {
    type Target = comp::RegisterBlock;
    fn deref(&self) -> &comp::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Real-time clock"]
pub const RTC: Peripheral<Rtc> = unsafe { Peripheral::new(1073752064) };
#[doc = "Real-time clock"]
pub mod rtc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - time register"]
        pub tr: Tr,
        #[doc = "0x04 - date register"]
        pub dr: Dr,
        #[doc = "0x08 - control register"]
        pub cr: Cr,
        #[doc = "0x0c - initialization and status register"]
        pub isr: Isr,
        #[doc = "0x10 - prescaler register"]
        pub prer: Prer,
        _reserved0: [u8; 8usize],
        #[doc = "0x1c - alarm A register"]
        pub alrmar: Alrmar,
        _reserved1: [u8; 4usize],
        #[doc = "0x24 - write protection register"]
        pub wpr: Wpr,
        #[doc = "0x28 - sub second register"]
        pub ssr: Ssr,
        #[doc = "0x2c - shift control register"]
        pub shiftr: Shiftr,
        #[doc = "0x30 - timestamp time register"]
        pub tstr: Tstr,
        #[doc = "0x34 - timestamp date register"]
        pub tsdr: Tsdr,
        #[doc = "0x38 - time-stamp sub second register"]
        pub tsssr: Tsssr,
        #[doc = "0x3c - calibration register"]
        pub calr: Calr,
        #[doc = "0x40 - tamper and alternate function configuration register"]
        pub tafcr: Tafcr,
        #[doc = "0x44 - alarm A sub second register"]
        pub alrmassr: Alrmassr,
        _reserved2: [u8; 8usize],
        #[doc = "0x50 - backup register"]
        pub bkp0r: Bkp0r,
        #[doc = "0x54 - backup register"]
        pub bkp1r: Bkp1r,
        #[doc = "0x58 - backup register"]
        pub bkp2r: Bkp2r,
        #[doc = "0x5c - backup register"]
        pub bkp3r: Bkp3r,
        #[doc = "0x60 - backup register"]
        pub bkp4r: Bkp4r,
    }
    #[doc = "time register"]
    pub struct Tr {
        register: VolatileCell<u32>,
    }
    #[doc = "time register"]
    pub mod tr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Tr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PmR {
            bits: u8,
        }
        impl PmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtR {
            bits: u8,
        }
        impl HtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HuR {
            bits: u8,
        }
        impl HuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MntR {
            bits: u8,
        }
        impl MntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MnuR {
            bits: u8,
        }
        impl MnuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StR {
            bits: u8,
        }
        impl StR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SuR {
            bits: u8,
        }
        impl SuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MnuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MnuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline ( always )]
            pub fn pm(&self) -> PmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PmR { bits }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline ( always )]
            pub fn ht(&self) -> HtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtR { bits }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline ( always )]
            pub fn hu(&self) -> HuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HuR { bits }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline ( always )]
            pub fn mnt(&self) -> MntR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MntR { bits }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline ( always )]
            pub fn mnu(&self) -> MnuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MnuR { bits }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline ( always )]
            pub fn st(&self) -> StR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StR { bits }
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline ( always )]
            pub fn su(&self) -> SuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SuR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline ( always )]
            pub fn pm(&mut self) -> _PmW {
                _PmW { w: self }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format"]
            #[inline ( always )]
            pub fn ht(&mut self) -> _HtW {
                _HtW { w: self }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format"]
            #[inline ( always )]
            pub fn hu(&mut self) -> _HuW {
                _HuW { w: self }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format"]
            #[inline ( always )]
            pub fn mnt(&mut self) -> _MntW {
                _MntW { w: self }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format"]
            #[inline ( always )]
            pub fn mnu(&mut self) -> _MnuW {
                _MnuW { w: self }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format"]
            #[inline ( always )]
            pub fn st(&mut self) -> _StW {
                _StW { w: self }
            }
            #[doc = "Bits 0:3 - Second units in BCD format"]
            #[inline ( always )]
            pub fn su(&mut self) -> _SuW {
                _SuW { w: self }
            }
        }
    }
    #[doc = "date register"]
    pub struct Dr {
        register: VolatileCell<u32>,
    }
    #[doc = "date register"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct YtR {
            bits: u8,
        }
        impl YtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct YuR {
            bits: u8,
        }
        impl YuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WduR {
            bits: u8,
        }
        impl WduR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MtR {
            bits: u8,
        }
        impl MtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MuR {
            bits: u8,
        }
        impl MuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtR {
            bits: u8,
        }
        impl DtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DuR {
            bits: u8,
        }
        impl DuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _YtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _YtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _YuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _YuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WduW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WduW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 20:23 - Year tens in BCD format"]
            #[inline ( always )]
            pub fn yt(&self) -> YtR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                YtR { bits }
            }
            #[doc = "Bits 16:19 - Year units in BCD format"]
            #[inline ( always )]
            pub fn yu(&self) -> YuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                YuR { bits }
            }
            #[doc = "Bits 13:15 - Week day units"]
            #[inline ( always )]
            pub fn wdu(&self) -> WduR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WduR { bits }
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline ( always )]
            pub fn mt(&self) -> MtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtR { bits }
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline ( always )]
            pub fn mu(&self) -> MuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuR { bits }
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline ( always )]
            pub fn dt(&self) -> DtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtR { bits }
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline ( always )]
            pub fn du(&self) -> DuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DuR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 8449 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 20:23 - Year tens in BCD format"]
            #[inline ( always )]
            pub fn yt(&mut self) -> _YtW {
                _YtW { w: self }
            }
            #[doc = "Bits 16:19 - Year units in BCD format"]
            #[inline ( always )]
            pub fn yu(&mut self) -> _YuW {
                _YuW { w: self }
            }
            #[doc = "Bits 13:15 - Week day units"]
            #[inline ( always )]
            pub fn wdu(&mut self) -> _WduW {
                _WduW { w: self }
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline ( always )]
            pub fn mt(&mut self) -> _MtW {
                _MtW { w: self }
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline ( always )]
            pub fn mu(&mut self) -> _MuW {
                _MuW { w: self }
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline ( always )]
            pub fn dt(&mut self) -> _DtW {
                _DtW { w: self }
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline ( always )]
            pub fn du(&mut self) -> _DuW {
                _DuW { w: self }
            }
        }
    }
    #[doc = "control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsedgeR {
            bits: u8,
        }
        impl TsedgeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `REFCKON`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum RefckonR {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl RefckonR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    RefckonR::Off => 0,
                    RefckonR::On => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> RefckonR {
                match bits {
                    0 => RefckonR::Off,
                    1 => RefckonR::On,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Off`"]
            #[inline ( always )]
            pub fn is_off(&self) -> bool {
                *self == RefckonR::Off
            }
            #[doc = "Checks if the value of the field is `On`"]
            #[inline ( always )]
            pub fn is_on(&self) -> bool {
                *self == RefckonR::On
            }
        }
        #[doc = r" Value of the field"]
        pub struct BypshadR {
            bits: u8,
        }
        impl BypshadR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FmtR {
            bits: u8,
        }
        impl FmtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlraeR {
            bits: u8,
        }
        impl AlraeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TseR {
            bits: u8,
        }
        impl TseR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlraieR {
            bits: u8,
        }
        impl AlraieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsieR {
            bits: u8,
        }
        impl TsieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CoselR {
            bits: u8,
        }
        impl CoselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PolR {
            bits: u8,
        }
        impl PolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OselR {
            bits: u8,
        }
        impl OselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CoeR {
            bits: u8,
        }
        impl CoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsedgeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsedgeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFCKON`"]
        pub enum RefckonW {
            #[doc = "Off."]
            Off,
            #[doc = "On."]
            On,
        }
        impl RefckonW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RefckonW::Off => 0,
                    RefckonW::On => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RefckonW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RefckonW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: RefckonW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Off."]
            #[inline ( always )]
            pub fn off(self) -> &'a mut W {
                self.variant(RefckonW::Off)
            }
            #[doc = "On."]
            #[inline ( always )]
            pub fn on(self) -> &'a mut W {
                self.variant(RefckonW::On)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BypshadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BypshadW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FmtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FmtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlraeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlraeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TseW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlraieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlraieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Add1hW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add1hW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Sub1hW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Sub1hW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CoselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CoselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Time-stamp event active edge"]
            #[inline ( always )]
            pub fn tsedge(&self) -> TsedgeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsedgeR { bits }
            }
            #[doc = "Bit 4 - RTC_REFIN reference clock detection enable (50 or 60 Hz)"]
            #[inline ( always )]
            pub fn refckon(&self) -> RefckonR {
                RefckonR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 4;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 5 - Bypass the shadow registers"]
            #[inline ( always )]
            pub fn bypshad(&self) -> BypshadR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BypshadR { bits }
            }
            #[doc = "Bit 6 - Hour format"]
            #[inline ( always )]
            pub fn fmt(&self) -> FmtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FmtR { bits }
            }
            #[doc = "Bit 8 - Alarm A enable"]
            #[inline ( always )]
            pub fn alrae(&self) -> AlraeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlraeR { bits }
            }
            #[doc = "Bit 11 - timestamp enable"]
            #[inline ( always )]
            pub fn tse(&self) -> TseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TseR { bits }
            }
            #[doc = "Bit 12 - Alarm A interrupt enable"]
            #[inline ( always )]
            pub fn alraie(&self) -> AlraieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlraieR { bits }
            }
            #[doc = "Bit 15 - Time-stamp interrupt enable"]
            #[inline ( always )]
            pub fn tsie(&self) -> TsieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsieR { bits }
            }
            #[doc = "Bit 18 - Backup"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            #[doc = "Bit 19 - Calibration output selection"]
            #[inline ( always )]
            pub fn cosel(&self) -> CoselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CoselR { bits }
            }
            #[doc = "Bit 20 - Output polarity"]
            #[inline ( always )]
            pub fn pol(&self) -> PolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PolR { bits }
            }
            #[doc = "Bits 21:22 - Output selection"]
            #[inline ( always )]
            pub fn osel(&self) -> OselR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OselR { bits }
            }
            #[doc = "Bit 23 - Calibration output enable"]
            #[inline ( always )]
            pub fn coe(&self) -> CoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CoeR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Time-stamp event active edge"]
            #[inline ( always )]
            pub fn tsedge(&mut self) -> _TsedgeW {
                _TsedgeW { w: self }
            }
            #[doc = "Bit 4 - RTC_REFIN reference clock detection enable (50 or 60 Hz)"]
            #[inline ( always )]
            pub fn refckon(&mut self) -> _RefckonW {
                _RefckonW { w: self }
            }
            #[doc = "Bit 5 - Bypass the shadow registers"]
            #[inline ( always )]
            pub fn bypshad(&mut self) -> _BypshadW {
                _BypshadW { w: self }
            }
            #[doc = "Bit 6 - Hour format"]
            #[inline ( always )]
            pub fn fmt(&mut self) -> _FmtW {
                _FmtW { w: self }
            }
            #[doc = "Bit 8 - Alarm A enable"]
            #[inline ( always )]
            pub fn alrae(&mut self) -> _AlraeW {
                _AlraeW { w: self }
            }
            #[doc = "Bit 11 - timestamp enable"]
            #[inline ( always )]
            pub fn tse(&mut self) -> _TseW {
                _TseW { w: self }
            }
            #[doc = "Bit 12 - Alarm A interrupt enable"]
            #[inline ( always )]
            pub fn alraie(&mut self) -> _AlraieW {
                _AlraieW { w: self }
            }
            #[doc = "Bit 15 - Time-stamp interrupt enable"]
            #[inline ( always )]
            pub fn tsie(&mut self) -> _TsieW {
                _TsieW { w: self }
            }
            #[doc = "Bit 16 - Add 1 hour (summer time change)"]
            #[inline ( always )]
            pub fn add1h(&mut self) -> _Add1hW {
                _Add1hW { w: self }
            }
            #[doc = "Bit 17 - Subtract 1 hour (winter time change)"]
            #[inline ( always )]
            pub fn sub1h(&mut self) -> _Sub1hW {
                _Sub1hW { w: self }
            }
            #[doc = "Bit 18 - Backup"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            #[doc = "Bit 19 - Calibration output selection"]
            #[inline ( always )]
            pub fn cosel(&mut self) -> _CoselW {
                _CoselW { w: self }
            }
            #[doc = "Bit 20 - Output polarity"]
            #[inline ( always )]
            pub fn pol(&mut self) -> _PolW {
                _PolW { w: self }
            }
            #[doc = "Bits 21:22 - Output selection"]
            #[inline ( always )]
            pub fn osel(&mut self) -> _OselW {
                _OselW { w: self }
            }
            #[doc = "Bit 23 - Calibration output enable"]
            #[inline ( always )]
            pub fn coe(&mut self) -> _CoeW {
                _CoeW { w: self }
            }
        }
    }
    #[doc = "initialization and status register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "initialization and status register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlrawfR {
            bits: u8,
        }
        impl AlrawfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ShpfR {
            bits: u8,
        }
        impl ShpfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct InitsR {
            bits: u8,
        }
        impl InitsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RsfR {
            bits: u8,
        }
        impl RsfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct InitfR {
            bits: u8,
        }
        impl InitfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct InitR {
            bits: u8,
        }
        impl InitR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AlrafR {
            bits: u8,
        }
        impl AlrafR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsfR {
            bits: u8,
        }
        impl TsfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsovfR {
            bits: u8,
        }
        impl TsovfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp1fR {
            bits: u8,
        }
        impl Tamp1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp2fR {
            bits: u8,
        }
        impl Tamp2fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RecalpfR {
            bits: u8,
        }
        impl RecalpfR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ShpfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ShpfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RsfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RsfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _InitW<'a> {
            w: &'a mut W,
        }
        impl<'a> _InitW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AlrafW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AlrafW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsovfW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsovfW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp2fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Alarm A write flag"]
            #[inline ( always )]
            pub fn alrawf(&self) -> AlrawfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlrawfR { bits }
            }
            #[doc = "Bit 3 - Shift operation pending"]
            #[inline ( always )]
            pub fn shpf(&self) -> ShpfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ShpfR { bits }
            }
            #[doc = "Bit 4 - Initialization status flag"]
            #[inline ( always )]
            pub fn inits(&self) -> InitsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                InitsR { bits }
            }
            #[doc = "Bit 5 - Registers synchronization flag"]
            #[inline ( always )]
            pub fn rsf(&self) -> RsfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RsfR { bits }
            }
            #[doc = "Bit 6 - Initialization flag"]
            #[inline ( always )]
            pub fn initf(&self) -> InitfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                InitfR { bits }
            }
            #[doc = "Bit 7 - Initialization mode"]
            #[inline ( always )]
            pub fn init(&self) -> InitR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                InitR { bits }
            }
            #[doc = "Bit 8 - Alarm A flag"]
            #[inline ( always )]
            pub fn alraf(&self) -> AlrafR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AlrafR { bits }
            }
            #[doc = "Bit 11 - Time-stamp flag"]
            #[inline ( always )]
            pub fn tsf(&self) -> TsfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsfR { bits }
            }
            #[doc = "Bit 12 - Time-stamp overflow flag"]
            #[inline ( always )]
            pub fn tsovf(&self) -> TsovfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsovfR { bits }
            }
            #[doc = "Bit 13 - RTC_TAMP1 detection flag"]
            #[inline ( always )]
            pub fn tamp1f(&self) -> Tamp1fR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp1fR { bits }
            }
            #[doc = "Bit 14 - RTC_TAMP2 detection flag"]
            #[inline ( always )]
            pub fn tamp2f(&self) -> Tamp2fR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp2fR { bits }
            }
            #[doc = "Bit 16 - Recalibration pending Flag"]
            #[inline ( always )]
            pub fn recalpf(&self) -> RecalpfR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RecalpfR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 7 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Shift operation pending"]
            #[inline ( always )]
            pub fn shpf(&mut self) -> _ShpfW {
                _ShpfW { w: self }
            }
            #[doc = "Bit 5 - Registers synchronization flag"]
            #[inline ( always )]
            pub fn rsf(&mut self) -> _RsfW {
                _RsfW { w: self }
            }
            #[doc = "Bit 7 - Initialization mode"]
            #[inline ( always )]
            pub fn init(&mut self) -> _InitW {
                _InitW { w: self }
            }
            #[doc = "Bit 8 - Alarm A flag"]
            #[inline ( always )]
            pub fn alraf(&mut self) -> _AlrafW {
                _AlrafW { w: self }
            }
            #[doc = "Bit 11 - Time-stamp flag"]
            #[inline ( always )]
            pub fn tsf(&mut self) -> _TsfW {
                _TsfW { w: self }
            }
            #[doc = "Bit 12 - Time-stamp overflow flag"]
            #[inline ( always )]
            pub fn tsovf(&mut self) -> _TsovfW {
                _TsovfW { w: self }
            }
            #[doc = "Bit 13 - RTC_TAMP1 detection flag"]
            #[inline ( always )]
            pub fn tamp1f(&mut self) -> _Tamp1fW {
                _Tamp1fW { w: self }
            }
            #[doc = "Bit 14 - RTC_TAMP2 detection flag"]
            #[inline ( always )]
            pub fn tamp2f(&mut self) -> _Tamp2fW {
                _Tamp2fW { w: self }
            }
        }
    }
    #[doc = "prescaler register"]
    pub struct Prer {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler register"]
    pub mod prer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Prer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PredivAR {
            bits: u8,
        }
        impl PredivAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PredivSR {
            bits: u16,
        }
        impl PredivSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PredivAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PredivAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PredivSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PredivSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 32767;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 16:22 - Asynchronous prescaler factor"]
            #[inline ( always )]
            pub fn prediv_a(&self) -> PredivAR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PredivAR { bits }
            }
            #[doc = "Bits 0:14 - Synchronous prescaler factor"]
            #[inline ( always )]
            pub fn prediv_s(&self) -> PredivSR {
                let bits = {
                    const MASK: u16 = 32767;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PredivSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 8323327 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 16:22 - Asynchronous prescaler factor"]
            #[inline ( always )]
            pub fn prediv_a(&mut self) -> _PredivAW {
                _PredivAW { w: self }
            }
            #[doc = "Bits 0:14 - Synchronous prescaler factor"]
            #[inline ( always )]
            pub fn prediv_s(&mut self) -> _PredivSW {
                _PredivSW { w: self }
            }
        }
    }
    #[doc = "alarm A register"]
    pub struct Alrmar {
        register: VolatileCell<u32>,
    }
    #[doc = "alarm A register"]
    pub mod alrmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Alrmar {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Msk4R {
            bits: u8,
        }
        impl Msk4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WdselR {
            bits: u8,
        }
        impl WdselR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtR {
            bits: u8,
        }
        impl DtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DuR {
            bits: u8,
        }
        impl DuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Msk3R {
            bits: u8,
        }
        impl Msk3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PmR {
            bits: u8,
        }
        impl PmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtR {
            bits: u8,
        }
        impl HtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HuR {
            bits: u8,
        }
        impl HuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Msk2R {
            bits: u8,
        }
        impl Msk2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MntR {
            bits: u8,
        }
        impl MntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MnuR {
            bits: u8,
        }
        impl MnuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Msk1R {
            bits: u8,
        }
        impl Msk1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StR {
            bits: u8,
        }
        impl StR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SuR {
            bits: u8,
        }
        impl SuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Msk4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Msk4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WdselW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WdselW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Msk3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Msk3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Msk2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Msk2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MnuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MnuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Msk1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Msk1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SuW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SuW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 31 - Alarm A date mask"]
            #[inline ( always )]
            pub fn msk4(&self) -> Msk4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Msk4R { bits }
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline ( always )]
            pub fn wdsel(&self) -> WdselR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdselR { bits }
            }
            #[doc = "Bits 28:29 - Date tens in BCD format."]
            #[inline ( always )]
            pub fn dt(&self) -> DtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtR { bits }
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format."]
            #[inline ( always )]
            pub fn du(&self) -> DuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DuR { bits }
            }
            #[doc = "Bit 23 - Alarm A hours mask"]
            #[inline ( always )]
            pub fn msk3(&self) -> Msk3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Msk3R { bits }
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline ( always )]
            pub fn pm(&self) -> PmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PmR { bits }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline ( always )]
            pub fn ht(&self) -> HtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtR { bits }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline ( always )]
            pub fn hu(&self) -> HuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HuR { bits }
            }
            #[doc = "Bit 15 - Alarm A minutes mask"]
            #[inline ( always )]
            pub fn msk2(&self) -> Msk2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Msk2R { bits }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline ( always )]
            pub fn mnt(&self) -> MntR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MntR { bits }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline ( always )]
            pub fn mnu(&self) -> MnuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MnuR { bits }
            }
            #[doc = "Bit 7 - Alarm A seconds mask"]
            #[inline ( always )]
            pub fn msk1(&self) -> Msk1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Msk1R { bits }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline ( always )]
            pub fn st(&self) -> StR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StR { bits }
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline ( always )]
            pub fn su(&self) -> SuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SuR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - Alarm A date mask"]
            #[inline ( always )]
            pub fn msk4(&mut self) -> _Msk4W {
                _Msk4W { w: self }
            }
            #[doc = "Bit 30 - Week day selection"]
            #[inline ( always )]
            pub fn wdsel(&mut self) -> _WdselW {
                _WdselW { w: self }
            }
            #[doc = "Bits 28:29 - Date tens in BCD format."]
            #[inline ( always )]
            pub fn dt(&mut self) -> _DtW {
                _DtW { w: self }
            }
            #[doc = "Bits 24:27 - Date units or day in BCD format."]
            #[inline ( always )]
            pub fn du(&mut self) -> _DuW {
                _DuW { w: self }
            }
            #[doc = "Bit 23 - Alarm A hours mask"]
            #[inline ( always )]
            pub fn msk3(&mut self) -> _Msk3W {
                _Msk3W { w: self }
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline ( always )]
            pub fn pm(&mut self) -> _PmW {
                _PmW { w: self }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline ( always )]
            pub fn ht(&mut self) -> _HtW {
                _HtW { w: self }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline ( always )]
            pub fn hu(&mut self) -> _HuW {
                _HuW { w: self }
            }
            #[doc = "Bit 15 - Alarm A minutes mask"]
            #[inline ( always )]
            pub fn msk2(&mut self) -> _Msk2W {
                _Msk2W { w: self }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline ( always )]
            pub fn mnt(&mut self) -> _MntW {
                _MntW { w: self }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline ( always )]
            pub fn mnu(&mut self) -> _MnuW {
                _MnuW { w: self }
            }
            #[doc = "Bit 7 - Alarm A seconds mask"]
            #[inline ( always )]
            pub fn msk1(&mut self) -> _Msk1W {
                _Msk1W { w: self }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline ( always )]
            pub fn st(&mut self) -> _StW {
                _StW { w: self }
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline ( always )]
            pub fn su(&mut self) -> _SuW {
                _SuW { w: self }
            }
        }
    }
    #[doc = "write protection register"]
    pub struct Wpr {
        register: VolatileCell<u32>,
    }
    #[doc = "write protection register"]
    pub mod wpr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Wpr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _KeyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _KeyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Write protection key"]
            #[inline ( always )]
            pub fn key(&mut self) -> _KeyW {
                _KeyW { w: self }
            }
        }
    }
    #[doc = "sub second register"]
    pub struct Ssr {
        register: VolatileCell<u32>,
    }
    #[doc = "sub second register"]
    pub mod ssr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Ssr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsR {
            bits: u16,
        }
        impl SsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Sub second value"]
            #[inline ( always )]
            pub fn ss(&self) -> SsR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                SsR { bits }
            }
        }
    }
    #[doc = "shift control register"]
    pub struct Shiftr {
        register: VolatileCell<u32>,
    }
    #[doc = "shift control register"]
    pub mod shiftr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Shiftr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _Add1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Add1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SubfsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SubfsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 32767;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 31 - Reserved"]
            #[inline ( always )]
            pub fn add1s(&mut self) -> _Add1sW {
                _Add1sW { w: self }
            }
            #[doc = "Bits 0:14 - Subtract a fraction of a second"]
            #[inline ( always )]
            pub fn subfs(&mut self) -> _SubfsW {
                _SubfsW { w: self }
            }
        }
    }
    #[doc = "timestamp time register"]
    pub struct Tstr {
        register: VolatileCell<u32>,
    }
    #[doc = "timestamp time register"]
    pub mod tstr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Tstr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PmR {
            bits: u8,
        }
        impl PmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HtR {
            bits: u8,
        }
        impl HtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HuR {
            bits: u8,
        }
        impl HuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MntR {
            bits: u8,
        }
        impl MntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MnuR {
            bits: u8,
        }
        impl MnuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StR {
            bits: u8,
        }
        impl StR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SuR {
            bits: u8,
        }
        impl SuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 22 - AM/PM notation"]
            #[inline ( always )]
            pub fn pm(&self) -> PmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PmR { bits }
            }
            #[doc = "Bits 20:21 - Hour tens in BCD format."]
            #[inline ( always )]
            pub fn ht(&self) -> HtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HtR { bits }
            }
            #[doc = "Bits 16:19 - Hour units in BCD format."]
            #[inline ( always )]
            pub fn hu(&self) -> HuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HuR { bits }
            }
            #[doc = "Bits 12:14 - Minute tens in BCD format."]
            #[inline ( always )]
            pub fn mnt(&self) -> MntR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MntR { bits }
            }
            #[doc = "Bits 8:11 - Minute units in BCD format."]
            #[inline ( always )]
            pub fn mnu(&self) -> MnuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MnuR { bits }
            }
            #[doc = "Bits 4:6 - Second tens in BCD format."]
            #[inline ( always )]
            pub fn st(&self) -> StR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StR { bits }
            }
            #[doc = "Bits 0:3 - Second units in BCD format."]
            #[inline ( always )]
            pub fn su(&self) -> SuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SuR { bits }
            }
        }
    }
    #[doc = "timestamp date register"]
    pub struct Tsdr {
        register: VolatileCell<u32>,
    }
    #[doc = "timestamp date register"]
    pub mod tsdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Tsdr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct WduR {
            bits: u8,
        }
        impl WduR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MtR {
            bits: u8,
        }
        impl MtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MuR {
            bits: u8,
        }
        impl MuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtR {
            bits: u8,
        }
        impl DtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DuR {
            bits: u8,
        }
        impl DuR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 13:15 - Week day units"]
            #[inline ( always )]
            pub fn wdu(&self) -> WduR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WduR { bits }
            }
            #[doc = "Bit 12 - Month tens in BCD format"]
            #[inline ( always )]
            pub fn mt(&self) -> MtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MtR { bits }
            }
            #[doc = "Bits 8:11 - Month units in BCD format"]
            #[inline ( always )]
            pub fn mu(&self) -> MuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MuR { bits }
            }
            #[doc = "Bits 4:5 - Date tens in BCD format"]
            #[inline ( always )]
            pub fn dt(&self) -> DtR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtR { bits }
            }
            #[doc = "Bits 0:3 - Date units in BCD format"]
            #[inline ( always )]
            pub fn du(&self) -> DuR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DuR { bits }
            }
        }
    }
    #[doc = "time-stamp sub second register"]
    pub struct Tsssr {
        register: VolatileCell<u32>,
    }
    #[doc = "time-stamp sub second register"]
    pub mod tsssr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Tsssr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsR {
            bits: u16,
        }
        impl SsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Sub second value"]
            #[inline ( always )]
            pub fn ss(&self) -> SsR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                SsR { bits }
            }
        }
    }
    #[doc = "calibration register"]
    pub struct Calr {
        register: VolatileCell<u32>,
    }
    #[doc = "calibration register"]
    pub mod calr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Calr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CalpR {
            bits: u8,
        }
        impl CalpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Calw8R {
            bits: u8,
        }
        impl Calw8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Calw16R {
            bits: u8,
        }
        impl Calw16R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CalmR {
            bits: u16,
        }
        impl CalmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CalpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CalpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Calw8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Calw8W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Calw16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Calw16W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CalmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CalmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Use an 8-second calibration cycle period"]
            #[inline ( always )]
            pub fn calp(&self) -> CalpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CalpR { bits }
            }
            #[doc = "Bit 14 - Use a 16-second calibration cycle period"]
            #[inline ( always )]
            pub fn calw8(&self) -> Calw8R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Calw8R { bits }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn calw16(&self) -> Calw16R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Calw16R { bits }
            }
            #[doc = "Bits 0:8 - Calibration minus"]
            #[inline ( always )]
            pub fn calm(&self) -> CalmR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CalmR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Use an 8-second calibration cycle period"]
            #[inline ( always )]
            pub fn calp(&mut self) -> _CalpW {
                _CalpW { w: self }
            }
            #[doc = "Bit 14 - Use a 16-second calibration cycle period"]
            #[inline ( always )]
            pub fn calw8(&mut self) -> _Calw8W {
                _Calw8W { w: self }
            }
            #[doc = "Bit 13 - Reserved"]
            #[inline ( always )]
            pub fn calw16(&mut self) -> _Calw16W {
                _Calw16W { w: self }
            }
            #[doc = "Bits 0:8 - Calibration minus"]
            #[inline ( always )]
            pub fn calm(&mut self) -> _CalmW {
                _CalmW { w: self }
            }
        }
    }
    #[doc = "tamper and alternate function configuration register"]
    pub struct Tafcr {
        register: VolatileCell<u32>,
    }
    #[doc = "tamper and alternate function configuration register"]
    pub mod tafcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Tafcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc15modeR {
            bits: u8,
        }
        impl Pc15modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc15valueR {
            bits: u8,
        }
        impl Pc15valueR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc14modeR {
            bits: u8,
        }
        impl Pc14modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc14valueR {
            bits: u8,
        }
        impl Pc14valueR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc13modeR {
            bits: u8,
        }
        impl Pc13modeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Pc13valueR {
            bits: u8,
        }
        impl Pc13valueR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TampPudisR {
            bits: u8,
        }
        impl TampPudisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TampPrchR {
            bits: u8,
        }
        impl TampPrchR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TampfltR {
            bits: u8,
        }
        impl TampfltR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TampfreqR {
            bits: u8,
        }
        impl TampfreqR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TamptsR {
            bits: u8,
        }
        impl TamptsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp2TrgR {
            bits: u8,
        }
        impl Tamp2TrgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp2eR {
            bits: u8,
        }
        impl Tamp2eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TampieR {
            bits: u8,
        }
        impl TampieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp1trgR {
            bits: u8,
        }
        impl Tamp1trgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Tamp1eR {
            bits: u8,
        }
        impl Tamp1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc15modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc15modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc15valueW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc15valueW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc14modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc14modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc14valueW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc14valueW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc13modeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc13modeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Pc13valueW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Pc13valueW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TampPudisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TampPudisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TampPrchW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TampPrchW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TampfltW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TampfltW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TampfreqW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TampfreqW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TamptsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TamptsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp2TrgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp2TrgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp2eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TampieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TampieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp1trgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp1trgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Tamp1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Tamp1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - PC15 mode"]
            #[inline ( always )]
            pub fn pc15mode(&self) -> Pc15modeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc15modeR { bits }
            }
            #[doc = "Bit 22 - PC15 value"]
            #[inline ( always )]
            pub fn pc15value(&self) -> Pc15valueR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc15valueR { bits }
            }
            #[doc = "Bit 21 - PC14 mode"]
            #[inline ( always )]
            pub fn pc14mode(&self) -> Pc14modeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc14modeR { bits }
            }
            #[doc = "Bit 20 - PC14 value"]
            #[inline ( always )]
            pub fn pc14value(&self) -> Pc14valueR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc14valueR { bits }
            }
            #[doc = "Bit 19 - PC13 mode"]
            #[inline ( always )]
            pub fn pc13mode(&self) -> Pc13modeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc13modeR { bits }
            }
            #[doc = "Bit 18 - RTC_ALARM output type/PC13 value"]
            #[inline ( always )]
            pub fn pc13value(&self) -> Pc13valueR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Pc13valueR { bits }
            }
            #[doc = "Bit 15 - RTC_TAMPx pull-up disable"]
            #[inline ( always )]
            pub fn tamp_pudis(&self) -> TampPudisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TampPudisR { bits }
            }
            #[doc = "Bits 13:14 - RTC_TAMPx precharge duration"]
            #[inline ( always )]
            pub fn tamp_prch(&self) -> TampPrchR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TampPrchR { bits }
            }
            #[doc = "Bits 11:12 - RTC_TAMPx filter count"]
            #[inline ( always )]
            pub fn tampflt(&self) -> TampfltR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TampfltR { bits }
            }
            #[doc = "Bits 8:10 - Tamper sampling frequency"]
            #[inline ( always )]
            pub fn tampfreq(&self) -> TampfreqR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TampfreqR { bits }
            }
            #[doc = "Bit 7 - Activate timestamp on tamper detection event"]
            #[inline ( always )]
            pub fn tampts(&self) -> TamptsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TamptsR { bits }
            }
            #[doc = "Bit 4 - Active level for RTC_TAMP2 input"]
            #[inline ( always )]
            pub fn tamp2_trg(&self) -> Tamp2TrgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp2TrgR { bits }
            }
            #[doc = "Bit 3 - RTC_TAMP2 input detection enable"]
            #[inline ( always )]
            pub fn tamp2e(&self) -> Tamp2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp2eR { bits }
            }
            #[doc = "Bit 2 - Tamper interrupt enable"]
            #[inline ( always )]
            pub fn tampie(&self) -> TampieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TampieR { bits }
            }
            #[doc = "Bit 1 - Active level for RTC_TAMP1 input"]
            #[inline ( always )]
            pub fn tamp1trg(&self) -> Tamp1trgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp1trgR { bits }
            }
            #[doc = "Bit 0 - RTC_TAMP1 input detection enable"]
            #[inline ( always )]
            pub fn tamp1e(&self) -> Tamp1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Tamp1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - PC15 mode"]
            #[inline ( always )]
            pub fn pc15mode(&mut self) -> _Pc15modeW {
                _Pc15modeW { w: self }
            }
            #[doc = "Bit 22 - PC15 value"]
            #[inline ( always )]
            pub fn pc15value(&mut self) -> _Pc15valueW {
                _Pc15valueW { w: self }
            }
            #[doc = "Bit 21 - PC14 mode"]
            #[inline ( always )]
            pub fn pc14mode(&mut self) -> _Pc14modeW {
                _Pc14modeW { w: self }
            }
            #[doc = "Bit 20 - PC14 value"]
            #[inline ( always )]
            pub fn pc14value(&mut self) -> _Pc14valueW {
                _Pc14valueW { w: self }
            }
            #[doc = "Bit 19 - PC13 mode"]
            #[inline ( always )]
            pub fn pc13mode(&mut self) -> _Pc13modeW {
                _Pc13modeW { w: self }
            }
            #[doc = "Bit 18 - RTC_ALARM output type/PC13 value"]
            #[inline ( always )]
            pub fn pc13value(&mut self) -> _Pc13valueW {
                _Pc13valueW { w: self }
            }
            #[doc = "Bit 15 - RTC_TAMPx pull-up disable"]
            #[inline ( always )]
            pub fn tamp_pudis(&mut self) -> _TampPudisW {
                _TampPudisW { w: self }
            }
            #[doc = "Bits 13:14 - RTC_TAMPx precharge duration"]
            #[inline ( always )]
            pub fn tamp_prch(&mut self) -> _TampPrchW {
                _TampPrchW { w: self }
            }
            #[doc = "Bits 11:12 - RTC_TAMPx filter count"]
            #[inline ( always )]
            pub fn tampflt(&mut self) -> _TampfltW {
                _TampfltW { w: self }
            }
            #[doc = "Bits 8:10 - Tamper sampling frequency"]
            #[inline ( always )]
            pub fn tampfreq(&mut self) -> _TampfreqW {
                _TampfreqW { w: self }
            }
            #[doc = "Bit 7 - Activate timestamp on tamper detection event"]
            #[inline ( always )]
            pub fn tampts(&mut self) -> _TamptsW {
                _TamptsW { w: self }
            }
            #[doc = "Bit 4 - Active level for RTC_TAMP2 input"]
            #[inline ( always )]
            pub fn tamp2_trg(&mut self) -> _Tamp2TrgW {
                _Tamp2TrgW { w: self }
            }
            #[doc = "Bit 3 - RTC_TAMP2 input detection enable"]
            #[inline ( always )]
            pub fn tamp2e(&mut self) -> _Tamp2eW {
                _Tamp2eW { w: self }
            }
            #[doc = "Bit 2 - Tamper interrupt enable"]
            #[inline ( always )]
            pub fn tampie(&mut self) -> _TampieW {
                _TampieW { w: self }
            }
            #[doc = "Bit 1 - Active level for RTC_TAMP1 input"]
            #[inline ( always )]
            pub fn tamp1trg(&mut self) -> _Tamp1trgW {
                _Tamp1trgW { w: self }
            }
            #[doc = "Bit 0 - RTC_TAMP1 input detection enable"]
            #[inline ( always )]
            pub fn tamp1e(&mut self) -> _Tamp1eW {
                _Tamp1eW { w: self }
            }
        }
    }
    #[doc = "alarm A sub second register"]
    pub struct Alrmassr {
        register: VolatileCell<u32>,
    }
    #[doc = "alarm A sub second register"]
    pub mod alrmassr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Alrmassr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MaskssR {
            bits: u8,
        }
        impl MaskssR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsR {
            bits: u16,
        }
        impl SsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MaskssW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MaskssW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 32767;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline ( always )]
            pub fn maskss(&self) -> MaskssR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MaskssR { bits }
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline ( always )]
            pub fn ss(&self) -> SsR {
                let bits = {
                    const MASK: u16 = 32767;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                SsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 24:27 - Mask the most-significant bits starting at this bit"]
            #[inline ( always )]
            pub fn maskss(&mut self) -> _MaskssW {
                _MaskssW { w: self }
            }
            #[doc = "Bits 0:14 - Sub seconds value"]
            #[inline ( always )]
            pub fn ss(&mut self) -> _SsW {
                _SsW { w: self }
            }
        }
    }
    #[doc = "backup register"]
    pub struct Bkp0r {
        register: VolatileCell<u32>,
    }
    #[doc = "backup register"]
    pub mod bkp0r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bkp0r {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u32,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BkpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
        }
    }
    #[doc = "backup register"]
    pub struct Bkp1r {
        register: VolatileCell<u32>,
    }
    #[doc = "backup register"]
    pub mod bkp1r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bkp1r {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u32,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BkpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
        }
    }
    #[doc = "backup register"]
    pub struct Bkp2r {
        register: VolatileCell<u32>,
    }
    #[doc = "backup register"]
    pub mod bkp2r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bkp2r {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u32,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BkpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
        }
    }
    #[doc = "backup register"]
    pub struct Bkp3r {
        register: VolatileCell<u32>,
    }
    #[doc = "backup register"]
    pub mod bkp3r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bkp3r {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u32,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BkpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
        }
    }
    #[doc = "backup register"]
    pub struct Bkp4r {
        register: VolatileCell<u32>,
    }
    #[doc = "backup register"]
    pub mod bkp4r {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bkp4r {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u32,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                BkpR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - BKP"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
        }
    }
}
#[doc = "Real-time clock"]
pub struct Rtc {
    register_block: rtc::RegisterBlock,
}
impl Deref for Rtc {
    type Target = rtc::RegisterBlock;
    fn deref(&self) -> &rtc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose-timers"]
pub const TIM15: Peripheral<Tim15> = unsafe { Peripheral::new(1073823744) };
#[doc = "General-purpose-timers"]
pub mod tim15 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        #[doc = "0x08 - slave mode control register"]
        pub smcr: Smcr,
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: Ccmr1Output,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: Ccer,
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: Rcr,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: Ccr1,
        #[doc = "0x38 - capture/compare register 2"]
        pub ccr2: Ccr2,
        _reserved1: [u8; 8usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: Bdtr,
        #[doc = "0x48 - DMA control register"]
        pub dcr: Dcr,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: Dmar,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois2R {
            bits: u8,
        }
        impl Ois2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MmsR {
            bits: u8,
        }
        impl MmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2(&self) -> Ois2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois2R { bits }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&self) -> MmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MmsR { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - Output Idle state 2"]
            #[inline ( always )]
            pub fn ois2(&mut self) -> _Ois2W {
                _Ois2W { w: self }
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            #[doc = "Bits 4:6 - Master mode selection"]
            #[inline ( always )]
            pub fn mms(&mut self) -> _MmsW {
                _MmsW { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    #[doc = "slave mode control register"]
    pub struct Smcr {
        register: VolatileCell<u32>,
    }
    #[doc = "slave mode control register"]
    pub mod smcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Smcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MsmR {
            bits: u8,
        }
        impl MsmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsR {
            bits: u8,
        }
        impl TsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SmsR {
            bits: u8,
        }
        impl SmsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MsmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MsmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SmsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SmsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&self) -> MsmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MsmR { bits }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&self) -> TsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsR { bits }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&self) -> SmsR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SmsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Master/Slave mode"]
            #[inline ( always )]
            pub fn msm(&mut self) -> _MsmW {
                _MsmW { w: self }
            }
            #[doc = "Bits 4:6 - Trigger selection"]
            #[inline ( always )]
            pub fn ts(&mut self) -> _TsW {
                _TsW { w: self }
            }
            #[doc = "Bits 0:2 - Slave mode selection"]
            #[inline ( always )]
            pub fn sms(&mut self) -> _SmsW {
                _SmsW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2deR {
            bits: u8,
        }
        impl Cc2deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ieR {
            bits: u8,
        }
        impl Cc2ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&self) -> Cc2deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2deR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&self) -> Cc2ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ieR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            #[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
            #[inline ( always )]
            pub fn cc2de(&mut self) -> _Cc2deW {
                _Cc2deW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
            #[inline ( always )]
            pub fn cc2ie(&mut self) -> _Cc2ieW {
                _Cc2ieW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ofR {
            bits: u8,
        }
        impl Cc2ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2ifR {
            bits: u8,
        }
        impl Cc2ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&self) -> Cc2ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ofR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&self) -> Cc2ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2ifR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - Capture/compare 2 overcapture flag"]
            #[inline ( always )]
            pub fn cc2of(&mut self) -> _Cc2ofW {
                _Cc2ofW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
            #[inline ( always )]
            pub fn cc2if(&mut self) -> _Cc2ifW {
                _Cc2ifW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline ( always )]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline ( always )]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline ( always )]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare 2 generation"]
            #[inline ( always )]
            pub fn cc2g(&mut self) -> _Cc2gW {
                _Cc2gW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline ( always )]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2mR {
            bits: u8,
        }
        impl Oc2mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2peR {
            bits: u8,
        }
        impl Oc2peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc2feR {
            bits: u8,
        }
        impl Oc2feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc2feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc2feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&self) -> Oc2mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2mR { bits }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&self) -> Oc2peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2peR { bits }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&self) -> Oc2feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc2feR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:14 - Output Compare 2 mode"]
            #[inline ( always )]
            pub fn oc2m(&mut self) -> _Oc2mW {
                _Oc2mW { w: self }
            }
            #[doc = "Bit 11 - Output Compare 2 preload enable"]
            #[inline ( always )]
            pub fn oc2pe(&mut self) -> _Oc2peW {
                _Oc2peW { w: self }
            }
            #[doc = "Bit 10 - Output Compare 2 fast enable"]
            #[inline ( always )]
            pub fn oc2fe(&mut self) -> _Oc2feW {
                _Oc2feW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2fR {
            bits: u8,
        }
        impl Ic2fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic2pscR {
            bits: u8,
        }
        impl Ic2pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2sR {
            bits: u8,
        }
        impl Cc2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic2pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic2pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&self) -> Ic2fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2fR { bits }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2psc(&self) -> Ic2pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic2pscR { bits }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&self) -> Cc2sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2sR { bits }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 12:15 - Input capture 2 filter"]
            #[inline ( always )]
            pub fn ic2f(&mut self) -> _Ic2fW {
                _Ic2fW { w: self }
            }
            #[doc = "Bits 10:11 - Input capture 2 prescaler"]
            #[inline ( always )]
            pub fn ic2psc(&mut self) -> _Ic2pscW {
                _Ic2pscW { w: self }
            }
            #[doc = "Bits 8:9 - Capture/Compare 2 selection"]
            #[inline ( always )]
            pub fn cc2s(&mut self) -> _Cc2sW {
                _Cc2sW { w: self }
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2npR {
            bits: u8,
        }
        impl Cc2npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2pR {
            bits: u8,
        }
        impl Cc2pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc2eR {
            bits: u8,
        }
        impl Cc2eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc2eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&self) -> Cc2npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2npR { bits }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&self) -> Cc2pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2pR { bits }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&self) -> Cc2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc2eR { bits }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2np(&mut self) -> _Cc2npW {
                _Cc2npW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare 2 output Polarity"]
            #[inline ( always )]
            pub fn cc2p(&mut self) -> _Cc2pW {
                _Cc2pW { w: self }
            }
            #[doc = "Bit 4 - Capture/Compare 2 output enable"]
            #[inline ( always )]
            pub fn cc2e(&mut self) -> _Cc2eW {
                _Cc2eW { w: self }
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    #[doc = "capture/compare register 2"]
    pub struct Ccr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 2"]
    pub mod ccr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr2R {
            bits: u16,
        }
        impl Ccr2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2(&self) -> Ccr2R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 2 value"]
            #[inline ( always )]
            pub fn ccr2(&mut self) -> _Ccr2W {
                _Ccr2W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct Tim15 {
    register_block: tim15::RegisterBlock,
}
impl Deref for Tim15 {
    type Target = tim15::RegisterBlock;
    fn deref(&self) -> &tim15::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General-purpose-timers"]
pub const TIM16: Peripheral<Tim16> = unsafe { Peripheral::new(1073824768) };
#[doc = "General-purpose-timers"]
pub mod tim16 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register 1"]
        pub cr1: Cr1,
        #[doc = "0x04 - control register 2"]
        pub cr2: Cr2,
        _reserved0: [u8; 4usize],
        #[doc = "0x0c - DMA/Interrupt enable register"]
        pub dier: Dier,
        #[doc = "0x10 - status register"]
        pub sr: Sr,
        #[doc = "0x14 - event generation register"]
        pub egr: Egr,
        #[doc = "0x18 - capture/compare mode register (output mode)"]
        pub ccmr1_output: Ccmr1Output,
        _reserved1: [u8; 4usize],
        #[doc = "0x20 - capture/compare enable register"]
        pub ccer: Ccer,
        #[doc = "0x24 - counter"]
        pub cnt: Cnt,
        #[doc = "0x28 - prescaler"]
        pub psc: Psc,
        #[doc = "0x2c - auto-reload register"]
        pub arr: Arr,
        #[doc = "0x30 - repetition counter register"]
        pub rcr: Rcr,
        #[doc = "0x34 - capture/compare register 1"]
        pub ccr1: Ccr1,
        _reserved2: [u8; 12usize],
        #[doc = "0x44 - break and dead-time register"]
        pub bdtr: Bdtr,
        #[doc = "0x48 - DMA control register"]
        pub dcr: Dcr,
        #[doc = "0x4c - DMA address for full transfer"]
        pub dmar: Dmar,
    }
    #[doc = "control register 1"]
    pub struct Cr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 1"]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CkdR {
            bits: u8,
        }
        impl CkdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArpeR {
            bits: u8,
        }
        impl ArpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpmR {
            bits: u8,
        }
        impl OpmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UrsR {
            bits: u8,
        }
        impl UrsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdisR {
            bits: u8,
        }
        impl UdisR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CenR::Disabled => 0,
                    CenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CenR {
                match bits {
                    0 => CenR::Disabled,
                    1 => CenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _CkdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CkdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UrsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UrsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdisW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdisW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CEN`"]
        pub enum CenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CenW::Disabled => 0,
                    CenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&self) -> CkdR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CkdR { bits }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&self) -> ArpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArpeR { bits }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&self) -> OpmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpmR { bits }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&self) -> UrsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UrsR { bits }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&self) -> UdisR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdisR { bits }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&self) -> CenR {
                CenR::_from({
                                const MASK: u8 = 1;
                                const OFFSET: u8 = 0;
                                ((self.bits >> OFFSET) & MASK as u32) as u8
                            })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:9 - Clock division"]
            #[inline ( always )]
            pub fn ckd(&mut self) -> _CkdW {
                _CkdW { w: self }
            }
            #[doc = "Bit 7 - Auto-reload preload enable"]
            #[inline ( always )]
            pub fn arpe(&mut self) -> _ArpeW {
                _ArpeW { w: self }
            }
            #[doc = "Bit 3 - One-pulse mode"]
            #[inline ( always )]
            pub fn opm(&mut self) -> _OpmW {
                _OpmW { w: self }
            }
            #[doc = "Bit 2 - Update request source"]
            #[inline ( always )]
            pub fn urs(&mut self) -> _UrsW {
                _UrsW { w: self }
            }
            #[doc = "Bit 1 - Update disable"]
            #[inline ( always )]
            pub fn udis(&mut self) -> _UdisW {
                _UdisW { w: self }
            }
            #[doc = "Bit 0 - Counter enable"]
            #[inline ( always )]
            pub fn cen(&mut self) -> _CenW {
                _CenW { w: self }
            }
        }
    }
    #[doc = "control register 2"]
    pub struct Cr2 {
        register: VolatileCell<u32>,
    }
    #[doc = "control register 2"]
    pub mod cr2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1nR {
            bits: u8,
        }
        impl Ois1nR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ois1R {
            bits: u8,
        }
        impl Ois1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcdsR {
            bits: u8,
        }
        impl CcdsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcusR {
            bits: u8,
        }
        impl CcusR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CcpcR {
            bits: u8,
        }
        impl CcpcR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1nW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1nW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ois1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ois1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcdsW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcdsW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcusW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcusW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CcpcW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CcpcW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&self) -> Ois1nR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1nR { bits }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&self) -> Ois1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ois1R { bits }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&self) -> CcdsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcdsR { bits }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&self) -> CcusR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcusR { bits }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&self) -> CcpcR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CcpcR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1n(&mut self) -> _Ois1nW {
                _Ois1nW { w: self }
            }
            #[doc = "Bit 8 - Output Idle state 1"]
            #[inline ( always )]
            pub fn ois1(&mut self) -> _Ois1W {
                _Ois1W { w: self }
            }
            #[doc = "Bit 3 - Capture/compare DMA selection"]
            #[inline ( always )]
            pub fn ccds(&mut self) -> _CcdsW {
                _CcdsW { w: self }
            }
            #[doc = "Bit 2 - Capture/compare control update selection"]
            #[inline ( always )]
            pub fn ccus(&mut self) -> _CcusW {
                _CcusW { w: self }
            }
            #[doc = "Bit 0 - Capture/compare preloaded control"]
            #[inline ( always )]
            pub fn ccpc(&mut self) -> _CcpcW {
                _CcpcW { w: self }
            }
        }
    }
    #[doc = "DMA/Interrupt enable register"]
    pub struct Dier {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA/Interrupt enable register"]
    pub mod dier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TdeR {
            bits: u8,
        }
        impl TdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1deR {
            bits: u8,
        }
        impl Cc1deR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UdeR {
            bits: u8,
        }
        impl UdeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BieR {
            bits: u8,
        }
        impl BieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TieR {
            bits: u8,
        }
        impl TieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComieR {
            bits: u8,
        }
        impl ComieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ieR {
            bits: u8,
        }
        impl Cc1ieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UieR {
            bits: u8,
        }
        impl UieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1deW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1deW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UdeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UdeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&self) -> TdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TdeR { bits }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&self) -> Cc1deR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1deR { bits }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&self) -> UdeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UdeR { bits }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&self) -> BieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BieR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&self) -> TieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TieR { bits }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&self) -> ComieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComieR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&self) -> Cc1ieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ieR { bits }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&self) -> UieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 14 - Trigger DMA request enable"]
            #[inline ( always )]
            pub fn tde(&mut self) -> _TdeW {
                _TdeW { w: self }
            }
            #[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
            #[inline ( always )]
            pub fn cc1de(&mut self) -> _Cc1deW {
                _Cc1deW { w: self }
            }
            #[doc = "Bit 8 - Update DMA request enable"]
            #[inline ( always )]
            pub fn ude(&mut self) -> _UdeW {
                _UdeW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt enable"]
            #[inline ( always )]
            pub fn bie(&mut self) -> _BieW {
                _BieW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt enable"]
            #[inline ( always )]
            pub fn tie(&mut self) -> _TieW {
                _TieW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt enable"]
            #[inline ( always )]
            pub fn comie(&mut self) -> _ComieW {
                _ComieW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
            #[inline ( always )]
            pub fn cc1ie(&mut self) -> _Cc1ieW {
                _Cc1ieW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt enable"]
            #[inline ( always )]
            pub fn uie(&mut self) -> _UieW {
                _UieW { w: self }
            }
        }
    }
    #[doc = "status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ofR {
            bits: u8,
        }
        impl Cc1ofR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BifR {
            bits: u8,
        }
        impl BifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TifR {
            bits: u8,
        }
        impl TifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ComifR {
            bits: u8,
        }
        impl ComifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1ifR {
            bits: u8,
        }
        impl Cc1ifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct UifR {
            bits: u8,
        }
        impl UifR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ofW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ofW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1ifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1ifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UifW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UifW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&self) -> Cc1ofR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ofR { bits }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&self) -> BifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BifR { bits }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&self) -> TifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TifR { bits }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&self) -> ComifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ComifR { bits }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&self) -> Cc1ifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1ifR { bits }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&self) -> UifR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                UifR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
            #[inline ( always )]
            pub fn cc1of(&mut self) -> _Cc1ofW {
                _Cc1ofW { w: self }
            }
            #[doc = "Bit 7 - Break interrupt flag"]
            #[inline ( always )]
            pub fn bif(&mut self) -> _BifW {
                _BifW { w: self }
            }
            #[doc = "Bit 6 - Trigger interrupt flag"]
            #[inline ( always )]
            pub fn tif(&mut self) -> _TifW {
                _TifW { w: self }
            }
            #[doc = "Bit 5 - COM interrupt flag"]
            #[inline ( always )]
            pub fn comif(&mut self) -> _ComifW {
                _ComifW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 interrupt flag"]
            #[inline ( always )]
            pub fn cc1if(&mut self) -> _Cc1ifW {
                _Cc1ifW { w: self }
            }
            #[doc = "Bit 0 - Update interrupt flag"]
            #[inline ( always )]
            pub fn uif(&mut self) -> _UifW {
                _UifW { w: self }
            }
        }
    }
    #[doc = "event generation register"]
    pub struct Egr {
        register: VolatileCell<u32>,
    }
    #[doc = "event generation register"]
    pub mod egr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Egr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _BgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ComgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ComgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1gW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1gW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _UgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - Break generation"]
            #[inline ( always )]
            pub fn bg(&mut self) -> _BgW {
                _BgW { w: self }
            }
            #[doc = "Bit 6 - Trigger generation"]
            #[inline ( always )]
            pub fn tg(&mut self) -> _TgW {
                _TgW { w: self }
            }
            #[doc = "Bit 5 - Capture/Compare control update generation"]
            #[inline ( always )]
            pub fn comg(&mut self) -> _ComgW {
                _ComgW { w: self }
            }
            #[doc = "Bit 1 - Capture/compare 1 generation"]
            #[inline ( always )]
            pub fn cc1g(&mut self) -> _Cc1gW {
                _Cc1gW { w: self }
            }
            #[doc = "Bit 0 - Update generation"]
            #[inline ( always )]
            pub fn ug(&mut self) -> _UgW {
                _UgW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub struct Ccmr1Output {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register (output mode)"]
    pub mod ccmr1_output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Output {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1mR {
            bits: u8,
        }
        impl Oc1mR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1peR {
            bits: u8,
        }
        impl Oc1peR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Oc1feR {
            bits: u8,
        }
        impl Oc1feR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1mW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1mW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1peW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1peW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Oc1feW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Oc1feW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&self) -> Oc1mR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1mR { bits }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&self) -> Oc1peR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1peR { bits }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&self) -> Oc1feR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Oc1feR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:6 - Output Compare 1 mode"]
            #[inline ( always )]
            pub fn oc1m(&mut self) -> _Oc1mW {
                _Oc1mW { w: self }
            }
            #[doc = "Bit 3 - Output Compare 1 preload enable"]
            #[inline ( always )]
            pub fn oc1pe(&mut self) -> _Oc1peW {
                _Oc1peW { w: self }
            }
            #[doc = "Bit 2 - Output Compare 1 fast enable"]
            #[inline ( always )]
            pub fn oc1fe(&mut self) -> _Oc1feW {
                _Oc1feW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub struct Ccmr1Input {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare mode register 1 (input mode)"]
    pub mod ccmr1_input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccmr1Input {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1fR {
            bits: u8,
        }
        impl Ic1fR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ic1pscR {
            bits: u8,
        }
        impl Ic1pscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1sR {
            bits: u8,
        }
        impl Cc1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1fW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1fW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ic1pscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ic1pscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&self) -> Ic1fR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1fR { bits }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&self) -> Ic1pscR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Ic1pscR { bits }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&self) -> Cc1sR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1sR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 4:7 - Input capture 1 filter"]
            #[inline ( always )]
            pub fn ic1f(&mut self) -> _Ic1fW {
                _Ic1fW { w: self }
            }
            #[doc = "Bits 2:3 - Input capture 1 prescaler"]
            #[inline ( always )]
            pub fn ic1psc(&mut self) -> _Ic1pscW {
                _Ic1pscW { w: self }
            }
            #[doc = "Bits 0:1 - Capture/Compare 1 selection"]
            #[inline ( always )]
            pub fn cc1s(&mut self) -> _Cc1sW {
                _Cc1sW { w: self }
            }
        }
    }
    #[doc = "capture/compare enable register"]
    pub struct Ccer {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare enable register"]
    pub mod ccer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccer {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1npR {
            bits: u8,
        }
        impl Cc1npR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1neR {
            bits: u8,
        }
        impl Cc1neR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1pR {
            bits: u8,
        }
        impl Cc1pR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Cc1eR {
            bits: u8,
        }
        impl Cc1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1npW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1npW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1neW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1neW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1pW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1pW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _Cc1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _Cc1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&self) -> Cc1npR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1npR { bits }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&self) -> Cc1neR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1neR { bits }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&self) -> Cc1pR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1pR { bits }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&self) -> Cc1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Cc1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1np(&mut self) -> _Cc1npW {
                _Cc1npW { w: self }
            }
            #[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
            #[inline ( always )]
            pub fn cc1ne(&mut self) -> _Cc1neW {
                _Cc1neW { w: self }
            }
            #[doc = "Bit 1 - Capture/Compare 1 output Polarity"]
            #[inline ( always )]
            pub fn cc1p(&mut self) -> _Cc1pW {
                _Cc1pW { w: self }
            }
            #[doc = "Bit 0 - Capture/Compare 1 output enable"]
            #[inline ( always )]
            pub fn cc1e(&mut self) -> _Cc1eW {
                _Cc1eW { w: self }
            }
        }
    }
    #[doc = "counter"]
    pub struct Cnt {
        register: VolatileCell<u32>,
    }
    #[doc = "counter"]
    pub mod cnt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cnt {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CntW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CntW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - counter value"]
            #[inline ( always )]
            pub fn cnt(&mut self) -> _CntW {
                _CntW { w: self }
            }
        }
    }
    #[doc = "prescaler"]
    pub struct Psc {
        register: VolatileCell<u32>,
    }
    #[doc = "prescaler"]
    pub mod psc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Psc {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct PscR {
            bits: u16,
        }
        impl PscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&self) -> PscR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PscR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescaler value"]
            #[inline ( always )]
            pub fn psc(&mut self) -> _PscW {
                _PscW { w: self }
            }
        }
    }
    #[doc = "auto-reload register"]
    pub struct Arr {
        register: VolatileCell<u32>,
    }
    #[doc = "auto-reload register"]
    pub mod arr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Arr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArrR {
            bits: u16,
        }
        impl ArrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&self) -> ArrR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                ArrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Auto-reload value"]
            #[inline ( always )]
            pub fn arr(&mut self) -> _ArrW {
                _ArrW { w: self }
            }
        }
    }
    #[doc = "repetition counter register"]
    pub struct Rcr {
        register: VolatileCell<u32>,
    }
    #[doc = "repetition counter register"]
    pub mod rcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Rcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct RepR {
            bits: u8,
        }
        impl RepR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RepW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RepW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&self) -> RepR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RepR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Repetition counter value"]
            #[inline ( always )]
            pub fn rep(&mut self) -> _RepW {
                _RepW { w: self }
            }
        }
    }
    #[doc = "capture/compare register 1"]
    pub struct Ccr1 {
        register: VolatileCell<u32>,
    }
    #[doc = "capture/compare register 1"]
    pub mod ccr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ccr1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct Ccr1R {
            bits: u16,
        }
        impl Ccr1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _Ccr1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _Ccr1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&self) -> Ccr1R {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                Ccr1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Capture/Compare 1 value"]
            #[inline ( always )]
            pub fn ccr1(&mut self) -> _Ccr1W {
                _Ccr1W { w: self }
            }
        }
    }
    #[doc = "break and dead-time register"]
    pub struct Bdtr {
        register: VolatileCell<u32>,
    }
    #[doc = "break and dead-time register"]
    pub mod bdtr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Bdtr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MoeR {
            bits: u8,
        }
        impl MoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AoeR {
            bits: u8,
        }
        impl AoeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkpR {
            bits: u8,
        }
        impl BkpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BkeR {
            bits: u8,
        }
        impl BkeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssrR {
            bits: u8,
        }
        impl OssrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OssiR {
            bits: u8,
        }
        impl OssiR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DtgR {
            bits: u8,
        }
        impl DtgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AoeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AoeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BkeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BkeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OssiW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OssiW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DtgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DtgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&self) -> MoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MoeR { bits }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&self) -> AoeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AoeR { bits }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&self) -> BkpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkpR { bits }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&self) -> BkeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BkeR { bits }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&self) -> OssrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssrR { bits }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&self) -> OssiR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OssiR { bits }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&self) -> DtgR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DtgR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 15 - Main output enable"]
            #[inline ( always )]
            pub fn moe(&mut self) -> _MoeW {
                _MoeW { w: self }
            }
            #[doc = "Bit 14 - Automatic output enable"]
            #[inline ( always )]
            pub fn aoe(&mut self) -> _AoeW {
                _AoeW { w: self }
            }
            #[doc = "Bit 13 - Break polarity"]
            #[inline ( always )]
            pub fn bkp(&mut self) -> _BkpW {
                _BkpW { w: self }
            }
            #[doc = "Bit 12 - Break enable"]
            #[inline ( always )]
            pub fn bke(&mut self) -> _BkeW {
                _BkeW { w: self }
            }
            #[doc = "Bit 11 - Off-state selection for Run mode"]
            #[inline ( always )]
            pub fn ossr(&mut self) -> _OssrW {
                _OssrW { w: self }
            }
            #[doc = "Bit 10 - Off-state selection for Idle mode"]
            #[inline ( always )]
            pub fn ossi(&mut self) -> _OssiW {
                _OssiW { w: self }
            }
            #[doc = "Bits 8:9 - Lock configuration"]
            #[inline ( always )]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            #[doc = "Bits 0:7 - Dead-time generator setup"]
            #[inline ( always )]
            pub fn dtg(&mut self) -> _DtgW {
                _DtgW { w: self }
            }
        }
    }
    #[doc = "DMA control register"]
    pub struct Dcr {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA control register"]
    pub mod dcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DblR {
            bits: u8,
        }
        impl DblR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbaR {
            bits: u8,
        }
        impl DbaR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DblW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DblW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbaW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbaW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&self) -> DblR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DblR { bits }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&self) -> DbaR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbaR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:12 - DMA burst length"]
            #[inline ( always )]
            pub fn dbl(&mut self) -> _DblW {
                _DblW { w: self }
            }
            #[doc = "Bits 0:4 - DMA base address"]
            #[inline ( always )]
            pub fn dba(&mut self) -> _DbaW {
                _DbaW { w: self }
            }
        }
    }
    #[doc = "DMA address for full transfer"]
    pub struct Dmar {
        register: VolatileCell<u32>,
    }
    #[doc = "DMA address for full transfer"]
    pub mod dmar {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Dmar {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DmabR {
            bits: u16,
        }
        impl DmabR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DmabW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DmabW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&self) -> DmabR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DmabR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - DMA register for burst accesses"]
            #[inline ( always )]
            pub fn dmab(&mut self) -> _DmabW {
                _DmabW { w: self }
            }
        }
    }
}
#[doc = "General-purpose-timers"]
pub struct Tim16 {
    register_block: tim16::RegisterBlock,
}
impl Deref for Tim16 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        &self.register_block
    }
}
#[doc = "TIM17"]
pub const TIM17: Peripheral<Tim17> = unsafe { Peripheral::new(1073825792) };
#[doc = r" Register block"]
pub struct Tim17 {
    register_block: tim16::RegisterBlock,
}
impl Deref for Tim17 {
    type Target = tim16::RegisterBlock;
    fn deref(&self) -> &tim16::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Touch sensing controller"]
pub const TSC: Peripheral<Tsc> = unsafe { Peripheral::new(1073889280) };
#[doc = "Touch sensing controller"]
pub mod tsc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register"]
        pub cr: Cr,
        #[doc = "0x04 - interrupt enable register"]
        pub ier: Ier,
        #[doc = "0x08 - interrupt clear register"]
        pub icr: Icr,
        #[doc = "0x0c - interrupt status register"]
        pub isr: Isr,
        #[doc = "0x10 - I/O hysteresis control register"]
        pub iohcr: Iohcr,
        _reserved0: [u8; 4usize],
        #[doc = "0x18 - I/O analog switch control register"]
        pub ioascr: Ioascr,
        _reserved1: [u8; 4usize],
        #[doc = "0x20 - I/O sampling control register"]
        pub ioscr: Ioscr,
        _reserved2: [u8; 4usize],
        #[doc = "0x28 - I/O channel control register"]
        pub ioccr: Ioccr,
        _reserved3: [u8; 4usize],
        #[doc = "0x30 - I/O group control status register"]
        pub iogcsr: Iogcsr,
        #[doc = "0x34 - I/O group x counter register"]
        pub iog1cr: Iog1cr,
        #[doc = "0x38 - I/O group x counter register"]
        pub iog2cr: Iog2cr,
        #[doc = "0x3c - I/O group x counter register"]
        pub iog3cr: Iog3cr,
        #[doc = "0x40 - I/O group x counter register"]
        pub iog4cr: Iog4cr,
        #[doc = "0x44 - I/O group x counter register"]
        pub iog5cr: Iog5cr,
        #[doc = "0x48 - I/O group x counter register"]
        pub iog6cr: Iog6cr,
    }
    #[doc = "control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtphR {
            bits: u8,
        }
        impl CtphR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CtplR {
            bits: u8,
        }
        impl CtplR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SsdR {
            bits: u8,
        }
        impl SsdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SseR {
            bits: u8,
        }
        impl SseR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SspscR {
            bits: u8,
        }
        impl SspscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PgpscR {
            bits: u8,
        }
        impl PgpscR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct McvR {
            bits: u8,
        }
        impl McvR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct IodefR {
            bits: u8,
        }
        impl IodefR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SyncpolR {
            bits: u8,
        }
        impl SyncpolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AmR {
            bits: u8,
        }
        impl AmR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StartR {
            bits: u8,
        }
        impl StartR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TsceR {
            bits: u8,
        }
        impl TsceR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CtphW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtphW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CtplW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CtplW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SsdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SsdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SseW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SseW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SspscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SspscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PgpscW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PgpscW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _McvW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McvW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IodefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IodefW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SyncpolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SyncpolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AmW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AmW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StartW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StartW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TsceW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TsceW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 28:31 - Charge transfer pulse high"]
            #[inline ( always )]
            pub fn ctph(&self) -> CtphR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtphR { bits }
            }
            #[doc = "Bits 24:27 - Charge transfer pulse low"]
            #[inline ( always )]
            pub fn ctpl(&self) -> CtplR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CtplR { bits }
            }
            #[doc = "Bits 17:23 - Spread spectrum deviation"]
            #[inline ( always )]
            pub fn ssd(&self) -> SsdR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SsdR { bits }
            }
            #[doc = "Bit 16 - Spread spectrum enable"]
            #[inline ( always )]
            pub fn sse(&self) -> SseR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SseR { bits }
            }
            #[doc = "Bit 15 - Spread spectrum prescaler"]
            #[inline ( always )]
            pub fn sspsc(&self) -> SspscR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SspscR { bits }
            }
            #[doc = "Bits 12:14 - pulse generator prescaler"]
            #[inline ( always )]
            pub fn pgpsc(&self) -> PgpscR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PgpscR { bits }
            }
            #[doc = "Bits 5:7 - Max count value"]
            #[inline ( always )]
            pub fn mcv(&self) -> McvR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                McvR { bits }
            }
            #[doc = "Bit 4 - I/O Default mode"]
            #[inline ( always )]
            pub fn iodef(&self) -> IodefR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IodefR { bits }
            }
            #[doc = "Bit 3 - Synchronization pin polarity"]
            #[inline ( always )]
            pub fn syncpol(&self) -> SyncpolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SyncpolR { bits }
            }
            #[doc = "Bit 2 - Acquisition mode"]
            #[inline ( always )]
            pub fn am(&self) -> AmR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AmR { bits }
            }
            #[doc = "Bit 1 - Start a new acquisition"]
            #[inline ( always )]
            pub fn start(&self) -> StartR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StartR { bits }
            }
            #[doc = "Bit 0 - Touch sensing controller enable"]
            #[inline ( always )]
            pub fn tsce(&self) -> TsceR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TsceR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 28:31 - Charge transfer pulse high"]
            #[inline ( always )]
            pub fn ctph(&mut self) -> _CtphW {
                _CtphW { w: self }
            }
            #[doc = "Bits 24:27 - Charge transfer pulse low"]
            #[inline ( always )]
            pub fn ctpl(&mut self) -> _CtplW {
                _CtplW { w: self }
            }
            #[doc = "Bits 17:23 - Spread spectrum deviation"]
            #[inline ( always )]
            pub fn ssd(&mut self) -> _SsdW {
                _SsdW { w: self }
            }
            #[doc = "Bit 16 - Spread spectrum enable"]
            #[inline ( always )]
            pub fn sse(&mut self) -> _SseW {
                _SseW { w: self }
            }
            #[doc = "Bit 15 - Spread spectrum prescaler"]
            #[inline ( always )]
            pub fn sspsc(&mut self) -> _SspscW {
                _SspscW { w: self }
            }
            #[doc = "Bits 12:14 - pulse generator prescaler"]
            #[inline ( always )]
            pub fn pgpsc(&mut self) -> _PgpscW {
                _PgpscW { w: self }
            }
            #[doc = "Bits 5:7 - Max count value"]
            #[inline ( always )]
            pub fn mcv(&mut self) -> _McvW {
                _McvW { w: self }
            }
            #[doc = "Bit 4 - I/O Default mode"]
            #[inline ( always )]
            pub fn iodef(&mut self) -> _IodefW {
                _IodefW { w: self }
            }
            #[doc = "Bit 3 - Synchronization pin polarity"]
            #[inline ( always )]
            pub fn syncpol(&mut self) -> _SyncpolW {
                _SyncpolW { w: self }
            }
            #[doc = "Bit 2 - Acquisition mode"]
            #[inline ( always )]
            pub fn am(&mut self) -> _AmW {
                _AmW { w: self }
            }
            #[doc = "Bit 1 - Start a new acquisition"]
            #[inline ( always )]
            pub fn start(&mut self) -> _StartW {
                _StartW { w: self }
            }
            #[doc = "Bit 0 - Touch sensing controller enable"]
            #[inline ( always )]
            pub fn tsce(&mut self) -> _TsceW {
                _TsceW { w: self }
            }
        }
    }
    #[doc = "interrupt enable register"]
    pub struct Ier {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt enable register"]
    pub mod ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MceieR {
            bits: u8,
        }
        impl MceieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EoaieR {
            bits: u8,
        }
        impl EoaieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MceieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MceieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EoaieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EoaieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Max count error interrupt enable"]
            #[inline ( always )]
            pub fn mceie(&self) -> MceieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MceieR { bits }
            }
            #[doc = "Bit 0 - End of acquisition interrupt enable"]
            #[inline ( always )]
            pub fn eoaie(&self) -> EoaieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EoaieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Max count error interrupt enable"]
            #[inline ( always )]
            pub fn mceie(&mut self) -> _MceieW {
                _MceieW { w: self }
            }
            #[doc = "Bit 0 - End of acquisition interrupt enable"]
            #[inline ( always )]
            pub fn eoaie(&mut self) -> _EoaieW {
                _EoaieW { w: self }
            }
        }
    }
    #[doc = "interrupt clear register"]
    pub struct Icr {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt clear register"]
    pub mod icr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Icr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct MceicR {
            bits: u8,
        }
        impl MceicR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EoaicR {
            bits: u8,
        }
        impl EoaicR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MceicW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MceicW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EoaicW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EoaicW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Max count error interrupt clear"]
            #[inline ( always )]
            pub fn mceic(&self) -> MceicR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MceicR { bits }
            }
            #[doc = "Bit 0 - End of acquisition interrupt clear"]
            #[inline ( always )]
            pub fn eoaic(&self) -> EoaicR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EoaicR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Max count error interrupt clear"]
            #[inline ( always )]
            pub fn mceic(&mut self) -> _MceicW {
                _MceicW { w: self }
            }
            #[doc = "Bit 0 - End of acquisition interrupt clear"]
            #[inline ( always )]
            pub fn eoaic(&mut self) -> _EoaicW {
                _EoaicW { w: self }
            }
        }
    }
    #[doc = "interrupt status register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt status register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct McefR {
            bits: u8,
        }
        impl McefR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EoafR {
            bits: u8,
        }
        impl EoafR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _McefW<'a> {
            w: &'a mut W,
        }
        impl<'a> _McefW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EoafW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EoafW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Max count error flag"]
            #[inline ( always )]
            pub fn mcef(&self) -> McefR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                McefR { bits }
            }
            #[doc = "Bit 0 - End of acquisition flag"]
            #[inline ( always )]
            pub fn eoaf(&self) -> EoafR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EoafR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Max count error flag"]
            #[inline ( always )]
            pub fn mcef(&mut self) -> _McefW {
                _McefW { w: self }
            }
            #[doc = "Bit 0 - End of acquisition flag"]
            #[inline ( always )]
            pub fn eoaf(&mut self) -> _EoafW {
                _EoafW { w: self }
            }
        }
    }
    #[doc = "I/O hysteresis control register"]
    pub struct Iohcr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O hysteresis control register"]
    pub mod iohcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Iohcr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io4R {
            bits: u8,
        }
        impl G6Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io3R {
            bits: u8,
        }
        impl G6Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io2R {
            bits: u8,
        }
        impl G6Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io1R {
            bits: u8,
        }
        impl G6Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io4R {
            bits: u8,
        }
        impl G5Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io3R {
            bits: u8,
        }
        impl G5Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io2R {
            bits: u8,
        }
        impl G5Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io1R {
            bits: u8,
        }
        impl G5Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io4R {
            bits: u8,
        }
        impl G4Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io3R {
            bits: u8,
        }
        impl G4Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io2R {
            bits: u8,
        }
        impl G4Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io1R {
            bits: u8,
        }
        impl G4Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io4R {
            bits: u8,
        }
        impl G3Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io3R {
            bits: u8,
        }
        impl G3Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io2R {
            bits: u8,
        }
        impl G3Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io1R {
            bits: u8,
        }
        impl G3Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io4R {
            bits: u8,
        }
        impl G2Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io3R {
            bits: u8,
        }
        impl G2Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io2R {
            bits: u8,
        }
        impl G2Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io1R {
            bits: u8,
        }
        impl G2Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io4R {
            bits: u8,
        }
        impl G1Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io3R {
            bits: u8,
        }
        impl G1Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io2R {
            bits: u8,
        }
        impl G1Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io1R {
            bits: u8,
        }
        impl G1Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - G6_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io4(&self) -> G6Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io4R { bits }
            }
            #[doc = "Bit 22 - G6_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io3(&self) -> G6Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io3R { bits }
            }
            #[doc = "Bit 21 - G6_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io2(&self) -> G6Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io2R { bits }
            }
            #[doc = "Bit 20 - G6_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io1(&self) -> G6Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io1R { bits }
            }
            #[doc = "Bit 19 - G5_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io4(&self) -> G5Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io4R { bits }
            }
            #[doc = "Bit 18 - G5_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io3(&self) -> G5Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io3R { bits }
            }
            #[doc = "Bit 17 - G5_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io2(&self) -> G5Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io2R { bits }
            }
            #[doc = "Bit 16 - G5_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io1(&self) -> G5Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io1R { bits }
            }
            #[doc = "Bit 15 - G4_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io4(&self) -> G4Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io4R { bits }
            }
            #[doc = "Bit 14 - G4_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io3(&self) -> G4Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io3R { bits }
            }
            #[doc = "Bit 13 - G4_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io2(&self) -> G4Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io2R { bits }
            }
            #[doc = "Bit 12 - G4_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io1(&self) -> G4Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io1R { bits }
            }
            #[doc = "Bit 11 - G3_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io4(&self) -> G3Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io4R { bits }
            }
            #[doc = "Bit 10 - G3_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io3(&self) -> G3Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io3R { bits }
            }
            #[doc = "Bit 9 - G3_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io2(&self) -> G3Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io2R { bits }
            }
            #[doc = "Bit 8 - G3_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io1(&self) -> G3Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io1R { bits }
            }
            #[doc = "Bit 7 - G2_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io4(&self) -> G2Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io4R { bits }
            }
            #[doc = "Bit 6 - G2_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io3(&self) -> G2Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io3R { bits }
            }
            #[doc = "Bit 5 - G2_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io2(&self) -> G2Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io2R { bits }
            }
            #[doc = "Bit 4 - G2_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io1(&self) -> G2Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io1R { bits }
            }
            #[doc = "Bit 3 - G1_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io4(&self) -> G1Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io4R { bits }
            }
            #[doc = "Bit 2 - G1_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io3(&self) -> G1Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io3R { bits }
            }
            #[doc = "Bit 1 - G1_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io2(&self) -> G1Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io2R { bits }
            }
            #[doc = "Bit 0 - G1_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io1(&self) -> G1Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - G6_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io4(&mut self) -> _G6Io4W {
                _G6Io4W { w: self }
            }
            #[doc = "Bit 22 - G6_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io3(&mut self) -> _G6Io3W {
                _G6Io3W { w: self }
            }
            #[doc = "Bit 21 - G6_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io2(&mut self) -> _G6Io2W {
                _G6Io2W { w: self }
            }
            #[doc = "Bit 20 - G6_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g6_io1(&mut self) -> _G6Io1W {
                _G6Io1W { w: self }
            }
            #[doc = "Bit 19 - G5_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io4(&mut self) -> _G5Io4W {
                _G5Io4W { w: self }
            }
            #[doc = "Bit 18 - G5_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io3(&mut self) -> _G5Io3W {
                _G5Io3W { w: self }
            }
            #[doc = "Bit 17 - G5_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io2(&mut self) -> _G5Io2W {
                _G5Io2W { w: self }
            }
            #[doc = "Bit 16 - G5_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g5_io1(&mut self) -> _G5Io1W {
                _G5Io1W { w: self }
            }
            #[doc = "Bit 15 - G4_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io4(&mut self) -> _G4Io4W {
                _G4Io4W { w: self }
            }
            #[doc = "Bit 14 - G4_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io3(&mut self) -> _G4Io3W {
                _G4Io3W { w: self }
            }
            #[doc = "Bit 13 - G4_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io2(&mut self) -> _G4Io2W {
                _G4Io2W { w: self }
            }
            #[doc = "Bit 12 - G4_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g4_io1(&mut self) -> _G4Io1W {
                _G4Io1W { w: self }
            }
            #[doc = "Bit 11 - G3_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io4(&mut self) -> _G3Io4W {
                _G3Io4W { w: self }
            }
            #[doc = "Bit 10 - G3_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io3(&mut self) -> _G3Io3W {
                _G3Io3W { w: self }
            }
            #[doc = "Bit 9 - G3_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io2(&mut self) -> _G3Io2W {
                _G3Io2W { w: self }
            }
            #[doc = "Bit 8 - G3_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g3_io1(&mut self) -> _G3Io1W {
                _G3Io1W { w: self }
            }
            #[doc = "Bit 7 - G2_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io4(&mut self) -> _G2Io4W {
                _G2Io4W { w: self }
            }
            #[doc = "Bit 6 - G2_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io3(&mut self) -> _G2Io3W {
                _G2Io3W { w: self }
            }
            #[doc = "Bit 5 - G2_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io2(&mut self) -> _G2Io2W {
                _G2Io2W { w: self }
            }
            #[doc = "Bit 4 - G2_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g2_io1(&mut self) -> _G2Io1W {
                _G2Io1W { w: self }
            }
            #[doc = "Bit 3 - G1_IO4 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io4(&mut self) -> _G1Io4W {
                _G1Io4W { w: self }
            }
            #[doc = "Bit 2 - G1_IO3 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io3(&mut self) -> _G1Io3W {
                _G1Io3W { w: self }
            }
            #[doc = "Bit 1 - G1_IO2 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io2(&mut self) -> _G1Io2W {
                _G1Io2W { w: self }
            }
            #[doc = "Bit 0 - G1_IO1 Schmitt trigger hysteresis mode"]
            #[inline ( always )]
            pub fn g1_io1(&mut self) -> _G1Io1W {
                _G1Io1W { w: self }
            }
        }
    }
    #[doc = "I/O analog switch control register"]
    pub struct Ioascr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O analog switch control register"]
    pub mod ioascr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ioascr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io4R {
            bits: u8,
        }
        impl G6Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io3R {
            bits: u8,
        }
        impl G6Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io2R {
            bits: u8,
        }
        impl G6Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io1R {
            bits: u8,
        }
        impl G6Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io4R {
            bits: u8,
        }
        impl G5Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io3R {
            bits: u8,
        }
        impl G5Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io2R {
            bits: u8,
        }
        impl G5Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io1R {
            bits: u8,
        }
        impl G5Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io4R {
            bits: u8,
        }
        impl G4Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io3R {
            bits: u8,
        }
        impl G4Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io2R {
            bits: u8,
        }
        impl G4Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io1R {
            bits: u8,
        }
        impl G4Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io4R {
            bits: u8,
        }
        impl G3Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io3R {
            bits: u8,
        }
        impl G3Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io2R {
            bits: u8,
        }
        impl G3Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io1R {
            bits: u8,
        }
        impl G3Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io4R {
            bits: u8,
        }
        impl G2Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io3R {
            bits: u8,
        }
        impl G2Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io2R {
            bits: u8,
        }
        impl G2Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io1R {
            bits: u8,
        }
        impl G2Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io4R {
            bits: u8,
        }
        impl G1Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io3R {
            bits: u8,
        }
        impl G1Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io2R {
            bits: u8,
        }
        impl G1Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io1R {
            bits: u8,
        }
        impl G1Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - G6_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io4(&self) -> G6Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io4R { bits }
            }
            #[doc = "Bit 22 - G6_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io3(&self) -> G6Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io3R { bits }
            }
            #[doc = "Bit 21 - G6_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io2(&self) -> G6Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io2R { bits }
            }
            #[doc = "Bit 20 - G6_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io1(&self) -> G6Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io1R { bits }
            }
            #[doc = "Bit 19 - G5_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io4(&self) -> G5Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io4R { bits }
            }
            #[doc = "Bit 18 - G5_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io3(&self) -> G5Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io3R { bits }
            }
            #[doc = "Bit 17 - G5_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io2(&self) -> G5Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io2R { bits }
            }
            #[doc = "Bit 16 - G5_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io1(&self) -> G5Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io1R { bits }
            }
            #[doc = "Bit 15 - G4_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io4(&self) -> G4Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io4R { bits }
            }
            #[doc = "Bit 14 - G4_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io3(&self) -> G4Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io3R { bits }
            }
            #[doc = "Bit 13 - G4_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io2(&self) -> G4Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io2R { bits }
            }
            #[doc = "Bit 12 - G4_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io1(&self) -> G4Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io1R { bits }
            }
            #[doc = "Bit 11 - G3_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io4(&self) -> G3Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io4R { bits }
            }
            #[doc = "Bit 10 - G3_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io3(&self) -> G3Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io3R { bits }
            }
            #[doc = "Bit 9 - G3_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io2(&self) -> G3Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io2R { bits }
            }
            #[doc = "Bit 8 - G3_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io1(&self) -> G3Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io1R { bits }
            }
            #[doc = "Bit 7 - G2_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io4(&self) -> G2Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io4R { bits }
            }
            #[doc = "Bit 6 - G2_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io3(&self) -> G2Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io3R { bits }
            }
            #[doc = "Bit 5 - G2_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io2(&self) -> G2Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io2R { bits }
            }
            #[doc = "Bit 4 - G2_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io1(&self) -> G2Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io1R { bits }
            }
            #[doc = "Bit 3 - G1_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io4(&self) -> G1Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io4R { bits }
            }
            #[doc = "Bit 2 - G1_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io3(&self) -> G1Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io3R { bits }
            }
            #[doc = "Bit 1 - G1_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io2(&self) -> G1Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io2R { bits }
            }
            #[doc = "Bit 0 - G1_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io1(&self) -> G1Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - G6_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io4(&mut self) -> _G6Io4W {
                _G6Io4W { w: self }
            }
            #[doc = "Bit 22 - G6_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io3(&mut self) -> _G6Io3W {
                _G6Io3W { w: self }
            }
            #[doc = "Bit 21 - G6_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io2(&mut self) -> _G6Io2W {
                _G6Io2W { w: self }
            }
            #[doc = "Bit 20 - G6_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g6_io1(&mut self) -> _G6Io1W {
                _G6Io1W { w: self }
            }
            #[doc = "Bit 19 - G5_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io4(&mut self) -> _G5Io4W {
                _G5Io4W { w: self }
            }
            #[doc = "Bit 18 - G5_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io3(&mut self) -> _G5Io3W {
                _G5Io3W { w: self }
            }
            #[doc = "Bit 17 - G5_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io2(&mut self) -> _G5Io2W {
                _G5Io2W { w: self }
            }
            #[doc = "Bit 16 - G5_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g5_io1(&mut self) -> _G5Io1W {
                _G5Io1W { w: self }
            }
            #[doc = "Bit 15 - G4_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io4(&mut self) -> _G4Io4W {
                _G4Io4W { w: self }
            }
            #[doc = "Bit 14 - G4_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io3(&mut self) -> _G4Io3W {
                _G4Io3W { w: self }
            }
            #[doc = "Bit 13 - G4_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io2(&mut self) -> _G4Io2W {
                _G4Io2W { w: self }
            }
            #[doc = "Bit 12 - G4_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g4_io1(&mut self) -> _G4Io1W {
                _G4Io1W { w: self }
            }
            #[doc = "Bit 11 - G3_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io4(&mut self) -> _G3Io4W {
                _G3Io4W { w: self }
            }
            #[doc = "Bit 10 - G3_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io3(&mut self) -> _G3Io3W {
                _G3Io3W { w: self }
            }
            #[doc = "Bit 9 - G3_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io2(&mut self) -> _G3Io2W {
                _G3Io2W { w: self }
            }
            #[doc = "Bit 8 - G3_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g3_io1(&mut self) -> _G3Io1W {
                _G3Io1W { w: self }
            }
            #[doc = "Bit 7 - G2_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io4(&mut self) -> _G2Io4W {
                _G2Io4W { w: self }
            }
            #[doc = "Bit 6 - G2_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io3(&mut self) -> _G2Io3W {
                _G2Io3W { w: self }
            }
            #[doc = "Bit 5 - G2_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io2(&mut self) -> _G2Io2W {
                _G2Io2W { w: self }
            }
            #[doc = "Bit 4 - G2_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g2_io1(&mut self) -> _G2Io1W {
                _G2Io1W { w: self }
            }
            #[doc = "Bit 3 - G1_IO4 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io4(&mut self) -> _G1Io4W {
                _G1Io4W { w: self }
            }
            #[doc = "Bit 2 - G1_IO3 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io3(&mut self) -> _G1Io3W {
                _G1Io3W { w: self }
            }
            #[doc = "Bit 1 - G1_IO2 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io2(&mut self) -> _G1Io2W {
                _G1Io2W { w: self }
            }
            #[doc = "Bit 0 - G1_IO1 analog switch enable"]
            #[inline ( always )]
            pub fn g1_io1(&mut self) -> _G1Io1W {
                _G1Io1W { w: self }
            }
        }
    }
    #[doc = "I/O sampling control register"]
    pub struct Ioscr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O sampling control register"]
    pub mod ioscr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ioscr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io4R {
            bits: u8,
        }
        impl G6Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io3R {
            bits: u8,
        }
        impl G6Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io2R {
            bits: u8,
        }
        impl G6Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io1R {
            bits: u8,
        }
        impl G6Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io4R {
            bits: u8,
        }
        impl G5Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io3R {
            bits: u8,
        }
        impl G5Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io2R {
            bits: u8,
        }
        impl G5Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io1R {
            bits: u8,
        }
        impl G5Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io4R {
            bits: u8,
        }
        impl G4Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io3R {
            bits: u8,
        }
        impl G4Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io2R {
            bits: u8,
        }
        impl G4Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io1R {
            bits: u8,
        }
        impl G4Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io4R {
            bits: u8,
        }
        impl G3Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io3R {
            bits: u8,
        }
        impl G3Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io2R {
            bits: u8,
        }
        impl G3Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io1R {
            bits: u8,
        }
        impl G3Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io4R {
            bits: u8,
        }
        impl G2Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io3R {
            bits: u8,
        }
        impl G2Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io2R {
            bits: u8,
        }
        impl G2Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io1R {
            bits: u8,
        }
        impl G2Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io4R {
            bits: u8,
        }
        impl G1Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io3R {
            bits: u8,
        }
        impl G1Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io2R {
            bits: u8,
        }
        impl G1Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io1R {
            bits: u8,
        }
        impl G1Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - G6_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g6_io4(&self) -> G6Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io4R { bits }
            }
            #[doc = "Bit 22 - G6_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g6_io3(&self) -> G6Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io3R { bits }
            }
            #[doc = "Bit 21 - G6_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g6_io2(&self) -> G6Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io2R { bits }
            }
            #[doc = "Bit 20 - G6_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g6_io1(&self) -> G6Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io1R { bits }
            }
            #[doc = "Bit 19 - G5_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g5_io4(&self) -> G5Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io4R { bits }
            }
            #[doc = "Bit 18 - G5_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g5_io3(&self) -> G5Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io3R { bits }
            }
            #[doc = "Bit 17 - G5_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g5_io2(&self) -> G5Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io2R { bits }
            }
            #[doc = "Bit 16 - G5_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g5_io1(&self) -> G5Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io1R { bits }
            }
            #[doc = "Bit 15 - G4_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g4_io4(&self) -> G4Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io4R { bits }
            }
            #[doc = "Bit 14 - G4_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g4_io3(&self) -> G4Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io3R { bits }
            }
            #[doc = "Bit 13 - G4_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g4_io2(&self) -> G4Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io2R { bits }
            }
            #[doc = "Bit 12 - G4_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g4_io1(&self) -> G4Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io1R { bits }
            }
            #[doc = "Bit 11 - G3_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g3_io4(&self) -> G3Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io4R { bits }
            }
            #[doc = "Bit 10 - G3_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g3_io3(&self) -> G3Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io3R { bits }
            }
            #[doc = "Bit 9 - G3_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g3_io2(&self) -> G3Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io2R { bits }
            }
            #[doc = "Bit 8 - G3_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g3_io1(&self) -> G3Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io1R { bits }
            }
            #[doc = "Bit 7 - G2_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g2_io4(&self) -> G2Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io4R { bits }
            }
            #[doc = "Bit 6 - G2_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g2_io3(&self) -> G2Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io3R { bits }
            }
            #[doc = "Bit 5 - G2_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g2_io2(&self) -> G2Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io2R { bits }
            }
            #[doc = "Bit 4 - G2_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g2_io1(&self) -> G2Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io1R { bits }
            }
            #[doc = "Bit 3 - G1_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g1_io4(&self) -> G1Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io4R { bits }
            }
            #[doc = "Bit 2 - G1_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g1_io3(&self) -> G1Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io3R { bits }
            }
            #[doc = "Bit 1 - G1_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g1_io2(&self) -> G1Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io2R { bits }
            }
            #[doc = "Bit 0 - G1_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g1_io1(&self) -> G1Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - G6_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g6_io4(&mut self) -> _G6Io4W {
                _G6Io4W { w: self }
            }
            #[doc = "Bit 22 - G6_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g6_io3(&mut self) -> _G6Io3W {
                _G6Io3W { w: self }
            }
            #[doc = "Bit 21 - G6_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g6_io2(&mut self) -> _G6Io2W {
                _G6Io2W { w: self }
            }
            #[doc = "Bit 20 - G6_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g6_io1(&mut self) -> _G6Io1W {
                _G6Io1W { w: self }
            }
            #[doc = "Bit 19 - G5_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g5_io4(&mut self) -> _G5Io4W {
                _G5Io4W { w: self }
            }
            #[doc = "Bit 18 - G5_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g5_io3(&mut self) -> _G5Io3W {
                _G5Io3W { w: self }
            }
            #[doc = "Bit 17 - G5_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g5_io2(&mut self) -> _G5Io2W {
                _G5Io2W { w: self }
            }
            #[doc = "Bit 16 - G5_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g5_io1(&mut self) -> _G5Io1W {
                _G5Io1W { w: self }
            }
            #[doc = "Bit 15 - G4_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g4_io4(&mut self) -> _G4Io4W {
                _G4Io4W { w: self }
            }
            #[doc = "Bit 14 - G4_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g4_io3(&mut self) -> _G4Io3W {
                _G4Io3W { w: self }
            }
            #[doc = "Bit 13 - G4_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g4_io2(&mut self) -> _G4Io2W {
                _G4Io2W { w: self }
            }
            #[doc = "Bit 12 - G4_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g4_io1(&mut self) -> _G4Io1W {
                _G4Io1W { w: self }
            }
            #[doc = "Bit 11 - G3_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g3_io4(&mut self) -> _G3Io4W {
                _G3Io4W { w: self }
            }
            #[doc = "Bit 10 - G3_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g3_io3(&mut self) -> _G3Io3W {
                _G3Io3W { w: self }
            }
            #[doc = "Bit 9 - G3_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g3_io2(&mut self) -> _G3Io2W {
                _G3Io2W { w: self }
            }
            #[doc = "Bit 8 - G3_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g3_io1(&mut self) -> _G3Io1W {
                _G3Io1W { w: self }
            }
            #[doc = "Bit 7 - G2_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g2_io4(&mut self) -> _G2Io4W {
                _G2Io4W { w: self }
            }
            #[doc = "Bit 6 - G2_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g2_io3(&mut self) -> _G2Io3W {
                _G2Io3W { w: self }
            }
            #[doc = "Bit 5 - G2_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g2_io2(&mut self) -> _G2Io2W {
                _G2Io2W { w: self }
            }
            #[doc = "Bit 4 - G2_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g2_io1(&mut self) -> _G2Io1W {
                _G2Io1W { w: self }
            }
            #[doc = "Bit 3 - G1_IO4 sampling mode"]
            #[inline ( always )]
            pub fn g1_io4(&mut self) -> _G1Io4W {
                _G1Io4W { w: self }
            }
            #[doc = "Bit 2 - G1_IO3 sampling mode"]
            #[inline ( always )]
            pub fn g1_io3(&mut self) -> _G1Io3W {
                _G1Io3W { w: self }
            }
            #[doc = "Bit 1 - G1_IO2 sampling mode"]
            #[inline ( always )]
            pub fn g1_io2(&mut self) -> _G1Io2W {
                _G1Io2W { w: self }
            }
            #[doc = "Bit 0 - G1_IO1 sampling mode"]
            #[inline ( always )]
            pub fn g1_io1(&mut self) -> _G1Io1W {
                _G1Io1W { w: self }
            }
        }
    }
    #[doc = "I/O channel control register"]
    pub struct Ioccr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O channel control register"]
    pub mod ioccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ioccr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io4R {
            bits: u8,
        }
        impl G6Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io3R {
            bits: u8,
        }
        impl G6Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io2R {
            bits: u8,
        }
        impl G6Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6Io1R {
            bits: u8,
        }
        impl G6Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io4R {
            bits: u8,
        }
        impl G5Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io3R {
            bits: u8,
        }
        impl G5Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io2R {
            bits: u8,
        }
        impl G5Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5Io1R {
            bits: u8,
        }
        impl G5Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io4R {
            bits: u8,
        }
        impl G4Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io3R {
            bits: u8,
        }
        impl G4Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io2R {
            bits: u8,
        }
        impl G4Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4Io1R {
            bits: u8,
        }
        impl G4Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io4R {
            bits: u8,
        }
        impl G3Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io3R {
            bits: u8,
        }
        impl G3Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io2R {
            bits: u8,
        }
        impl G3Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3Io1R {
            bits: u8,
        }
        impl G3Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io4R {
            bits: u8,
        }
        impl G2Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io3R {
            bits: u8,
        }
        impl G2Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io2R {
            bits: u8,
        }
        impl G2Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2Io1R {
            bits: u8,
        }
        impl G2Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io4R {
            bits: u8,
        }
        impl G1Io4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io3R {
            bits: u8,
        }
        impl G1Io3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io2R {
            bits: u8,
        }
        impl G1Io2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1Io1R {
            bits: u8,
        }
        impl G1Io1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1Io1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1Io1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - G6_IO4 channel mode"]
            #[inline ( always )]
            pub fn g6_io4(&self) -> G6Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io4R { bits }
            }
            #[doc = "Bit 22 - G6_IO3 channel mode"]
            #[inline ( always )]
            pub fn g6_io3(&self) -> G6Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io3R { bits }
            }
            #[doc = "Bit 21 - G6_IO2 channel mode"]
            #[inline ( always )]
            pub fn g6_io2(&self) -> G6Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io2R { bits }
            }
            #[doc = "Bit 20 - G6_IO1 channel mode"]
            #[inline ( always )]
            pub fn g6_io1(&self) -> G6Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6Io1R { bits }
            }
            #[doc = "Bit 19 - G5_IO4 channel mode"]
            #[inline ( always )]
            pub fn g5_io4(&self) -> G5Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io4R { bits }
            }
            #[doc = "Bit 18 - G5_IO3 channel mode"]
            #[inline ( always )]
            pub fn g5_io3(&self) -> G5Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io3R { bits }
            }
            #[doc = "Bit 17 - G5_IO2 channel mode"]
            #[inline ( always )]
            pub fn g5_io2(&self) -> G5Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io2R { bits }
            }
            #[doc = "Bit 16 - G5_IO1 channel mode"]
            #[inline ( always )]
            pub fn g5_io1(&self) -> G5Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5Io1R { bits }
            }
            #[doc = "Bit 15 - G4_IO4 channel mode"]
            #[inline ( always )]
            pub fn g4_io4(&self) -> G4Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io4R { bits }
            }
            #[doc = "Bit 14 - G4_IO3 channel mode"]
            #[inline ( always )]
            pub fn g4_io3(&self) -> G4Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io3R { bits }
            }
            #[doc = "Bit 13 - G4_IO2 channel mode"]
            #[inline ( always )]
            pub fn g4_io2(&self) -> G4Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io2R { bits }
            }
            #[doc = "Bit 12 - G4_IO1 channel mode"]
            #[inline ( always )]
            pub fn g4_io1(&self) -> G4Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4Io1R { bits }
            }
            #[doc = "Bit 11 - G3_IO4 channel mode"]
            #[inline ( always )]
            pub fn g3_io4(&self) -> G3Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io4R { bits }
            }
            #[doc = "Bit 10 - G3_IO3 channel mode"]
            #[inline ( always )]
            pub fn g3_io3(&self) -> G3Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io3R { bits }
            }
            #[doc = "Bit 9 - G3_IO2 channel mode"]
            #[inline ( always )]
            pub fn g3_io2(&self) -> G3Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io2R { bits }
            }
            #[doc = "Bit 8 - G3_IO1 channel mode"]
            #[inline ( always )]
            pub fn g3_io1(&self) -> G3Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3Io1R { bits }
            }
            #[doc = "Bit 7 - G2_IO4 channel mode"]
            #[inline ( always )]
            pub fn g2_io4(&self) -> G2Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io4R { bits }
            }
            #[doc = "Bit 6 - G2_IO3 channel mode"]
            #[inline ( always )]
            pub fn g2_io3(&self) -> G2Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io3R { bits }
            }
            #[doc = "Bit 5 - G2_IO2 channel mode"]
            #[inline ( always )]
            pub fn g2_io2(&self) -> G2Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io2R { bits }
            }
            #[doc = "Bit 4 - G2_IO1 channel mode"]
            #[inline ( always )]
            pub fn g2_io1(&self) -> G2Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2Io1R { bits }
            }
            #[doc = "Bit 3 - G1_IO4 channel mode"]
            #[inline ( always )]
            pub fn g1_io4(&self) -> G1Io4R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io4R { bits }
            }
            #[doc = "Bit 2 - G1_IO3 channel mode"]
            #[inline ( always )]
            pub fn g1_io3(&self) -> G1Io3R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io3R { bits }
            }
            #[doc = "Bit 1 - G1_IO2 channel mode"]
            #[inline ( always )]
            pub fn g1_io2(&self) -> G1Io2R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io2R { bits }
            }
            #[doc = "Bit 0 - G1_IO1 channel mode"]
            #[inline ( always )]
            pub fn g1_io1(&self) -> G1Io1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1Io1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - G6_IO4 channel mode"]
            #[inline ( always )]
            pub fn g6_io4(&mut self) -> _G6Io4W {
                _G6Io4W { w: self }
            }
            #[doc = "Bit 22 - G6_IO3 channel mode"]
            #[inline ( always )]
            pub fn g6_io3(&mut self) -> _G6Io3W {
                _G6Io3W { w: self }
            }
            #[doc = "Bit 21 - G6_IO2 channel mode"]
            #[inline ( always )]
            pub fn g6_io2(&mut self) -> _G6Io2W {
                _G6Io2W { w: self }
            }
            #[doc = "Bit 20 - G6_IO1 channel mode"]
            #[inline ( always )]
            pub fn g6_io1(&mut self) -> _G6Io1W {
                _G6Io1W { w: self }
            }
            #[doc = "Bit 19 - G5_IO4 channel mode"]
            #[inline ( always )]
            pub fn g5_io4(&mut self) -> _G5Io4W {
                _G5Io4W { w: self }
            }
            #[doc = "Bit 18 - G5_IO3 channel mode"]
            #[inline ( always )]
            pub fn g5_io3(&mut self) -> _G5Io3W {
                _G5Io3W { w: self }
            }
            #[doc = "Bit 17 - G5_IO2 channel mode"]
            #[inline ( always )]
            pub fn g5_io2(&mut self) -> _G5Io2W {
                _G5Io2W { w: self }
            }
            #[doc = "Bit 16 - G5_IO1 channel mode"]
            #[inline ( always )]
            pub fn g5_io1(&mut self) -> _G5Io1W {
                _G5Io1W { w: self }
            }
            #[doc = "Bit 15 - G4_IO4 channel mode"]
            #[inline ( always )]
            pub fn g4_io4(&mut self) -> _G4Io4W {
                _G4Io4W { w: self }
            }
            #[doc = "Bit 14 - G4_IO3 channel mode"]
            #[inline ( always )]
            pub fn g4_io3(&mut self) -> _G4Io3W {
                _G4Io3W { w: self }
            }
            #[doc = "Bit 13 - G4_IO2 channel mode"]
            #[inline ( always )]
            pub fn g4_io2(&mut self) -> _G4Io2W {
                _G4Io2W { w: self }
            }
            #[doc = "Bit 12 - G4_IO1 channel mode"]
            #[inline ( always )]
            pub fn g4_io1(&mut self) -> _G4Io1W {
                _G4Io1W { w: self }
            }
            #[doc = "Bit 11 - G3_IO4 channel mode"]
            #[inline ( always )]
            pub fn g3_io4(&mut self) -> _G3Io4W {
                _G3Io4W { w: self }
            }
            #[doc = "Bit 10 - G3_IO3 channel mode"]
            #[inline ( always )]
            pub fn g3_io3(&mut self) -> _G3Io3W {
                _G3Io3W { w: self }
            }
            #[doc = "Bit 9 - G3_IO2 channel mode"]
            #[inline ( always )]
            pub fn g3_io2(&mut self) -> _G3Io2W {
                _G3Io2W { w: self }
            }
            #[doc = "Bit 8 - G3_IO1 channel mode"]
            #[inline ( always )]
            pub fn g3_io1(&mut self) -> _G3Io1W {
                _G3Io1W { w: self }
            }
            #[doc = "Bit 7 - G2_IO4 channel mode"]
            #[inline ( always )]
            pub fn g2_io4(&mut self) -> _G2Io4W {
                _G2Io4W { w: self }
            }
            #[doc = "Bit 6 - G2_IO3 channel mode"]
            #[inline ( always )]
            pub fn g2_io3(&mut self) -> _G2Io3W {
                _G2Io3W { w: self }
            }
            #[doc = "Bit 5 - G2_IO2 channel mode"]
            #[inline ( always )]
            pub fn g2_io2(&mut self) -> _G2Io2W {
                _G2Io2W { w: self }
            }
            #[doc = "Bit 4 - G2_IO1 channel mode"]
            #[inline ( always )]
            pub fn g2_io1(&mut self) -> _G2Io1W {
                _G2Io1W { w: self }
            }
            #[doc = "Bit 3 - G1_IO4 channel mode"]
            #[inline ( always )]
            pub fn g1_io4(&mut self) -> _G1Io4W {
                _G1Io4W { w: self }
            }
            #[doc = "Bit 2 - G1_IO3 channel mode"]
            #[inline ( always )]
            pub fn g1_io3(&mut self) -> _G1Io3W {
                _G1Io3W { w: self }
            }
            #[doc = "Bit 1 - G1_IO2 channel mode"]
            #[inline ( always )]
            pub fn g1_io2(&mut self) -> _G1Io2W {
                _G1Io2W { w: self }
            }
            #[doc = "Bit 0 - G1_IO1 channel mode"]
            #[inline ( always )]
            pub fn g1_io1(&mut self) -> _G1Io1W {
                _G1Io1W { w: self }
            }
        }
    }
    #[doc = "I/O group control status register"]
    pub struct Iogcsr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group control status register"]
    pub mod iogcsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Iogcsr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct G8sR {
            bits: u8,
        }
        impl G8sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G7sR {
            bits: u8,
        }
        impl G7sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6sR {
            bits: u8,
        }
        impl G6sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5sR {
            bits: u8,
        }
        impl G5sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4sR {
            bits: u8,
        }
        impl G4sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3sR {
            bits: u8,
        }
        impl G3sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2sR {
            bits: u8,
        }
        impl G2sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1sR {
            bits: u8,
        }
        impl G1sR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G8eR {
            bits: u8,
        }
        impl G8eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G7eR {
            bits: u8,
        }
        impl G7eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G6eR {
            bits: u8,
        }
        impl G6eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G5eR {
            bits: u8,
        }
        impl G5eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G4eR {
            bits: u8,
        }
        impl G4eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G3eR {
            bits: u8,
        }
        impl G3eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G2eR {
            bits: u8,
        }
        impl G2eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct G1eR {
            bits: u8,
        }
        impl G1eR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _G8sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G8sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G7sW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G7sW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G8eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G8eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G7eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G7eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G6eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G6eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G5eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G5eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G4eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G4eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G3eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G3eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G2eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G2eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _G1eW<'a> {
            w: &'a mut W,
        }
        impl<'a> _G1eW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 23 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g8s(&self) -> G8sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G8sR { bits }
            }
            #[doc = "Bit 22 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g7s(&self) -> G7sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G7sR { bits }
            }
            #[doc = "Bit 21 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g6s(&self) -> G6sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6sR { bits }
            }
            #[doc = "Bit 20 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g5s(&self) -> G5sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5sR { bits }
            }
            #[doc = "Bit 19 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g4s(&self) -> G4sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4sR { bits }
            }
            #[doc = "Bit 18 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g3s(&self) -> G3sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3sR { bits }
            }
            #[doc = "Bit 17 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g2s(&self) -> G2sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2sR { bits }
            }
            #[doc = "Bit 16 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g1s(&self) -> G1sR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1sR { bits }
            }
            #[doc = "Bit 7 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g8e(&self) -> G8eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G8eR { bits }
            }
            #[doc = "Bit 6 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g7e(&self) -> G7eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G7eR { bits }
            }
            #[doc = "Bit 5 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g6e(&self) -> G6eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G6eR { bits }
            }
            #[doc = "Bit 4 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g5e(&self) -> G5eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G5eR { bits }
            }
            #[doc = "Bit 3 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g4e(&self) -> G4eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G4eR { bits }
            }
            #[doc = "Bit 2 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g3e(&self) -> G3eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G3eR { bits }
            }
            #[doc = "Bit 1 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g2e(&self) -> G2eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G2eR { bits }
            }
            #[doc = "Bit 0 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g1e(&self) -> G1eR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                G1eR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 23 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g8s(&mut self) -> _G8sW {
                _G8sW { w: self }
            }
            #[doc = "Bit 22 - Analog I/O group x status"]
            #[inline ( always )]
            pub fn g7s(&mut self) -> _G7sW {
                _G7sW { w: self }
            }
            #[doc = "Bit 7 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g8e(&mut self) -> _G8eW {
                _G8eW { w: self }
            }
            #[doc = "Bit 6 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g7e(&mut self) -> _G7eW {
                _G7eW { w: self }
            }
            #[doc = "Bit 5 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g6e(&mut self) -> _G6eW {
                _G6eW { w: self }
            }
            #[doc = "Bit 4 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g5e(&mut self) -> _G5eW {
                _G5eW { w: self }
            }
            #[doc = "Bit 3 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g4e(&mut self) -> _G4eW {
                _G4eW { w: self }
            }
            #[doc = "Bit 2 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g3e(&mut self) -> _G3eW {
                _G3eW { w: self }
            }
            #[doc = "Bit 1 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g2e(&mut self) -> _G2eW {
                _G2eW { w: self }
            }
            #[doc = "Bit 0 - Analog I/O group x enable"]
            #[inline ( always )]
            pub fn g1e(&mut self) -> _G1eW {
                _G1eW { w: self }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog1cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog1cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog1cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog2cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog2cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog2cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog3cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog3cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog3cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog4cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog4cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog4cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog5cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog5cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog5cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
    #[doc = "I/O group x counter register"]
    pub struct Iog6cr {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O group x counter register"]
    pub mod iog6cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Iog6cr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CntR {
            bits: u16,
        }
        impl CntR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:13 - Counter value"]
            #[inline ( always )]
            pub fn cnt(&self) -> CntR {
                let bits = {
                    const MASK: u16 = 16383;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CntR { bits }
            }
        }
    }
}
#[doc = "Touch sensing controller"]
pub struct Tsc {
    register_block: tsc::RegisterBlock,
}
impl Deref for Tsc {
    type Target = tsc::RegisterBlock;
    fn deref(&self) -> &tsc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "HDMI-CEC controller"]
pub const CEC: Peripheral<Cec> = unsafe { Peripheral::new(1073772544) };
#[doc = "HDMI-CEC controller"]
pub mod cec {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - control register"]
        pub cr: Cr,
        #[doc = "0x04 - configuration register"]
        pub cfgr: Cfgr,
        #[doc = "0x08 - Tx data register"]
        pub txdr: Txdr,
        #[doc = "0x0c - Rx Data Register"]
        pub rxdr: Rxdr,
        #[doc = "0x10 - Interrupt and Status Register"]
        pub isr: Isr,
        #[doc = "0x14 - interrupt enable register"]
        pub ier: Ier,
    }
    #[doc = "control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxeomR {
            bits: u8,
        }
        impl TxeomR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxsomR {
            bits: u8,
        }
        impl TxsomR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CECEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum CecenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CecenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    CecenR::Disabled => 0,
                    CecenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> CecenR {
                match bits {
                    0 => CecenR::Disabled,
                    1 => CecenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == CecenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == CecenR::Enabled
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxeomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxeomW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxsomW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxsomW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CECEN`"]
        pub enum CecenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl CecenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CecenW::Disabled => 0,
                    CecenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CecenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CecenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: CecenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CecenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CecenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Tx End Of Message"]
            #[inline ( always )]
            pub fn txeom(&self) -> TxeomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxeomR { bits }
            }
            #[doc = "Bit 1 - Tx start of message"]
            #[inline ( always )]
            pub fn txsom(&self) -> TxsomR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxsomR { bits }
            }
            #[doc = "Bit 0 - CEC Enable"]
            #[inline ( always )]
            pub fn cecen(&self) -> CecenR {
                CecenR::_from({
                                  const MASK: u8 = 1;
                                  const OFFSET: u8 = 0;
                                  ((self.bits >> OFFSET) & MASK as u32) as u8
                              })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Tx End Of Message"]
            #[inline ( always )]
            pub fn txeom(&mut self) -> _TxeomW {
                _TxeomW { w: self }
            }
            #[doc = "Bit 1 - Tx start of message"]
            #[inline ( always )]
            pub fn txsom(&mut self) -> _TxsomW {
                _TxsomW { w: self }
            }
            #[doc = "Bit 0 - CEC Enable"]
            #[inline ( always )]
            pub fn cecen(&mut self) -> _CecenW {
                _CecenW { w: self }
            }
        }
    }
    #[doc = "configuration register"]
    pub struct Cfgr {
        register: VolatileCell<u32>,
    }
    #[doc = "configuration register"]
    pub mod cfgr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cfgr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Possible values of the field `LBPEGEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum LbpegenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl LbpegenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    LbpegenR::Disabled => 0,
                    LbpegenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> LbpegenR {
                match bits {
                    0 => LbpegenR::Disabled,
                    1 => LbpegenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == LbpegenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == LbpegenR::Enabled
            }
        }
        #[doc = "Possible values of the field `BREGEN`"]
        #[derive ( Clone , Copy , Debug , PartialEq )]
        pub enum BregenR {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl BregenR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                match *self {
                    BregenR::Disabled => 0,
                    BregenR::Enabled => 1,
                }
            }
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _from(bits: u8) -> BregenR {
                match bits {
                    0 => BregenR::Disabled,
                    1 => BregenR::Enabled,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `Disabled`"]
            #[inline ( always )]
            pub fn is_disabled(&self) -> bool {
                *self == BregenR::Disabled
            }
            #[doc = "Checks if the value of the field is `Enabled`"]
            #[inline ( always )]
            pub fn is_enabled(&self) -> bool {
                *self == BregenR::Enabled
            }
        }
        #[doc = r" Value of the field"]
        pub struct BrestpR {
            bits: u8,
        }
        impl BrestpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxtolR {
            bits: u8,
        }
        impl RxtolR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SftR {
            bits: u8,
        }
        impl SftR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LstnR {
            bits: u8,
        }
        impl LstnR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OarR {
            bits: u8,
        }
        impl OarR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `LBPEGEN`"]
        pub enum LbpegenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl LbpegenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LbpegenW::Disabled => 0,
                    LbpegenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbpegenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbpegenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: LbpegenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LbpegenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LbpegenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BREGEN`"]
        pub enum BregenW {
            #[doc = "Disable the Rising trigger."]
            Disabled,
            #[doc = "Enable the Rising trigger."]
            Enabled,
        }
        impl BregenW {
            #[allow ( missing_docs )]
            #[doc ( hidden )]
            #[inline ( always )]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BregenW::Disabled => 0,
                    BregenW::Enabled => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BregenW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BregenW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline ( always )]
            pub fn variant(self, variant: BregenW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Disable the Rising trigger."]
            #[inline ( always )]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BregenW::Disabled)
            }
            #[doc = "Enable the Rising trigger."]
            #[inline ( always )]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BregenW::Enabled)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BrestpW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BrestpW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxtolW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxtolW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SftW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SftW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LstnW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LstnW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OarW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 11 - Generate Error-Bit on Long Bit Period Error"]
            #[inline ( always )]
            pub fn lbpegen(&self) -> LbpegenR {
                LbpegenR::_from({
                                    const MASK: u8 = 1;
                                    const OFFSET: u8 = 11;
                                    ((self.bits >> OFFSET) & MASK as u32) as u8
                                })
            }
            #[doc = "Bit 10 - Generate error-bit on bit rising error"]
            #[inline ( always )]
            pub fn bregen(&self) -> BregenR {
                BregenR::_from({
                                   const MASK: u8 = 1;
                                   const OFFSET: u8 = 10;
                                   ((self.bits >> OFFSET) & MASK as u32) as u8
                               })
            }
            #[doc = "Bit 9 - Rx-stop on bit rising error"]
            #[inline ( always )]
            pub fn brestp(&self) -> BrestpR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BrestpR { bits }
            }
            #[doc = "Bit 8 - Rx-Tolerance"]
            #[inline ( always )]
            pub fn rxtol(&self) -> RxtolR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxtolR { bits }
            }
            #[doc = "Bits 5:7 - Signal Free Time"]
            #[inline ( always )]
            pub fn sft(&self) -> SftR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SftR { bits }
            }
            #[doc = "Bit 4 - Listen mode"]
            #[inline ( always )]
            pub fn lstn(&self) -> LstnR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LstnR { bits }
            }
            #[doc = "Bits 0:3 - Own Address"]
            #[inline ( always )]
            pub fn oar(&self) -> OarR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OarR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 11 - Generate Error-Bit on Long Bit Period Error"]
            #[inline ( always )]
            pub fn lbpegen(&mut self) -> _LbpegenW {
                _LbpegenW { w: self }
            }
            #[doc = "Bit 10 - Generate error-bit on bit rising error"]
            #[inline ( always )]
            pub fn bregen(&mut self) -> _BregenW {
                _BregenW { w: self }
            }
            #[doc = "Bit 9 - Rx-stop on bit rising error"]
            #[inline ( always )]
            pub fn brestp(&mut self) -> _BrestpW {
                _BrestpW { w: self }
            }
            #[doc = "Bit 8 - Rx-Tolerance"]
            #[inline ( always )]
            pub fn rxtol(&mut self) -> _RxtolW {
                _RxtolW { w: self }
            }
            #[doc = "Bits 5:7 - Signal Free Time"]
            #[inline ( always )]
            pub fn sft(&mut self) -> _SftW {
                _SftW { w: self }
            }
            #[doc = "Bit 4 - Listen mode"]
            #[inline ( always )]
            pub fn lstn(&mut self) -> _LstnW {
                _LstnW { w: self }
            }
            #[doc = "Bits 0:3 - Own Address"]
            #[inline ( always )]
            pub fn oar(&mut self) -> _OarW {
                _OarW { w: self }
            }
        }
    }
    #[doc = "Tx data register"]
    pub struct Txdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Tx data register"]
    pub mod txdr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Txdr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxdW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxdW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Tx Data register"]
            #[inline ( always )]
            pub fn txd(&mut self) -> _TxdW {
                _TxdW { w: self }
            }
        }
    }
    #[doc = "Rx Data Register"]
    pub struct Rxdr {
        register: VolatileCell<u32>,
    }
    #[doc = "Rx Data Register"]
    pub mod rxdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Rxdr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxdrR {
            bits: u8,
        }
        impl RxdrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CEC Rx Data Register"]
            #[inline ( always )]
            pub fn rxdr(&self) -> RxdrR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxdrR { bits }
            }
        }
    }
    #[doc = "Interrupt and Status Register"]
    pub struct Isr {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt and Status Register"]
    pub mod isr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Isr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxackeR {
            bits: u8,
        }
        impl TxackeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxerrR {
            bits: u8,
        }
        impl TxerrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxudrR {
            bits: u8,
        }
        impl TxudrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxendR {
            bits: u8,
        }
        impl TxendR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxbrR {
            bits: u8,
        }
        impl TxbrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArblstR {
            bits: u8,
        }
        impl ArblstR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxackeR {
            bits: u8,
        }
        impl RxackeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbpeR {
            bits: u8,
        }
        impl LbpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbpeR {
            bits: u8,
        }
        impl SbpeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BreR {
            bits: u8,
        }
        impl BreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxovrR {
            bits: u8,
        }
        impl RxovrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxendR {
            bits: u8,
        }
        impl RxendR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxbrR {
            bits: u8,
        }
        impl RxbrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxackeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxackeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxerrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxudrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxudrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxendW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxbrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxbrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArblstW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArblstW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxackeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxackeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SbpeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbpeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxovrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxovrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxendW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxendW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxbrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxbrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Tx-Missing acknowledge error"]
            #[inline ( always )]
            pub fn txacke(&self) -> TxackeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxackeR { bits }
            }
            #[doc = "Bit 11 - Tx-Error"]
            #[inline ( always )]
            pub fn txerr(&self) -> TxerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxerrR { bits }
            }
            #[doc = "Bit 10 - Tx-Buffer Underrun"]
            #[inline ( always )]
            pub fn txudr(&self) -> TxudrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxudrR { bits }
            }
            #[doc = "Bit 9 - End of Transmission"]
            #[inline ( always )]
            pub fn txend(&self) -> TxendR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxendR { bits }
            }
            #[doc = "Bit 8 - Tx-Byte Request"]
            #[inline ( always )]
            pub fn txbr(&self) -> TxbrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxbrR { bits }
            }
            #[doc = "Bit 7 - Arbitration Lost"]
            #[inline ( always )]
            pub fn arblst(&self) -> ArblstR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArblstR { bits }
            }
            #[doc = "Bit 6 - Rx-Missing Acknowledge"]
            #[inline ( always )]
            pub fn rxacke(&self) -> RxackeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxackeR { bits }
            }
            #[doc = "Bit 5 - Rx-Long Bit Period Error"]
            #[inline ( always )]
            pub fn lbpe(&self) -> LbpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbpeR { bits }
            }
            #[doc = "Bit 4 - Rx-Short Bit period error"]
            #[inline ( always )]
            pub fn sbpe(&self) -> SbpeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbpeR { bits }
            }
            #[doc = "Bit 3 - Rx-Bit rising error"]
            #[inline ( always )]
            pub fn bre(&self) -> BreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BreR { bits }
            }
            #[doc = "Bit 2 - Rx-Overrun"]
            #[inline ( always )]
            pub fn rxovr(&self) -> RxovrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxovrR { bits }
            }
            #[doc = "Bit 1 - End Of Reception"]
            #[inline ( always )]
            pub fn rxend(&self) -> RxendR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxendR { bits }
            }
            #[doc = "Bit 0 - Rx-Byte Received"]
            #[inline ( always )]
            pub fn rxbr(&self) -> RxbrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxbrR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Tx-Missing acknowledge error"]
            #[inline ( always )]
            pub fn txacke(&mut self) -> _TxackeW {
                _TxackeW { w: self }
            }
            #[doc = "Bit 11 - Tx-Error"]
            #[inline ( always )]
            pub fn txerr(&mut self) -> _TxerrW {
                _TxerrW { w: self }
            }
            #[doc = "Bit 10 - Tx-Buffer Underrun"]
            #[inline ( always )]
            pub fn txudr(&mut self) -> _TxudrW {
                _TxudrW { w: self }
            }
            #[doc = "Bit 9 - End of Transmission"]
            #[inline ( always )]
            pub fn txend(&mut self) -> _TxendW {
                _TxendW { w: self }
            }
            #[doc = "Bit 8 - Tx-Byte Request"]
            #[inline ( always )]
            pub fn txbr(&mut self) -> _TxbrW {
                _TxbrW { w: self }
            }
            #[doc = "Bit 7 - Arbitration Lost"]
            #[inline ( always )]
            pub fn arblst(&mut self) -> _ArblstW {
                _ArblstW { w: self }
            }
            #[doc = "Bit 6 - Rx-Missing Acknowledge"]
            #[inline ( always )]
            pub fn rxacke(&mut self) -> _RxackeW {
                _RxackeW { w: self }
            }
            #[doc = "Bit 5 - Rx-Long Bit Period Error"]
            #[inline ( always )]
            pub fn lbpe(&mut self) -> _LbpeW {
                _LbpeW { w: self }
            }
            #[doc = "Bit 4 - Rx-Short Bit period error"]
            #[inline ( always )]
            pub fn sbpe(&mut self) -> _SbpeW {
                _SbpeW { w: self }
            }
            #[doc = "Bit 3 - Rx-Bit rising error"]
            #[inline ( always )]
            pub fn bre(&mut self) -> _BreW {
                _BreW { w: self }
            }
            #[doc = "Bit 2 - Rx-Overrun"]
            #[inline ( always )]
            pub fn rxovr(&mut self) -> _RxovrW {
                _RxovrW { w: self }
            }
            #[doc = "Bit 1 - End Of Reception"]
            #[inline ( always )]
            pub fn rxend(&mut self) -> _RxendW {
                _RxendW { w: self }
            }
            #[doc = "Bit 0 - Rx-Byte Received"]
            #[inline ( always )]
            pub fn rxbr(&mut self) -> _RxbrW {
                _RxbrW { w: self }
            }
        }
    }
    #[doc = "interrupt enable register"]
    pub struct Ier {
        register: VolatileCell<u32>,
    }
    #[doc = "interrupt enable register"]
    pub mod ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ier {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxackieR {
            bits: u8,
        }
        impl TxackieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxerrieR {
            bits: u8,
        }
        impl TxerrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxudrieR {
            bits: u8,
        }
        impl TxudrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxendieR {
            bits: u8,
        }
        impl TxendieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TxbrieR {
            bits: u8,
        }
        impl TxbrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ArblstieR {
            bits: u8,
        }
        impl ArblstieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxackieR {
            bits: u8,
        }
        impl RxackieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LbpeieR {
            bits: u8,
        }
        impl LbpeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SbpeieR {
            bits: u8,
        }
        impl SbpeieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BreieR {
            bits: u8,
        }
        impl BreieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxovrieR {
            bits: u8,
        }
        impl RxovrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxendieR {
            bits: u8,
        }
        impl RxendieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RxbrieR {
            bits: u8,
        }
        impl RxbrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxackieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxerrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxerrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxudrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxudrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxendieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxendieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TxbrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TxbrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ArblstieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ArblstieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxackieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxackieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LbpeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LbpeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SbpeieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SbpeieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BreieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BreieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxovrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxovrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxendieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxendieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RxbrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RxbrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - Tx-Missing Acknowledge Error Interrupt Enable"]
            #[inline ( always )]
            pub fn txackie(&self) -> TxackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxackieR { bits }
            }
            #[doc = "Bit 11 - Tx-Error Interrupt Enable"]
            #[inline ( always )]
            pub fn txerrie(&self) -> TxerrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxerrieR { bits }
            }
            #[doc = "Bit 10 - Tx-Underrun interrupt enable"]
            #[inline ( always )]
            pub fn txudrie(&self) -> TxudrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxudrieR { bits }
            }
            #[doc = "Bit 9 - Tx-End of message interrupt enable"]
            #[inline ( always )]
            pub fn txendie(&self) -> TxendieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxendieR { bits }
            }
            #[doc = "Bit 8 - Tx-Byte Request Interrupt Enable"]
            #[inline ( always )]
            pub fn txbrie(&self) -> TxbrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TxbrieR { bits }
            }
            #[doc = "Bit 7 - Arbitration Lost Interrupt Enable"]
            #[inline ( always )]
            pub fn arblstie(&self) -> ArblstieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ArblstieR { bits }
            }
            #[doc = "Bit 6 - Rx-Missing Acknowledge Error Interrupt Enable"]
            #[inline ( always )]
            pub fn rxackie(&self) -> RxackieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxackieR { bits }
            }
            #[doc = "Bit 5 - Long Bit Period Error Interrupt Enable"]
            #[inline ( always )]
            pub fn lbpeie(&self) -> LbpeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LbpeieR { bits }
            }
            #[doc = "Bit 4 - Short Bit Period Error Interrupt Enable"]
            #[inline ( always )]
            pub fn sbpeie(&self) -> SbpeieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SbpeieR { bits }
            }
            #[doc = "Bit 3 - Bit Rising Error Interrupt Enable"]
            #[inline ( always )]
            pub fn breie(&self) -> BreieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BreieR { bits }
            }
            #[doc = "Bit 2 - Rx-Buffer Overrun Interrupt Enable"]
            #[inline ( always )]
            pub fn rxovrie(&self) -> RxovrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxovrieR { bits }
            }
            #[doc = "Bit 1 - End Of Reception Interrupt Enable"]
            #[inline ( always )]
            pub fn rxendie(&self) -> RxendieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxendieR { bits }
            }
            #[doc = "Bit 0 - Rx-Byte Received Interrupt Enable"]
            #[inline ( always )]
            pub fn rxbrie(&self) -> RxbrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RxbrieR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - Tx-Missing Acknowledge Error Interrupt Enable"]
            #[inline ( always )]
            pub fn txackie(&mut self) -> _TxackieW {
                _TxackieW { w: self }
            }
            #[doc = "Bit 11 - Tx-Error Interrupt Enable"]
            #[inline ( always )]
            pub fn txerrie(&mut self) -> _TxerrieW {
                _TxerrieW { w: self }
            }
            #[doc = "Bit 10 - Tx-Underrun interrupt enable"]
            #[inline ( always )]
            pub fn txudrie(&mut self) -> _TxudrieW {
                _TxudrieW { w: self }
            }
            #[doc = "Bit 9 - Tx-End of message interrupt enable"]
            #[inline ( always )]
            pub fn txendie(&mut self) -> _TxendieW {
                _TxendieW { w: self }
            }
            #[doc = "Bit 8 - Tx-Byte Request Interrupt Enable"]
            #[inline ( always )]
            pub fn txbrie(&mut self) -> _TxbrieW {
                _TxbrieW { w: self }
            }
            #[doc = "Bit 7 - Arbitration Lost Interrupt Enable"]
            #[inline ( always )]
            pub fn arblstie(&mut self) -> _ArblstieW {
                _ArblstieW { w: self }
            }
            #[doc = "Bit 6 - Rx-Missing Acknowledge Error Interrupt Enable"]
            #[inline ( always )]
            pub fn rxackie(&mut self) -> _RxackieW {
                _RxackieW { w: self }
            }
            #[doc = "Bit 5 - Long Bit Period Error Interrupt Enable"]
            #[inline ( always )]
            pub fn lbpeie(&mut self) -> _LbpeieW {
                _LbpeieW { w: self }
            }
            #[doc = "Bit 4 - Short Bit Period Error Interrupt Enable"]
            #[inline ( always )]
            pub fn sbpeie(&mut self) -> _SbpeieW {
                _SbpeieW { w: self }
            }
            #[doc = "Bit 3 - Bit Rising Error Interrupt Enable"]
            #[inline ( always )]
            pub fn breie(&mut self) -> _BreieW {
                _BreieW { w: self }
            }
            #[doc = "Bit 2 - Rx-Buffer Overrun Interrupt Enable"]
            #[inline ( always )]
            pub fn rxovrie(&mut self) -> _RxovrieW {
                _RxovrieW { w: self }
            }
            #[doc = "Bit 1 - End Of Reception Interrupt Enable"]
            #[inline ( always )]
            pub fn rxendie(&mut self) -> _RxendieW {
                _RxendieW { w: self }
            }
            #[doc = "Bit 0 - Rx-Byte Received Interrupt Enable"]
            #[inline ( always )]
            pub fn rxbrie(&mut self) -> _RxbrieW {
                _RxbrieW { w: self }
            }
        }
    }
}
#[doc = "HDMI-CEC controller"]
pub struct Cec {
    register_block: cec::RegisterBlock,
}
impl Deref for Cec {
    type Target = cec::RegisterBlock;
    fn deref(&self) -> &cec::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Flash"]
pub const FLASH: Peripheral<Flash> = unsafe { Peripheral::new(1073881088) };
#[doc = "Flash"]
pub mod flash {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - Flash access control register"]
        pub acr: Acr,
        #[doc = "0x04 - Flash key register"]
        pub keyr: Keyr,
        #[doc = "0x08 - Flash option key register"]
        pub optkeyr: Optkeyr,
        #[doc = "0x0c - Flash status register"]
        pub sr: Sr,
        #[doc = "0x10 - Flash control register"]
        pub cr: Cr,
        #[doc = "0x14 - Flash address register"]
        pub ar: Ar,
        _reserved0: [u8; 4usize],
        #[doc = "0x1c - Option byte register"]
        pub obr: Obr,
        #[doc = "0x20 - Write protection register"]
        pub wrpr: Wrpr,
    }
    #[doc = "Flash access control register"]
    pub struct Acr {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash access control register"]
    pub mod acr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Acr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct LatencyR {
            bits: u8,
        }
        impl LatencyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PrftbeR {
            bits: u8,
        }
        impl PrftbeR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PrftbsR {
            bits: u8,
        }
        impl PrftbsR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LatencyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LatencyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PrftbeW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PrftbeW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - LATENCY"]
            #[inline ( always )]
            pub fn latency(&self) -> LatencyR {
                let bits = {
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LatencyR { bits }
            }
            #[doc = "Bit 4 - PRFTBE"]
            #[inline ( always )]
            pub fn prftbe(&self) -> PrftbeR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrftbeR { bits }
            }
            #[doc = "Bit 5 - PRFTBS"]
            #[inline ( always )]
            pub fn prftbs(&self) -> PrftbsR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PrftbsR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 48 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - LATENCY"]
            #[inline ( always )]
            pub fn latency(&mut self) -> _LatencyW {
                _LatencyW { w: self }
            }
            #[doc = "Bit 4 - PRFTBE"]
            #[inline ( always )]
            pub fn prftbe(&mut self) -> _PrftbeW {
                _PrftbeW { w: self }
            }
        }
    }
    #[doc = "Flash key register"]
    pub struct Keyr {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash key register"]
    pub mod keyr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Keyr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FkeyrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FkeyrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Flash Key"]
            #[inline ( always )]
            pub fn fkeyr(&mut self) -> _FkeyrW {
                _FkeyrW { w: self }
            }
        }
    }
    #[doc = "Flash option key register"]
    pub struct Optkeyr {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash option key register"]
    pub mod optkeyr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Optkeyr {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _OptkeyrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptkeyrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Option byte key"]
            #[inline ( always )]
            pub fn optkeyr(&mut self) -> _OptkeyrW {
                _OptkeyrW { w: self }
            }
        }
    }
    #[doc = "Flash status register"]
    pub struct Sr {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash status register"]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Sr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct EopR {
            bits: u8,
        }
        impl EopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WrprtR {
            bits: u8,
        }
        impl WrprtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PgerrR {
            bits: u8,
        }
        impl PgerrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BsyR {
            bits: u8,
        }
        impl BsyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _EopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WrprtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WrprtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PgerrW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PgerrW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 5 - End of operation"]
            #[inline ( always )]
            pub fn eop(&self) -> EopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EopR { bits }
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline ( always )]
            pub fn wrprt(&self) -> WrprtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WrprtR { bits }
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline ( always )]
            pub fn pgerr(&self) -> PgerrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PgerrR { bits }
            }
            #[doc = "Bit 0 - Busy"]
            #[inline ( always )]
            pub fn bsy(&self) -> BsyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BsyR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 5 - End of operation"]
            #[inline ( always )]
            pub fn eop(&mut self) -> _EopW {
                _EopW { w: self }
            }
            #[doc = "Bit 4 - Write protection error"]
            #[inline ( always )]
            pub fn wrprt(&mut self) -> _WrprtW {
                _WrprtW { w: self }
            }
            #[doc = "Bit 2 - Programming error"]
            #[inline ( always )]
            pub fn pgerr(&mut self) -> _PgerrW {
                _PgerrW { w: self }
            }
        }
    }
    #[doc = "Flash control register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash control register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct ForceOptloadR {
            bits: u8,
        }
        impl ForceOptloadR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct EopieR {
            bits: u8,
        }
        impl EopieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ErrieR {
            bits: u8,
        }
        impl ErrieR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OptwreR {
            bits: u8,
        }
        impl OptwreR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LockR {
            bits: u8,
        }
        impl LockR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct StrtR {
            bits: u8,
        }
        impl StrtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpterR {
            bits: u8,
        }
        impl OpterR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OptpgR {
            bits: u8,
        }
        impl OptpgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MerR {
            bits: u8,
        }
        impl MerR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PerR {
            bits: u8,
        }
        impl PerR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct PgR {
            bits: u8,
        }
        impl PgR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ForceOptloadW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ForceOptloadW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EopieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EopieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ErrieW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ErrieW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OptwreW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptwreW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LockW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LockW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _StrtW<'a> {
            w: &'a mut W,
        }
        impl<'a> _StrtW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OpterW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OpterW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OptpgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OptpgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MerW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PerW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PerW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PgW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PgW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 13 - Force option byte loading"]
            #[inline ( always )]
            pub fn force_optload(&self) -> ForceOptloadR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ForceOptloadR { bits }
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline ( always )]
            pub fn eopie(&self) -> EopieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                EopieR { bits }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline ( always )]
            pub fn errie(&self) -> ErrieR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ErrieR { bits }
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline ( always )]
            pub fn optwre(&self) -> OptwreR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OptwreR { bits }
            }
            #[doc = "Bit 7 - Lock"]
            #[inline ( always )]
            pub fn lock(&self) -> LockR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LockR { bits }
            }
            #[doc = "Bit 6 - Start"]
            #[inline ( always )]
            pub fn strt(&self) -> StrtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                StrtR { bits }
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline ( always )]
            pub fn opter(&self) -> OpterR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpterR { bits }
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline ( always )]
            pub fn optpg(&self) -> OptpgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OptpgR { bits }
            }
            #[doc = "Bit 2 - Mass erase"]
            #[inline ( always )]
            pub fn mer(&self) -> MerR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MerR { bits }
            }
            #[doc = "Bit 1 - Page erase"]
            #[inline ( always )]
            pub fn per(&self) -> PerR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PerR { bits }
            }
            #[doc = "Bit 0 - Programming"]
            #[inline ( always )]
            pub fn pg(&self) -> PgR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PgR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 13 - Force option byte loading"]
            #[inline ( always )]
            pub fn force_optload(&mut self) -> _ForceOptloadW {
                _ForceOptloadW { w: self }
            }
            #[doc = "Bit 12 - End of operation interrupt enable"]
            #[inline ( always )]
            pub fn eopie(&mut self) -> _EopieW {
                _EopieW { w: self }
            }
            #[doc = "Bit 10 - Error interrupt enable"]
            #[inline ( always )]
            pub fn errie(&mut self) -> _ErrieW {
                _ErrieW { w: self }
            }
            #[doc = "Bit 9 - Option bytes write enable"]
            #[inline ( always )]
            pub fn optwre(&mut self) -> _OptwreW {
                _OptwreW { w: self }
            }
            #[doc = "Bit 7 - Lock"]
            #[inline ( always )]
            pub fn lock(&mut self) -> _LockW {
                _LockW { w: self }
            }
            #[doc = "Bit 6 - Start"]
            #[inline ( always )]
            pub fn strt(&mut self) -> _StrtW {
                _StrtW { w: self }
            }
            #[doc = "Bit 5 - Option byte erase"]
            #[inline ( always )]
            pub fn opter(&mut self) -> _OpterW {
                _OpterW { w: self }
            }
            #[doc = "Bit 4 - Option byte programming"]
            #[inline ( always )]
            pub fn optpg(&mut self) -> _OptpgW {
                _OptpgW { w: self }
            }
            #[doc = "Bit 2 - Mass erase"]
            #[inline ( always )]
            pub fn mer(&mut self) -> _MerW {
                _MerW { w: self }
            }
            #[doc = "Bit 1 - Page erase"]
            #[inline ( always )]
            pub fn per(&mut self) -> _PerW {
                _PerW { w: self }
            }
            #[doc = "Bit 0 - Programming"]
            #[inline ( always )]
            pub fn pg(&mut self) -> _PgW {
                _PgW { w: self }
            }
        }
    }
    #[doc = "Flash address register"]
    pub struct Ar {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash address register"]
    pub mod ar {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Ar {
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FarW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FarW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Flash address"]
            #[inline ( always )]
            pub fn far(&mut self) -> _FarW {
                _FarW { w: self }
            }
        }
    }
    #[doc = "Option byte register"]
    pub struct Obr {
        register: VolatileCell<u32>,
    }
    #[doc = "Option byte register"]
    pub mod obr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Obr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct Data1R {
            bits: u8,
        }
        impl Data1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Data0R {
            bits: u8,
        }
        impl Data0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct VddaMonitorR {
            bits: u8,
        }
        impl VddaMonitorR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Boot1R {
            bits: u8,
        }
        impl Boot1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRstStdbyR {
            bits: u8,
        }
        impl NRstStdbyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NRstStopR {
            bits: u8,
        }
        impl NRstStopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct WdgSwR {
            bits: u8,
        }
        impl WdgSwR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Level2ProtR {
            bits: u8,
        }
        impl Level2ProtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct Level1ProtR {
            bits: u8,
        }
        impl Level1ProtR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OpterrR {
            bits: u8,
        }
        impl OpterrR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 24:31 - Data1"]
            #[inline ( always )]
            pub fn data1(&self) -> Data1R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Data1R { bits }
            }
            #[doc = "Bits 16:23 - Data0"]
            #[inline ( always )]
            pub fn data0(&self) -> Data0R {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Data0R { bits }
            }
            #[doc = "Bit 13 - VDDA_MONITOR"]
            #[inline ( always )]
            pub fn vdda_monitor(&self) -> VddaMonitorR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VddaMonitorR { bits }
            }
            #[doc = "Bit 12 - BOOT1"]
            #[inline ( always )]
            pub fn boot1(&self) -> Boot1R {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Boot1R { bits }
            }
            #[doc = "Bit 10 - nRST_STDBY"]
            #[inline ( always )]
            pub fn n_rst_stdby(&self) -> NRstStdbyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NRstStdbyR { bits }
            }
            #[doc = "Bit 9 - nRST_STOP"]
            #[inline ( always )]
            pub fn n_rst_stop(&self) -> NRstStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NRstStopR { bits }
            }
            #[doc = "Bit 8 - WDG_SW"]
            #[inline ( always )]
            pub fn wdg_sw(&self) -> WdgSwR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                WdgSwR { bits }
            }
            #[doc = "Bit 2 - Level 2 protection status"]
            #[inline ( always )]
            pub fn level2_prot(&self) -> Level2ProtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Level2ProtR { bits }
            }
            #[doc = "Bit 1 - Level 1 protection status"]
            #[inline ( always )]
            pub fn level1_prot(&self) -> Level1ProtR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                Level1ProtR { bits }
            }
            #[doc = "Bit 0 - Option byte error"]
            #[inline ( always )]
            pub fn opterr(&self) -> OpterrR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OpterrR { bits }
            }
        }
    }
    #[doc = "Write protection register"]
    pub struct Wrpr {
        register: VolatileCell<u32>,
    }
    #[doc = "Write protection register"]
    pub mod wrpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Wrpr {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct WrpR {
            bits: u16,
        }
        impl WrpR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Write protect"]
            #[inline ( always )]
            pub fn wrp(&self) -> WrpR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                WrpR { bits }
            }
        }
    }
}
#[doc = "Flash"]
pub struct Flash {
    register_block: flash::RegisterBlock,
}
impl Deref for Flash {
    type Target = flash::RegisterBlock;
    fn deref(&self) -> &flash::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Debug support"]
pub const DBGMCU: Peripheral<Dbgmcu> = unsafe { Peripheral::new(1073829888) };
#[doc = "Debug support"]
pub mod dbgmcu {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr ( C )]
    pub struct RegisterBlock {
        #[doc = "0x00 - MCU Device ID Code Register"]
        pub idcode: Idcode,
        #[doc = "0x04 - Debug MCU Configuration Register"]
        pub cr: Cr,
        #[doc = "0x08 - APB Low Freeze Register"]
        pub apblfz: Apblfz,
        #[doc = "0x0c - APB High Freeze Register"]
        pub apbhfz: Apbhfz,
    }
    #[doc = "MCU Device ID Code Register"]
    pub struct Idcode {
        register: VolatileCell<u32>,
    }
    #[doc = "MCU Device ID Code Register"]
    pub mod idcode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::Idcode {
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DevIdR {
            bits: u16,
        }
        impl DevIdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DivIdR {
            bits: u8,
        }
        impl DivIdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RevIdR {
            bits: u16,
        }
        impl RevIdR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - Device Identifier"]
            #[inline ( always )]
            pub fn dev_id(&self) -> DevIdR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DevIdR { bits }
            }
            #[doc = "Bits 12:15 - Division Identifier"]
            #[inline ( always )]
            pub fn div_id(&self) -> DivIdR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DivIdR { bits }
            }
            #[doc = "Bits 16:31 - Revision Identifier"]
            #[inline ( always )]
            pub fn rev_id(&self) -> RevIdR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RevIdR { bits }
            }
        }
    }
    #[doc = "Debug MCU Configuration Register"]
    pub struct Cr {
        register: VolatileCell<u32>,
    }
    #[doc = "Debug MCU Configuration Register"]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Cr {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgStopR {
            bits: u8,
        }
        impl DbgStopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgStandbyR {
            bits: u8,
        }
        impl DbgStandbyR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgStopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgStandbyW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgStandbyW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Debug Stop Mode"]
            #[inline ( always )]
            pub fn dbg_stop(&self) -> DbgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgStopR { bits }
            }
            #[doc = "Bit 2 - Debug Standby Mode"]
            #[inline ( always )]
            pub fn dbg_standby(&self) -> DbgStandbyR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgStandbyR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Debug Stop Mode"]
            #[inline ( always )]
            pub fn dbg_stop(&mut self) -> _DbgStopW {
                _DbgStopW { w: self }
            }
            #[doc = "Bit 2 - Debug Standby Mode"]
            #[inline ( always )]
            pub fn dbg_standby(&mut self) -> _DbgStandbyW {
                _DbgStandbyW { w: self }
            }
        }
    }
    #[doc = "APB Low Freeze Register"]
    pub struct Apblfz {
        register: VolatileCell<u32>,
    }
    #[doc = "APB Low Freeze Register"]
    pub mod apblfz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apblfz {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer2StopR {
            bits: u8,
        }
        impl DbgTimer2StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer3StopR {
            bits: u8,
        }
        impl DbgTimer3StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer6StopR {
            bits: u8,
        }
        impl DbgTimer6StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer14StopR {
            bits: u8,
        }
        impl DbgTimer14StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgRtcStopR {
            bits: u8,
        }
        impl DbgRtcStopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgWwdgStopR {
            bits: u8,
        }
        impl DbgWwdgStopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgIwdgStopR {
            bits: u8,
        }
        impl DbgIwdgStopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2c1SmbusTimeoutR {
            bits: u8,
        }
        impl I2c1SmbusTimeoutR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer2StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer2StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer3StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer3StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer6StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer6StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer14StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer14StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgRtcStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgRtcStopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgWwdgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgWwdgStopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgIwdgStopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgIwdgStopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2c1SmbusTimeoutW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2c1SmbusTimeoutW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer2_stop(&self) -> DbgTimer2StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer2StopR { bits }
            }
            #[doc = "Bit 1 - Debug Timer 3 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer3_stop(&self) -> DbgTimer3StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer3StopR { bits }
            }
            #[doc = "Bit 4 - Debug Timer 6 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer6_stop(&self) -> DbgTimer6StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer6StopR { bits }
            }
            #[doc = "Bit 8 - Debug Timer 14 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer14_stop(&self) -> DbgTimer14StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer14StopR { bits }
            }
            #[doc = "Bit 10 - Debug RTC stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_rtc_stop(&self) -> DbgRtcStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgRtcStopR { bits }
            }
            #[doc = "Bit 11 - Debug Window Wachdog stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_wwdg_stop(&self) -> DbgWwdgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgWwdgStopR { bits }
            }
            #[doc = "Bit 12 - Debug Independent Wachdog stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_iwdg_stop(&self) -> DbgIwdgStopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgIwdgStopR { bits }
            }
            #[doc = "Bit 21 - SMBUS timeout mode stopped when Core is halted"]
            #[inline ( always )]
            pub fn i2c1_smbus_timeout(&self) -> I2c1SmbusTimeoutR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2c1SmbusTimeoutR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Debug Timer 2 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer2_stop(&mut self) -> _DbgTimer2StopW {
                _DbgTimer2StopW { w: self }
            }
            #[doc = "Bit 1 - Debug Timer 3 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer3_stop(&mut self) -> _DbgTimer3StopW {
                _DbgTimer3StopW { w: self }
            }
            #[doc = "Bit 4 - Debug Timer 6 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer6_stop(&mut self) -> _DbgTimer6StopW {
                _DbgTimer6StopW { w: self }
            }
            #[doc = "Bit 8 - Debug Timer 14 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer14_stop(&mut self) -> _DbgTimer14StopW {
                _DbgTimer14StopW { w: self }
            }
            #[doc = "Bit 10 - Debug RTC stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_rtc_stop(&mut self) -> _DbgRtcStopW {
                _DbgRtcStopW { w: self }
            }
            #[doc = "Bit 11 - Debug Window Wachdog stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_wwdg_stop(&mut self) -> _DbgWwdgStopW {
                _DbgWwdgStopW { w: self }
            }
            #[doc = "Bit 12 - Debug Independent Wachdog stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_iwdg_stop(&mut self) -> _DbgIwdgStopW {
                _DbgIwdgStopW { w: self }
            }
            #[doc = "Bit 21 - SMBUS timeout mode stopped when Core is halted"]
            #[inline ( always )]
            pub fn i2c1_smbus_timeout(&mut self) -> _I2c1SmbusTimeoutW {
                _I2c1SmbusTimeoutW { w: self }
            }
        }
    }
    #[doc = "APB High Freeze Register"]
    pub struct Apbhfz {
        register: VolatileCell<u32>,
    }
    #[doc = "APB High Freeze Register"]
    pub mod apbhfz {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::Apbhfz {
            #[doc = r" Modifies the contents of the register"]
            #[inline ( always )]
            pub fn modify<F>(&self, f: F)
                where for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline ( always )]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline ( always )]
            pub fn write<F>(&self, f: F)
                where F: FnOnce(&mut W) -> &mut W
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer1StopR {
            bits: u8,
        }
        impl DbgTimer1StopR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer15StoR {
            bits: u8,
        }
        impl DbgTimer15StoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer16StoR {
            bits: u8,
        }
        impl DbgTimer16StoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DbgTimer17StoR {
            bits: u8,
        }
        impl DbgTimer17StoR {
            #[doc = r" Value of the field as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer1StopW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer1StopW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer15StoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer15StoW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer16StoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer16StoW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DbgTimer17StoW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DbgTimer17StoW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline ( always )]
            pub unsafe fn bits(self, bits: u8) -> &'a mut W {
                const MASK: u8 = 1;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((bits & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline ( always )]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 11 - Debug Timer 1 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer1_stop(&self) -> DbgTimer1StopR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer1StopR { bits }
            }
            #[doc = "Bit 16 - Debug Timer 15 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer15_sto(&self) -> DbgTimer15StoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer15StoR { bits }
            }
            #[doc = "Bit 17 - Debug Timer 16 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer16_sto(&self) -> DbgTimer16StoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer16StoR { bits }
            }
            #[doc = "Bit 18 - Debug Timer 17 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer17_sto(&self) -> DbgTimer17StoR {
                let bits = {
                    const MASK: u8 = 1;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DbgTimer17StoR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline ( always )]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline ( always )]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 11 - Debug Timer 1 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer1_stop(&mut self) -> _DbgTimer1StopW {
                _DbgTimer1StopW { w: self }
            }
            #[doc = "Bit 16 - Debug Timer 15 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer15_sto(&mut self) -> _DbgTimer15StoW {
                _DbgTimer15StoW { w: self }
            }
            #[doc = "Bit 17 - Debug Timer 16 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer16_sto(&mut self) -> _DbgTimer16StoW {
                _DbgTimer16StoW { w: self }
            }
            #[doc = "Bit 18 - Debug Timer 17 stopped when Core is halted"]
            #[inline ( always )]
            pub fn dbg_timer17_sto(&mut self) -> _DbgTimer17StoW {
                _DbgTimer17StoW { w: self }
            }
        }
    }
}
#[doc = "Debug support"]
pub struct Dbgmcu {
    register_block: dbgmcu::RegisterBlock,
}
impl Deref for Dbgmcu {
    type Target = dbgmcu::RegisterBlock;
    fn deref(&self) -> &dbgmcu::RegisterBlock {
        &self.register_block
    }
}
